<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>my github page</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="markdown build page.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/style1.css">


    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');
                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }
                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="study_todo.html"><strong aria-hidden="true">1.</strong> 学习任务</a></li><li class="chapter-item expanded "><a href="xbell/init.html"><strong aria-hidden="true">2.</strong> xbell</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="xbell/@ControllerAdvice的介绍及三种用法.html"><strong aria-hidden="true">2.1.</strong> @ControllerAdvice的介绍及三种用法</a></li><li class="chapter-item "><a href="xbell/excel处理.html"><strong aria-hidden="true">2.2.</strong> excel处理</a></li><li class="chapter-item "><a href="xbell/Guava文件操作.html"><strong aria-hidden="true">2.3.</strong> Guava文件操作</a></li><li class="chapter-item "><a href="xbell/SpringDataJpa复杂动态查询方式总结.html"><strong aria-hidden="true">2.4.</strong> SpringDataJpa复杂动态查询方式总结</a></li><li class="chapter-item "><a href="xbell/使用SpringDataJPA进行数据分页与排序.html"><strong aria-hidden="true">2.5.</strong> 使用SpringDataJPA进行数据分页与排序</a></li><li class="chapter-item "><a href="xbell/参数校验.html"><strong aria-hidden="true">2.6.</strong> 参数校验</a></li><li class="chapter-item "><a href="xbell/实习记录.html"><strong aria-hidden="true">2.7.</strong> 实习记录</a></li><li class="chapter-item "><a href="xbell/知识点(java).html"><strong aria-hidden="true">2.8.</strong> 知识点(java)</a></li><li class="chapter-item "><a href="xbell/知识点(javascript).html"><strong aria-hidden="true">2.9.</strong> 知识点(javascript)</a></li></ol></li><li class="chapter-item expanded "><a href="golang/init.html"><strong aria-hidden="true">3.</strong> golang知识</a></li><li class="chapter-item expanded "><a href="java/init.html"><strong aria-hidden="true">4.</strong> java知识</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="java/spring/init.html"><strong aria-hidden="true">4.1.</strong> spring</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="java/spring/@postMapping使用.html"><strong aria-hidden="true">4.1.1.</strong> @postMapping使用</a></li></ol></li><li class="chapter-item "><a href="java/0杂项.html"><strong aria-hidden="true">4.2.</strong> 0杂项</a></li><li class="chapter-item "><a href="java/@Column注解及属性详解.html"><strong aria-hidden="true">4.3.</strong> @Column注解及属性详解</a></li><li class="chapter-item "><a href="java/@RequestBody的使用.html"><strong aria-hidden="true">4.4.</strong> @RequestBody的使用</a></li><li class="chapter-item "><a href="java/Comparable和Comparator的区别.html"><strong aria-hidden="true">4.5.</strong> Comparable和Comparator的区别</a></li><li class="chapter-item "><a href="java/Druid数据库连接池.html"><strong aria-hidden="true">4.6.</strong> Druid数据库连接池</a></li><li class="chapter-item "><a href="java/Elasticsearch数据类型及其属性.html"><strong aria-hidden="true">4.7.</strong> Elasticsearch数据类型及其属性</a></li><li class="chapter-item "><a href="java/GSON.html"><strong aria-hidden="true">4.8.</strong> GSON</a></li><li class="chapter-item "><a href="java/IDEA自动部署WEB工程至远程服务器（学习笔记）.html"><strong aria-hidden="true">4.9.</strong> IDEA自动部署WEB工程至远程服务器（学习笔记）</a></li><li class="chapter-item "><a href="java/JSR303.html"><strong aria-hidden="true">4.10.</strong> JSR303</a></li><li class="chapter-item "><a href="java/JS简单实现多级Select联动菜单效果代码.html"><strong aria-hidden="true">4.11.</strong> JS简单实现多级Select联动菜单效果代码</a></li><li class="chapter-item "><a href="java/JXl常用解析详解.html"><strong aria-hidden="true">4.12.</strong> JXl常用解析详解</a></li><li class="chapter-item "><a href="java/Java8获取参数名称时无法获取参数名.html"><strong aria-hidden="true">4.13.</strong> Java8获取参数名称时无法获取参数名</a></li><li class="chapter-item "><a href="java/Java线程池分析.html"><strong aria-hidden="true">4.14.</strong> Java线程池分析</a></li><li class="chapter-item "><a href="java/Lombok的基本使用.html"><strong aria-hidden="true">4.15.</strong> Lombok的基本使用</a></li><li class="chapter-item "><a href="java/MD5.html"><strong aria-hidden="true">4.16.</strong> MD5</a></li><li class="chapter-item "><a href="java/index.html"><strong aria-hidden="true">4.17.</strong> README</a></li><li class="chapter-item "><a href="java/Redis.html"><strong aria-hidden="true">4.18.</strong> Redis</a></li><li class="chapter-item "><a href="java/Redis的五种数据类型及方法.html"><strong aria-hidden="true">4.19.</strong> Redis的五种数据类型及方法</a></li><li class="chapter-item "><a href="java/ResponseEntity实现Rest风格的返回值.html"><strong aria-hidden="true">4.20.</strong> ResponseEntity实现Rest风格的返回值</a></li><li class="chapter-item "><a href="java/时间戳和LocalDateTime和Date互转和格式化.html"><strong aria-hidden="true">4.21.</strong> 时间戳和LocalDateTime和Date互转和格式化</a></li></ol></li><li class="chapter-item expanded "><a href="ffmpeg/init.html"><strong aria-hidden="true">5.</strong> ffmpeg知识</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ffmpeg/ffmpegToolUse.html"><strong aria-hidden="true">5.1.</strong> ffmpeg工具使用</a></li><li class="chapter-item "><a href="ffmpeg/ffmpegample.html"><strong aria-hidden="true">5.2.</strong> ffmpeg示例</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">my github page</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/hqqich/hqqich.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <!-- Page table of contents -->
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        <h1 id="学习任务"><a class="header" href="#学习任务">学习任务</a></h1>
<ul>
<li><input disabled="" type="checkbox"/>
vert.x</li>
<li><input disabled="" type="checkbox"/>
gorm</li>
<li><input disabled="" type="checkbox"/>
netty</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xbell"><a class="header" href="#xbell">xbell</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="controlleradvice的介绍及三种用法"><a class="header" href="#controlleradvice的介绍及三种用法">@ControllerAdvice的介绍及三种用法</a></h1>
<blockquote>
<p><a href="https://blog.csdn.net/qq_36829919/article/details/101210250">url</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-处理-excel-表格"><a class="header" href="#java-处理-excel-表格">Java 处理 excel 表格</a></h1>
<h2 id="easyexcel-组件"><a class="header" href="#easyexcel-组件">easyExcel 组件</a></h2>
<blockquote>
<p><a href="https://www.yuque.com/easyexcel/doc">官方文档</a></p>
<p><a href="https://alibaba-easyexcel.github.io/index.html">官方文档</a></p>
<p><a href="https://github.com/alibaba/easyexcel">源码地址</a></p>
<p>参考文章：</p>
<ol>
<li><a href="https://www.jianshu.com/p/d1d264c817ef">框架篇-easyexcel使用</a></li>
<li><a href="https://www.jianshu.com/p/d1d264c817ef"></a></li>
<li><a href="https://blog.csdn.net/jianggujin/article/details/80200400">JAVA使用easyexcel操作Excel</a></li>
<li><a href="https://blog.csdn.net/xuxiannian/article/details/105029283">EasyExcel 动态表头生成且带合并</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/98042288">easyExcel 使用指南详解</a></li>
<li><a href="https://www.cnblogs.com/funnylog/p/14248982.html">EasyExcel模板填充踩坑</a></li>
<li><a href="xbell/"></a></li>
<li><a href="xbell/"></a></li>
<li><a href="xbell/"></a></li>
<li><a href="xbell/"></a></li>
</ol>
</blockquote>
<h4 id="1-引入依赖"><a class="header" href="#1-引入依赖">1. 引入依赖</a></h4>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/easyexcel --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;
    &lt;version&gt;3.0.5&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="2-简单例子实体类方式"><a class="header" href="#2-简单例子实体类方式">2. 简单例子（实体类方式）</a></h4>
<p>创建一个实体类<code>Student</code>：</p>
<pre><code class="language-java">import com.alibaba.excel.annotation.ExcelIgnore;
import com.alibaba.excel.annotation.ExcelProperty;
import com.alibaba.excel.annotation.format.DateTimeFormat;
import com.alibaba.excel.annotation.write.style.ColumnWidth;
import com.alibaba.excel.annotation.write.style.ContentRowHeight;
import com.alibaba.excel.annotation.write.style.HeadRowHeight;
import lombok.Data;
import java.io.Serializable;
import java.util.Date;

@Data
@HeadRowHeight(value = 35) // 表头行高
@ContentRowHeight(value = 25) // 内容行高
public class Student implements Serializable {

  @ExcelProperty(value = {&quot;学生信息&quot;,&quot;学生信息2&quot;,&quot;学生编号&quot;},order = 10)  //自定义title 和 order位置等级，值越大越靠后
  @ColumnWidth(20)  //自定义宽度
  @ExcelIgnore  //创建excel时忽略这个属性
  private Integer id;

  @ExcelProperty(value = {&quot;学生信息&quot;,&quot;学生信息1&quot;,&quot;学生姓名&quot;},order = 2)
  @ColumnWidth(20)
  private String name;

  @ExcelProperty(value = {&quot;学生信息&quot;,&quot;学生信息1&quot;,&quot;学生薪水&quot;},order = 1)
  @ColumnWidth(20)
  private Double salary;

  @ExcelProperty(value = {&quot;学生信息&quot;,&quot;学生信息2&quot;,&quot;学生生日&quot;},order = 11)
  @DateTimeFormat(&quot;yyyy-MM-dd&quot;)  //格式化日期 别导错了，是这个=&gt;com.alibaba.excel.annotation.format.DateTimeFormat;
  @ColumnWidth(30)
  private Date birthday;
}
</code></pre>
<p>写一个测试类：</p>
<pre><code class="language-java">public List&lt;Student&gt; getData() {
  return new ArrayList&lt;Student&gt;(){{
    for (int i = 0; i &lt; 10; i++) {
      add(new Student(i, &quot;name&quot;+i, 1000.00+i, new Date()));
    }
  }};
}

@Test
void contextLoads() {
  //第一个参数： 写出表格的文件名; 第二个参数：写到表格数据类型的class对象
  EasyExcel.write(&quot;学生信息表.xlsx&quot;, Student.class)  //创建一个表格，指定文件名，指定数据类型
      // .registerWriteHandler(new LongestMatchColumnWidthStyleStrategy())  //自适应宽度，但是这个不是特别精确
      .sheet()  //指定sheet , 可以指定名字，也可以不写，使用默认的
      .doWrite(getData());  //将数据写入表格中
}
</code></pre>
<p>运行后项目根目录就会出现一个文件</p>
<p><img src="xbell/img/20220118154701.JPG" alt="20220118154701" /></p>
<p>excel文件里就长这个样子
<img src="xbell/img/20220118190801.JPG" alt="20220118170801" /></p>
<p>还可以指定写</p>
<pre><code class="language-java">@HeadRowHeight(value = 35) // 表头行高
@ContentRowHeight(value = 25) // 内容行高
@Data
public class Student implements Serializable {

    @ExcelProperty(value = {&quot;学生信息&quot;,&quot;学生编号&quot;},order = 10)
    private Integer id;

    @ExcelProperty(value = {&quot;学生信息&quot;,&quot;学生姓名&quot;},order = 2)
    private String name;

    @ExcelProperty(value = {&quot;学生信息&quot;,&quot;学生薪水&quot;},order = 1)
    private Double salary;

    @ExcelProperty(value = {&quot;学生信息&quot;,&quot;学生生日&quot;},order = 11)
    @DateTimeFormat(&quot;yyyy-MM-dd&quot;)
    private Date birthday;
}


@Test
void contextLoads() {
    // 设置 要导出列的属性名
    // 必须要跟类型的属性名保持一致
    Set&lt;String&gt; set = new HashSet&lt;&gt;();
    set.add(&quot;id&quot;);
    set.add(&quot;name&quot;);

    EasyExcel.write(&quot;学生信息表.xlsx&quot;, Student.class)
        .includeColumnFiledNames(set)
        // 自适应宽度，但是这个不是特别精确
        .registerWriteHandler(new LongestMatchColumnWidthStyleStrategy())
        .sheet()
        .doWrite(getData());
}
</code></pre>
<h4 id="3-简单读"><a class="header" href="#3-简单读">3. 简单读</a></h4>
<p>记住，这里传入的excel 表格式一定和实体类对应，不然会现数据读不全，读错</p>
<pre><code class="language-java">@Test
  void test011(){
    List&lt;Student&gt; list = new ArrayList&lt;&gt;();
    EasyExcel.read(&quot;学生信息表.xlsx&quot;, Student.class, new AnalysisEventListener&lt;Student&gt;() {

      // 每读取一行就调用该方法
      @Override
      public void invoke(Student student, AnalysisContext analysisContext) {
        list.add(student);
      }

      // 全部读取完成就调用该方法
      @Override
      public void doAfterAllAnalysed(AnalysisContext analysisContext) {
        System.out.println(&quot;全部读取完成&quot;);
      }
    }).sheet().doRead();

    list.forEach(System.out::println);
    /**
     * 全部读取完成
     * Student(id=null, name=李四0, salary=1500.0, birthday=Tue Jan 18 09:38:35 CST 2022)
     * Student(id=null, name=李四1, salary=1500.0, birthday=Tue Jan 18 09:38:35 CST 2022)
     * Student(id=null, name=李四2, salary=1500.0, birthday=Tue Jan 18 09:38:35 CST 2022)
     * Student(id=null, name=李四3, salary=1500.0, birthday=Tue Jan 18 09:38:35 CST 2022)
     * Student(id=null, name=李四4, salary=1500.0, birthday=Tue Jan 18 09:38:35 CST 2022)
     * Student(id=null, name=李四5, salary=1500.0, birthday=Tue Jan 18 09:38:35 CST 2022)
     * Student(id=null, name=李四6, salary=1500.0, birthday=Tue Jan 18 09:38:35 CST 2022)
     * Student(id=null, name=李四7, salary=1500.0, birthday=Tue Jan 18 09:38:35 CST 2022)
     * Student(id=null, name=李四8, salary=1500.0, birthday=Tue Jan 18 09:38:35 CST 2022)
     * Student(id=null, name=李四9, salary=1500.0, birthday=Tue Jan 18 09:38:35 CST 2022)
     * Student(id=null, name=李四10, salary=1500.0, birthday=Tue Jan 18 09:38:35 CST 2022)
     */
  }
</code></pre>
<h4 id="excel工具类-excelutiljava"><a class="header" href="#excel工具类-excelutiljava">excel工具类 <code>ExcelUtil.java</code></a></h4>
<pre><code class="language-Java">package com.example.demoeasyexclespringboot.util;

import com.alibaba.excel.EasyExcel;
import com.alibaba.excel.context.AnalysisContext;
import com.alibaba.excel.event.AnalysisEventListener;
import com.alibaba.excel.read.listener.ReadListener;
import com.alibaba.excel.support.ExcelTypeEnum;
import com.alibaba.excel.write.builder.ExcelWriterBuilder;
import com.alibaba.excel.write.style.column.LongestMatchColumnWidthStyleStrategy;
import org.apache.commons.lang3.StringUtils;
import org.springframework.util.CollectionUtils;
import org.springframework.web.multipart.MultipartFile;

import javax.servlet.http.HttpServletResponse;
import java.io.*;
import java.util.*;

public class ExcelUtil {

  /**
   * 写出一个 excel 文件到本地
   * &lt;br /&gt;
   * 将类型所有加了 @ExcelProperty 注解的属性全部写出
   *
   * @param fileName  文件名 不要后缀
   * @param sheetName sheet名
   * @param data      写出的数据
   * @param clazz     要写出数据类的Class类型对象
   * @param &lt;T&gt;       写出的数据类型
   */
  public static &lt;T&gt; void writeExcel(String fileName, String sheetName, List&lt;T&gt; data, Class&lt;T&gt; clazz) {
    writeExcel(null, fileName, sheetName, data, clazz);
  }


  /**
   * 按照指定的属性名进行写出 一个 excel
   *
   * @param attrName  指定的属性名 必须与数据类型的属性名一致
   * @param fileName  文件名 不要后缀
   * @param sheetName sheet名
   * @param data      要写出的数据
   * @param clazz     要写出数据类的Class类型对象
   * @param &lt;T&gt;       要写出的数据类型
   */
  public static &lt;T&gt; void writeExcel(Set&lt;String&gt; attrName, String fileName, String sheetName, List&lt;T&gt; data, Class&lt;T&gt; clazz) {
    fileName = StringUtils.isBlank(fileName) ? &quot;学生管理系统&quot; : fileName;
    sheetName = StringUtils.isBlank(sheetName) ? &quot;sheet0&quot; : sheetName;

    try(FileOutputStream fos = new FileOutputStream(fileName)) {
      write(fos,attrName,sheetName,data,clazz);
    } catch (Exception exception) {
      exception.printStackTrace();
    }
  }

  /**
   * 读取 指定格式的 excel文档
   *
   * @param fileName 文件名
   * @param clazz    数据类型的class对象
   * @param &lt;T&gt;      数据类型
   * @return
   */
  public static &lt;T&gt; List&lt;T&gt; readExcel(String fileName, Class&lt;T&gt; clazz) {
    return readExcel(fileName, clazz, null);
  }

  /**
   * 取 指定格式的 excel文档
   * 注意一旦传入自定义监听器，则返回的list为空，数据需要在自定义监听器里面获取
   *
   * @param fileName     文件名
   * @param clazz        数据类型的class对象
   * @param readListener 自定义监听器
   * @param &lt;T&gt;          数据类型
   * @return
   */
  public static&lt;T&gt; List&lt;T&gt; readExcel(String fileName, Class&lt;T&gt; clazz, ReadListener&lt;T&gt; readListener) {
    try(FileInputStream fis = new FileInputStream(fileName)) {
      return read(fis,clazz,readListener);
    } catch (Exception exception) {
      exception.printStackTrace();
    }
    return null;
  }


  /**
   * 导出  一个 excel
   *         导出excel所有数据
   * @param response
   * @param fileName  件名 最好为英文，不要后缀名
   * @param sheetName sheet名
   * @param data      要写出的数据
   * @param clazz     要写出数据类的Class类型对象
   * @param &lt;T&gt;       要写出的数据类型
   */
  public static &lt;T&gt; void export(HttpServletResponse response, String fileName, String sheetName, List&lt;T&gt; data, Class&lt;T&gt; clazz) {
    export(response, null, fileName, sheetName, data, clazz);
  }

  /**
   * 按照指定的属性名进行写出 一个 excel
   *
   * @param response
   * @param attrName  指定的属性名 必须与数据类型的属性名一致
   * @param fileName  文件名 最好为英文，不要后缀名
   * @param sheetName sheet名
   * @param data      要写出的数据
   * @param clazz     要写出数据类的Class类型对象
   * @param &lt;T&gt;       要写出的数据类型
   */
  public static &lt;T&gt; void export(HttpServletResponse response, Set&lt;String&gt; attrName, String fileName, String sheetName, List&lt;T&gt; data, Class&lt;T&gt; clazz) {

    fileName = StringUtils.isBlank(fileName) ? &quot;student-system-manager&quot; : fileName;
    sheetName = StringUtils.isBlank(sheetName) ? &quot;sheet0&quot; : sheetName;

    response.setContentType(&quot;application/vnd.ms-excel;charset=utf-8&quot;);
    response.setCharacterEncoding(&quot;utf-8&quot;);
    response.addHeader(&quot;Content-disposition&quot;, &quot;attachment;filename=&quot; + fileName + ExcelTypeEnum.XLSX.getValue());

    try(OutputStream os = response.getOutputStream()) {
      write(os,attrName,sheetName,data,clazz);
    } catch (IOException e) {
      e.printStackTrace();
    }
  }


  /**
   * 接收一个excel文件，并且进行解析
   *  注意一旦传入自定义监听器，则返回的list为空，数据需要在自定义监听器里面获取
   * @param multipartFile excel文件
   * @param clazz 数据类型的class对象
   * @param readListener 监听器
   * @param &lt;T&gt;
   * @return
   */
  public static &lt;T&gt; List&lt;T&gt; importExcel(MultipartFile multipartFile,Class&lt;T&gt; clazz,ReadListener&lt;T&gt; readListener) {
    try(InputStream inputStream = multipartFile.getInputStream()) {
      return read(inputStream,clazz,readListener);
    } catch (IOException e) {
      e.printStackTrace();
    }
    return null;
  }



  private static &lt;T&gt; void write(OutputStream os, Set&lt;String&gt; attrName, String sheetName, List&lt;T&gt; data, Class&lt;T&gt; clazz) {
    ExcelWriterBuilder write = EasyExcel.write(os, clazz);
    // 如果没有指定要写出那些属性数据，则写出全部
    if (!CollectionUtils.isEmpty(attrName)) {
      write.includeColumnFiledNames(attrName);
    }
    write.registerWriteHandler(new LongestMatchColumnWidthStyleStrategy()).sheet(sheetName).doWrite(data);
  }


  private static &lt;T&gt; List&lt;T&gt; read(InputStream in,Class&lt;T&gt; clazz, ReadListener&lt;T&gt; readListener) {
    List&lt;T&gt; list = new ArrayList&lt;&gt;();
    Optional&lt;ReadListener&gt; optional = Optional.ofNullable(readListener);
    EasyExcel.read(in, clazz, optional.orElse(new AnalysisEventListener&lt;T&gt;() {
      @Override
      public void invoke(T data, AnalysisContext context) {
        list.add(data);
      }
      @Override
      public void doAfterAllAnalysed(AnalysisContext context) {
        System.out.println(&quot;解析完成&quot;);
      }
    })).sheet().doRead();
    return list;
  }
}

</code></pre>
<h4 id="使用模板"><a class="header" href="#使用模板">使用模板</a></h4>
<h5 id="1-map类型传参"><a class="header" href="#1-map类型传参">1. map类型传参</a></h5>
<h5 id="2实体类型传参"><a class="header" href="#2实体类型传参">2.实体类型传参</a></h5>
<h5 id="例子1"><a class="header" href="#例子1">例子1</a></h5>
<p>模板样子</p>
<p><img src="xbell/img/20220119121801.JPG" alt="20220119121801" /></p>
<blockquote>
<p>注意，这里需要循环的数据需要用.表示：<code>{.name}</code> 表示是对象中的属性</p>
</blockquote>
<pre><code class="language-java">@Test
void test05(){
  //准备模板
  String template = &quot;a.xlsx&quot;;
  ExcelWriterBuilder builder = EasyExcel.write(&quot;hqqich.xlsx&quot;, Map.class).withTemplate(template);

  //准备map数据
  Map&lt;String, Object&gt; map=new HashMap&lt;&gt;();
  map.put(&quot;title&quot;, &quot;标题&quot;);
  map.put(&quot;name&quot;,&quot;姓名&quot;);
  map.put(&quot;age&quot;,22);

  //简单写
  builder.sheet().doFill(map);
}
</code></pre>
<p>写入后样子</p>
<p><img src="xbell/img/20220119122101.JPG" alt="20220119122101" /></p>
<p>可以看到样式被清楚了，弊端</p>
<h5 id="例子2"><a class="header" href="#例子2">例子2</a></h5>
<pre><code class="language-java">//FileData
@Data
@NoArgsConstructor
@AllArgsConstructor
public class FileData {

  private String age;

  private String name;

}

//测试方法
@Test
void test06(){
  ExcelWriterBuilder builder = EasyExcel.write(&quot;hqqich.xlsx&quot;, FileData.class).withTemplate(&quot;a.xlsx&quot;);
  List&lt;FileData&gt; fileDataList = new ArrayList&lt;FileData&gt;(){{
    add(new FileData(&quot;100&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;200&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;300&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
  }};
  builder.sheet().doFill(fileDataList);
}
</code></pre>
<p>写入后的样子</p>
<p><img src="xbell/img/20220119132501.JPG" alt="20220119132501" /></p>
<p>可以看到，循环的的单元格样式被保留下来了</p>
<h5 id="例子3"><a class="header" href="#例子3">例子3</a></h5>
<pre><code class="language-java">@Test
@SneakyThrows
void test08(){

  //创建.关联文件
  ExcelWriter build = EasyExcel.write(&quot;hqqich.xlsx&quot;).withTemplate(&quot;a.xlsx&quot;).build();

  //工作区对象
  WriteSheet sheet = EasyExcel.writerSheet().build();

  //渲染数据
  List&lt;FileData&gt; fileDataList = new ArrayList&lt;FileData&gt;(){{
    add(new FileData(&quot;100&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;200&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;300&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
    add(new FileData(&quot;400&quot;, &quot;hqqich&quot;));
  }};
  HashMap&lt;String, Object&gt; hashMap = new HashMap&lt;String, Object&gt;(){{
    put(&quot;title&quot;, &quot;标题&quot;);
    put(&quot;name&quot;, &quot;用户姓名&quot;);
    put(&quot;age&quot;, &quot;用户年龄&quot;);
  }};

  //添加数据
  build.fill(fileDataList, sheet);
  build.fill(hashMap, sheet);

  //保存
  build.finish();
}
</code></pre>
<p>写入后的样子</p>
<p><img src="xbell/img/1642570457952.png" alt="1642570457952" /></p>
<p>可以看到（标题栏，循环的数据）中的样式都被保留下来了</p>
<h5 id="例子3的另一种写法"><a class="header" href="#例子3的另一种写法">例子3的另一种写法</a></h5>
<pre><code class="language-java">@Test
@SneakyThrows
void test09(){

  //创建.关联文件
  ExcelWriter build = EasyExcel.write(&quot;hqqich.xlsx&quot;).withTemplate(&quot;a.xlsx&quot;).build();

  //工作区对象
  WriteSheet sheet = EasyExcel.writerSheet().build();

  //渲染数据
  List&lt;Map&lt;String, Object&gt;&gt; fileDataList = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(){{
    for (int i = 0; i &lt; 10; i++) {
      int finalI = i;
      add(new HashMap&lt;String, Object&gt;() {{
        put(&quot;name&quot;, &quot;hqqich&quot;+ finalI);
        put(&quot;age&quot;, 22+ finalI);
      }});
    }
  }};
  HashMap&lt;String, Object&gt; hashMap = new HashMap&lt;String, Object&gt;(){{
    put(&quot;title&quot;, &quot;标题&quot;);
    put(&quot;name&quot;, &quot;用户姓名&quot;);
    put(&quot;age&quot;, &quot;用户年龄&quot;);
  }};

  //添加数据
  build.fill(fileDataList, sheet);
  build.fill(hashMap, sheet);

  //保存
  build.finish();
}
</code></pre>
<h5 id="例子4"><a class="header" href="#例子4">例子4</a></h5>
<pre><code class="language-java">@Test
void test061(){
  ExcelWriterBuilder builder = EasyExcel.write(&quot;hqqich.xlsx&quot;, Map.class).withTemplate(&quot;a.xlsx&quot;);
  List&lt;Map&lt;String, Object&gt;&gt; fileDataList = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(){{
    for (int i = 0; i &lt; 10; i++) {
      int finalI = i;
      add(new HashMap&lt;String, Object&gt;() {{
        put(&quot;name&quot;, &quot;hqqich&quot;+ finalI);
        put(&quot;age&quot;, 22+ finalI);
      }});
    }
  }};
  builder.sheet().doFill(fileDataList);
}
</code></pre>
<p>写入后的样子</p>
<p><img src="xbell/img/1642571146989.png" alt="1642571146989" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guava文件操作"><a class="header" href="#guava文件操作">Guava文件操作</a></h1>
<pre><code class="language-java">
//1.通过guava 实现文件复制
private static String from = &quot;C:\\text\\1.txt&quot;;
private static String to = &quot;C:\\text\\2.txt&quot;;
Files.copy(new File(from),new File(to));


//2.移动
//to若存在,将被删除,重新生成
Files.move(new File(from),new File(to));


//3.按行读取文件
//读取文件第一行
String configJson = Files.readFirstLine(file, Charsets.UTF_8);
//将文件每一行读到list里
List&lt;String&gt; readLines = Files.readLines(file, Charsets.UTF_8);
//按照条件，将文件每行读到list里
Files.readLines(file, Charsets.UTF_8, new LineProcessor&lt;List&lt;String&gt;&gt;() {
	List&lt;String&gt; list = new ArrayList&lt;&gt;();
	@Override
	public List&lt;String&gt; getResult() {
		return list;
	}
	@Override
	public boolean processLine(String arg0) throws IOException {
		// TODO Auto-generated method stub
		return false;
	}
});


//4、计算文件hashcode (可对比两个文件是否一样)
//Hashing.md5();Hashing.sha256()
HashCode hash = Files.asByteSource(new File(to)).hash(Hashing.sha512());


//5.遍历目录
String path = &quot;D:\\自定义代码\\Guava\\guava\\src\\main&quot;;
File file = new File(path);
//获取path下子目录
Iterable&lt;File&gt; childrens = Files.fileTreeTraverser().children(file);
for (File children : childrens) {
  System.out.println(&quot;子目录: &quot; + children);
}
//获取path下所有目录  preOrderTraversal postOrderTraversal顺序不一样
FluentIterable&lt;File&gt; files = Files.fileTreeTraverser().preOrderTraversal(file);
for (File file1 : files) {
  System.out.println(&quot;全目录: &quot; + file1);
}
        /**
         子目录: D:\自定义代码\Guava\guava\src\main\java
         子目录: D:\自定义代码\Guava\guava\src\main\resources
         全目录: D:\自定义代码\Guava\guava\src\main
         全目录: D:\自定义代码\Guava\guava\src\main\java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\cache
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\cache\LRU
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\cache\LRU\LinkedHashLRUcache.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\cache\LRU\LRUcache.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\cache\LRU\Test.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\cache\reference
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\cache\reference\Phantom_Reference.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\cache\reference\Soft_Reference.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\cache\reference\StrongReference.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\cache\reference\Weak_Reference.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\ClassScaner.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\evenbus
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\evenbus\AbstractListener.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\evenbus\mybus
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\evenbus\mybus\Bus.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\evenbus\mybus\MyDispatcher.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\evenbus\mybus\MyEvenBus.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\evenbus\mybus\MyEvenContext.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\evenbus\mybus\MyEvenExceptionHandle.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\evenbus\mybus\MyRegistry.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\evenbus\mybus\MySubscribe.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\evenbus\mybus\MySubscriber.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\evenbus\SimpleEventBus.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\evenbus\SimpleListener.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\evenbus\test
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\evenbus\test\EventBusTest.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\evenbus\test\MyListener.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\files
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\files\FilesTest.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\GuavaApplication.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\monitorFile
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\monitorFile\DirectoryTargetMonitor.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\monitorFile\MainTest.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\monitorFile\TargetMonitor.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\ratelimit
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\ratelimit\RateLimitTest.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\utils
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\utils\CharMatchsTest.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\utils\JoinerTest.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\utils\PreconditionsTest.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\utils\SplitterTest.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\utils\StopWatchTest.java
         全目录: D:\自定义代码\Guava\guava\src\main\java\com\cai\ya\utils\StringsTest.java
         全目录: D:\自定义代码\Guava\guava\src\main\resources
         全目录: D:\自定义代码\Guava\guava\src\main\resources\application.properties
         全目录: D:\自定义代码\Guava\guava\src\main\resources\io
         全目录: D:\自定义代码\Guava\guava\src\main\resources\io\2.txt
         全目录: D:\自定义代码\Guava\guava\src\main\resources\io\rest.txt
         全目录: D:\自定义代码\Guava\guava\src\main\resources\log4j2.xml
        */



//6.自定义过滤目录

public static void main(String[] args) {
    String path = &quot;D:\\自定义代码\\Guava\\guava\\src\\main&quot;;
    File file = new File(path);
    //preOrderTraversal postOrderTraversal顺序不一样
    FluentIterable&lt;File&gt; files =
        Files.fileTreeTraverser().preOrderTraversal(file).filter(new Predicate&lt;File&gt;() {
          @Override
          public boolean apply(@Nullable File input) {
            return input.isFile();  //只要文件
          }
        });
    for (File file1 : files) {
      System.out.println(file1);
    }
  }


//7.写、追加文件：
#写文件（覆盖原内容）
File configPath = new File(&quot;D:/test&quot;);
Files.write(&quot;sdfsdfdsfds33334444&quot;, configPath, Charsets.UTF_8);
//追加内容
File configPath1 = new File(&quot;D:/test1&quot;);
Files.append(&quot;sdfsdfdsfds33334444&quot;, configPath1, Charsets.UTF_8);


//8.常用功能
//获取扩展名
String ext = Files.getFileExtension(&quot;D:/binom.py&quot;);
//获得不带扩展名的文件名
String fn = Files.getNameWithoutExtension(&quot;D:/binom.py&quot;);
//创建或者更新文件的时间戳
File configPath = new File(&quot;D:/aaa&quot;);
Files.touch(configPath);
//获取文件的内存映射
MappedByteBuffer map = Files.map(configPath);
// 注：该方法实际调用的是jdk中的MappedByteBuffer，会受到文件大小不能超过2G的限制！



//9。guava流，文件快速读写
Files.asByteSource(new File(&quot;d:/1.txt&quot;)).copyTo(Files.asByteSink(new File(&quot;d:/2.txt&quot;), FileWriteMode.APPEND));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>一.Spring data jpa 简介
首先我并不推荐使用jpa作为ORM框架,毕竟对于负责查询的时候还是不太灵活,还是建议使用mybatis,自己写sql比较好.但是如果公司用这个就没办法了,可以学习一下,对于简单查询还是非常好用的.</p>
<pre><code>首先JPA是Java持久层API,由Sun公司开发, 希望整合ORM技术，实现天下归一.  诞生的缘由是为了整合第三方ORM框架，建立一种标准的方式，目前也是在按照这个方向发展，但是还没能完全实现。在ORM框架中，Hibernate是一支很大的部队，使用很广泛，也很方便，能力也很强，同时Hibernate也是和JPA整合的比较良好，我们可以认为JPA是标准，事实上也是，JPA几乎都是接口，实现都是Hibernate在做，宏观上面看，在JPA的统一之下Hibernate很良好的运行。

Spring-data-jpa，Spring与jpa的整合

Spring主要是在做第三方工具的整合 不重新造轮子. 而在与第三方整合这方面，Spring做了持久化这一块的工作，于是就有了Spring-data-**这一系列包。包括，Spring-data-jpa,Spring-data-template,Spring-data-mongodb,Spring-data-redis

Spring-data-jpa，目的少使用sql

我们都知道，在使用持久化工具的时候，一般都有一个对象来操作数据库，在原生的Hibernate中叫做Session，在JPA中叫做EntityManager，在MyBatis中叫做SqlSession，通过这个对象来操作数据库。我们一般按照三层结构来看的话，Service层做业务逻辑处理，Dao层和数据库打交道，在Dao中，就存在着上面的对象。那么ORM框架本身提供的功能有什么呢？答案是基本的CRUD(增删改查)，所有的基础CRUD框架都提供，我们使用起来感觉很方便，很给力，业务逻辑层面的处理ORM是没有提供的，如果使用原生的框架，业务逻辑代码我们一般会自定义，会自己去写SQL语句，然后执行。在这个时候，Spring-data-jpa的威力就体现出来了，ORM提供的能力他都提供，ORM框架没有提供的业务逻辑功能Spring-data-jpa也提供，全方位的解决用户的需求。使用Spring-data-jpa进行开发的过程中，常用的功能，我们几乎不需要写一条sql语句，至少在我看来，企业级应用基本上可以不用写任何一条sql，当然spring-data-jpa也提供自己写sql的方式

 返回值为对象的意义

是jpa查询表内容返回值基本上都是对象,但是仅仅需要一个字段返回整体对象不是会有很多数据冗余吗,其实大多数情况对一个数据表的查询不可能只有一次或者说这个表不仅仅是这一次会用到,如果我写好一个返回对象的方法,之后都可以直接调用,一般情况下多出一点数据对网络的压力可以忽略不计,而这样对开发效率的提升还是很大的.如果仅仅想得到一部分字段也可以新建一个只有想要字段的Entity.
</code></pre>
<p>二.Spring data jpa 基本使用
对于配置方法和基础的dao层写法等不做介绍,基础篇仅当做一个方法字典.</p>
<pre><code>1.核心方法
</code></pre>
<p>查询所有数据 findAll()
修改 添加数据  S save(S entity)
分页查询 Page<S> findAll(Example<S> example, Pageable pageable)
根据id查询 findOne()
根据实体类属性查询： findByProperty (type Property); 例如：findByAge(int age)
删除 void delete(T entity)
计数 查询 long count() 或者 根据某个属性的值查询总数 countByAge(int age)
是否存在   boolean existsById(ID primaryKey)</p>
<pre><code>2.查询关键字
</code></pre>
<p>-and</p>
<p>And 例如：findByUsernameAndPassword(String user, Striang pwd)；</p>
<p>-or
Or 例如：findByUsernameOrAddress(String user, String addr)；</p>
<p>-between
Between 例如：SalaryBetween(int max, int min)；</p>
<p>-&quot;&lt;&quot;
LessThan 例如： findBySalaryLessThan(int max)；</p>
<p>-&quot;&gt;&quot;
GreaterThan 例如： findBySalaryGreaterThan(int min)；</p>
<p>-is null
IsNull 例如： findByUsernameIsNull()；</p>
<p>-is not null
IsNotNull NotNull 与 IsNotNull 等价 例如： findByUsernameIsNotNull()；</p>
<p>-like
Like 例如： findByUsernameLike(String user)；</p>
<p>-not like
NotLike 例如： findByUsernameNotLike(String user)；</p>
<p>-order by
OrderBy 例如： findByUsernameOrderByNameAsc(String user)；直接通过name正序排序</p>
<p>-&quot;!=&quot;
Not 例如： findByUsernameNot(String user)；</p>
<p>-in
In 例如： findByUsernameIn(Collection<String> userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数；</p>
<p>-not in
NotIn 例如： findByUsernameNotIn(Collection<String> userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数；</p>
<p>-Top/Limit
查询方法结果的数量可以通过关键字来限制，first 或者 top都可以使用。top/first加数字可以指定要返回最大结果的大小 默认为1</p>
<pre><code> 例如:
</code></pre>
<p>User findFirstByOrderByLastnameAsc();
User findTopByOrderByAgeDesc();
Page<User> queryFirst10ByLastname(String lastname, Pageable pageable);
Slice<User> findTop3ByLastname(String lastname, Pageable pageable);
List<User> findFirst10ByLastname(String lastname, Sort sort);
List<User> findTop10ByLastname(String lastname, Pageable pageable);
详细查询语法
关键词	示例	对应的sql片段
And</p>
<p>findByLastnameAndFirstname</p>
<p>… where x.lastname = ?1 and x.firstname = ?2</p>
<p>Or</p>
<p>findByLastnameOrFirstname</p>
<p>… where x.lastname = ?1 or x.firstname = ?2</p>
<p>Is,Equals</p>
<p>findByFirstname,findByFirstnameIs,findByFirstnameEquals</p>
<p>… where x.firstname = ?1</p>
<p>Between</p>
<p>findByStartDateBetween</p>
<p>… where x.startDate between ?1 and ?2</p>
<p>LessThan</p>
<p>findByAgeLessThan</p>
<p>… where x.age &lt; ?1</p>
<p>LessThanEqual</p>
<p>findByAgeLessThanEqual</p>
<p>… where x.age &lt;= ?1</p>
<p>GreaterThan</p>
<p>findByAgeGreaterThan</p>
<p>… where x.age &gt; ?1</p>
<p>GreaterThanEqual</p>
<p>findByAgeGreaterThanEqual</p>
<p>… where x.age &gt;= ?1</p>
<p>After</p>
<p>findByStartDateAfter</p>
<p>… where x.startDate &gt; ?1</p>
<p>Before</p>
<p>findByStartDateBefore</p>
<p>… where x.startDate &lt; ?1</p>
<p>IsNull</p>
<p>findByAgeIsNull</p>
<p>… where x.age is null</p>
<p>IsNotNull,NotNull</p>
<p>findByAge(Is)NotNull</p>
<p>… where x.age not null</p>
<p>Like</p>
<p>findByFirstnameLike</p>
<p>… where x.firstname like ?1</p>
<p>NotLike</p>
<p>findByFirstnameNotLike</p>
<p>… where x.firstname not like ?1</p>
<p>StartingWith</p>
<p>findByFirstnameStartingWith</p>
<p>… where x.firstname like ?1 (parameter bound with appended %)</p>
<p>EndingWith</p>
<p>findByFirstnameEndingWith</p>
<p>… where x.firstname like ?1 (parameter bound with prepended %)</p>
<p>Containing</p>
<p>findByFirstnameContaining</p>
<p>… where x.firstname like ?1 (parameter bound wrapped in %)</p>
<p>OrderBy</p>
<p>findByAgeOrderByLastnameDesc</p>
<p>… where x.age = ?1 order by x.lastname desc</p>
<p>Not</p>
<p>findByLastnameNot</p>
<p>… where x.lastname &lt;&gt; ?1</p>
<p>In</p>
<p>findByAgeIn(Collection<Age> ages)</p>
<p>… where x.age in ?1</p>
<p>NotIn</p>
<p>findByAgeNotIn(Collection<Age> ages)</p>
<p>… where x.age not in ?1</p>
<p>True</p>
<p>findByActiveTrue()</p>
<p>… where x.active = true</p>
<p>False</p>
<p>findByActiveFalse()</p>
<p>… where x.active = false</p>
<p>IgnoreCase</p>
<p>findByFirstnameIgnoreCase</p>
<p>… where UPPER(x.firstame) = UPPER(?1)</p>
<pre><code>3.内置方法
</code></pre>
<p>Sort_排序
Sort sort =new Sort(Sort.Direction.ASC,&quot;id&quot;);
//其中第一个参数表示是降序还是升序（此处表示升序）
//第二个参数表示你要按你的 entity（记住是entity中声明的变量，不是数据库中表对应的字段）中的那个变量进行排序
PageRequest_分页
PageRequest pageRequest = new PageRequest(index, num, sort);
//index偏移量 num查询数量 sort排序
分页+排序实现:</p>
<p>DemoBean demoBean = new DemoBean();
demoBean.setAppId(appId); //查询条件
//创建查询参数
Example<DemoBean> example = Example.of(demoBean);
//获取排序对象
Sort sort = new Sort(Sort.Direction.DESC, &quot;id&quot;);
//创建分页对象
PageRequest pageRequest = new PageRequest(index, num, sort);
//分页查询
return demoRepository.findAll(example, pageRequest).getContent();
Example_实例查询
创建一个ExampleMatcher对象，最后再用Example的of方法构造相应的Example对象并传递给相关查询方法。我们看看Spring的例子。</p>
<p>Person person = new Person();<br />
person.setFirstname(&quot;Dave&quot;);  //Firstname = 'Dave'</p>
<p>ExampleMatcher matcher = ExampleMatcher.matching()<br />
.withMatcher(&quot;name&quot;, GenericPropertyMatchers.startsWith()) //姓名采用“开始匹配”的方式查询
.withIgnorePaths(&quot;int&quot;);  //忽略属性：是否关注。因为是基本类型，需要忽略掉</p>
<p>Example<Person> example = Example.of(person, matcher);  //Example根据域对象和配置创建一个新的ExampleMatcher<br />
ExampleMatcher用于创建一个查询对象，上面的代码就创建了一个查询对象。withIgnorePaths方法用来排除某个属性的查询。withIncludeNullValues方法让空值也参与查询，就是我们设置了对象的姓，而名为空值.</p>
<p>1、概念定义:</p>
<pre><code>上面例子中，是这样创建“实例”的：Example&lt;Customer&gt; ex = Example.of(customer, matcher);我们看到，Example对象，由customer和matcher共同创建。

A、实体对象：在持久化框架中与Table对应的域对象，一个对象代表数据库表中的一条记录，如上例中Customer对象。在构建查询条件时，一个实体对象代表的是查询条件中的“数值”部分。如：要查询名字是“Dave”的客户，实体对象只能存储条件值“Dave”。

B、匹配器：ExampleMatcher对象，它是匹配“实体对象”的，表示了如何使用“实体对象”中的“值”进行查询，它代表的是“查询方式”，解释了如何去查的问题。如：要查询FirstName是“Dave”的客户,即名以“Dave&quot;开头的客户，该对象就表示了“以什么开头的”这个查询方式，如上例中:withMatcher(&quot;name&quot;, GenericPropertyMatchers.startsWith())

C、实例：即Example对象，代表的是完整的查询条件。由实体对象（查询条件值）和匹配器（查询方式）共同创建。

再来理解“实例查询”，顾名思义，就是通过一个例子来查询。要查询的是Customer对象，查询条件也是一个Customer对象，通过一个现有的客户对象作为例子，查询和这个例子相匹配的对象。
</code></pre>
<p>2、特点及约束（局限性）:</p>
<pre><code>A、支持动态查询。即支持查询条件个数不固定的情况，如：客户列表中有多个过滤条件，用户使用时在“地址”查询框中输入了值，就需要按地址进行过滤，如果没有输入值，就忽略这个过滤条件。对应的实现是，在构建查询条件Customer对象时，将address属性值置具体的条件值或置为null。

B、不支持过滤条件分组。即不支持过滤条件用 or(或) 来连接，所有的过滤查件，都是简单一层的用 and(并且) 连接。

C、仅支持字符串的开始/包含/结束/正则表达式匹配 和 其他属性类型的精确匹配。查询时，对一个要进行匹配的属性（如：姓名 name），只能传入一个过滤条件值，如以Customer为例，要查询姓“刘”的客户，“刘”这个条件值就存储在表示条件对象的Customer对象的name属性中，针对于“姓名”的过滤也只有这么一个存储过滤值的位置，没办法同时传入两个过滤值。正是由于这个限制，有些查询是没办法支持的，例如要查询某个时间段内添加的客户，对应的属性是 addTime，需要传入“开始时间”和“结束时间”两个条件值，而这种查询方式没有存两个值的位置，所以就没办法完成这样的查询。
</code></pre>
<p>3、ExampleMatcher的使用 :</p>
<p>一些问题:
（1）Null值的处理。当某个条件值为Null,是应当忽略这个过滤条件呢，还是应当去匹配数据库表中该字段值是Null的记录？
（2）基本类型的处理。如客户Customer对象中的年龄age是int型的，当页面不传入条件值时，它默认是0，是有值的，那是否参与查询呢？
（3）忽略某些属性值。一个实体对象，有许多个属性，是否每个属性都参与过滤？是否可以忽略某些属性？
（4）不同的过滤方式。同样是作为String值，可能“姓名”希望精确匹配，“地址”希望模糊匹配，如何做到？</p>
<p>（5）大小写匹配。字符串匹配时，有时可能希望忽略大小写，有时则不忽略，如何做到？</p>
<p>一些方法:
1、关于基本数据类型。
实体对象中，避免使用基本数据类型，采用包装器类型。如果已经采用了基本类型，</p>
<p>而这个属性查询时不需要进行过滤，则把它添加到忽略列表（ignoredPaths）中。</p>
<p>2、Null值处理方式。</p>
<p>默认值是 IGNORE（忽略），即当条件值为null时，则忽略此过滤条件，一般业务也是采用这种方式就可满足。当需要查询数据库表中属性为null的记录时，可将值设为INCLUDE，这时，对于不需要参与查询的属性，都必须添加到忽略列表（ignoredPaths）中，否则会出现查不到数据的情况。</p>
<p>3、默认配置、特殊配置。</p>
<p>默认创建匹配器时，字符串采用的是精确匹配、不忽略大小写，可以通过操作方法改变这种默认匹配，以满足大多数查询条件的需要，如将“字符串匹配方式”改为CONTAINING（包含，模糊匹配），这是比较常用的情况。对于个别属性需要特定的查询方式，可以通过配置“属性特定查询方式”来满足要求。</p>
<p>4、非字符串属性</p>
<p>如约束中所谈，非字符串属性均采用精确匹配，即等于。</p>
<p>5、忽略大小写的问题。</p>
<p>忽略大小的生效与否，是依赖于数据库的。例如 MySql 数据库中，默认创建表结构时，字段是已经忽略大小写的，所以这个配置与否，都是忽略的。如果业务需要严格区分大小写，可以改变数据库表结构属性来实现，具体可百度。</p>
<p>一些例子:
综合使用:</p>
<p>//创建查询条件数据对象
Customer customer = new Customer();
customer.setName(&quot;zhang&quot;);
customer.setAddress(&quot;河南省&quot;);
customer.setRemark(&quot;BB&quot;);</p>
<pre><code>    //创建匹配器，即如何使用查询条件
    ExampleMatcher matcher = ExampleMatcher.matching() //构建对象
            .withStringMatcher(StringMatcher.CONTAINING) //改变默认字符串匹配方式：模糊查询
            .withIgnoreCase(true) //改变默认大小写忽略方式：忽略大小写
            .withMatcher(&quot;address&quot;, GenericPropertyMatchers.startsWith()) //地址采用“开始匹配”的方式查询
            .withIgnorePaths(&quot;focus&quot;);  //忽略属性：是否关注。因为是基本类型，需要忽略掉
    
    //创建实例
    Example&lt;Customer&gt; ex = Example.of(customer, matcher); 
    
    //查询
    List&lt;Customer&gt; ls = dao.findAll(ex);
</code></pre>
<p>查询null值:</p>
<p>　　　　 //创建查询条件数据对象
Customer customer = new Customer();</p>
<pre><code>    //创建匹配器，即如何使用查询条件
    ExampleMatcher matcher = ExampleMatcher.matching() //构建对象
            .withIncludeNullValues() //改变“Null值处理方式”：包括
            .withIgnorePaths(&quot;id&quot;,&quot;name&quot;,&quot;sex&quot;,&quot;age&quot;,&quot;focus&quot;,&quot;addTime&quot;,&quot;remark&quot;,&quot;customerType&quot;);  //忽略其他属性
    
    //创建实例
    Example&lt;Customer&gt; ex = Example.of(customer, matcher); 
    
    //查询
    List&lt;Customer&gt; ls = dao.findAll(ex);
</code></pre>
<p>三.Spring data jpa 注解
1.Repository注解</p>
<p>@Modifying //做update操作时需要添加</p>
<p>@Query // 自定义Sql</p>
<p>@Query(value = &quot;SELECT * FROM USERS WHERE X = ?1&quot;, nativeQuery = true)
User findByEmailAddress(String X);
@Query(&quot;select u from User u where u.firstname = :firstname&quot;) //不加nativeQuery应使用HQL
User findByLastnameOrFirstname(@Param(&quot;lastname&quot;) String lastname);
@Transactional //事务</p>
<p>@Async //异步操作</p>
<p>2.Entity注解</p>
<p>@Entity //不写@Table默认为user
@Table(name=&quot;t_user&quot;) //自定义表名
public class user {</p>
<pre><code>@Id //主键
@GeneratedValue(strategy = GenerationType.AUTO)//采用数据库自增方式生成主键
//JPA提供的四种标准用法为TABLE,SEQUENCE,IDENTITY,AUTO.
//TABLE：使用一个特定的数据库表格来保存主键。
//SEQUENCE：根据底层数据库的序列来生成主键，条件是数据库支持序列。
//IDENTITY：主键由数据库自动生成（主要是自动增长型）
//AUTO：主键由程序控制。
 
@Transient //此字段不与数据库关联
@Version//此字段加上乐观锁
//字段为name，不允许为空，用户名唯一
@Column(name = &quot;name&quot;, unique = true, nullable = false)
private String name;
 
@Temporal(TemporalType.DATE)//生成yyyy-MM-dd类型的日期
//出参时间格式化
@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)
//入参时，请求报文只需要传入yyyymmddhhmmss字符串进来，则自动转换为Date类型数据
@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm&quot;)
private Date createTime;
 
public String getName() {
    return name;
}
public void setName(String name) {
    this.name = name;
}
</code></pre>
<p>}</p>
<p>四.继承JpaSpecificationExecutor接口进行复杂查询
spring data jpa 通过创建方法名来做查询，只能做简单的查询，那如果我们要做复杂一些的查询呢，多条件分页怎么办，这里，spring data jpa为我们提供了JpaSpecificationExecutor接口，只要简单实现toPredicate方法就可以实现复杂的查询</p>
<p>参考:https://www.cnblogs.com/happyday56/p/4661839.html</p>
<p>1.首先让我们的接口继承于JpaSpecificationExecutor</p>
<p>public interface TaskDao extends JpaSpecificationExecutor<Task>{
}
2.JpaSpecificationExecutor提供了以下接口</p>
<p>public interface JpaSpecificationExecutor<T> {</p>
<pre><code>T findOne(Specification&lt;T&gt; spec);
 
List&lt;T&gt; findAll(Specification&lt;T&gt; spec);
 
Page&lt;T&gt; findAll(Specification&lt;T&gt; spec, Pageable pageable);
 
List&lt;T&gt; findAll(Specification&lt;T&gt; spec, Sort sort);
 
long count(Specification&lt;T&gt; spec);
</code></pre>
<p>}</p>
<p>//其中Specification就是需要我们传入查询方法的参数，它是一个接口</p>
<p>public interface Specification<T> {</p>
<pre><code>Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb);
</code></pre>
<p>}
提供唯一的一个方法toPredicate，我们只要按照JPA 2.0 criteria api写好查询条件就可以了，关于JPA 2.0 criteria api的介绍和使用，欢迎参考 
http://blog.csdn.net/dracotianlong/article/details/28445725 </p>
<p>http://developer.51cto.com/art/200911/162722.htm</p>
<p>3.接下来我们在service bean</p>
<p>@Service
public class TaskService {</p>
<pre><code>@Autowired TaskDao taskDao ;




/**
 * 复杂查询测试
 * @param page
 * @param size
 * @return
 */
public Page&lt;Task&gt; findBySepc(int page, int size){
 
    PageRequest pageReq = this.buildPageRequest(page, size);
    Page&lt;Task&gt; tasks = this.taskDao.findAll(new MySpec(), pageReq);
    //传入了new MySpec() 既下面定义的匿名内部类 其中定义了查询条件
    return tasks;
 
}
 
 /**
  * 建立分页排序请求 
  * @param page
  * @param size
  * @return
  */
 private PageRequest buildPageRequest(int page, int size) {
       Sort sort = new Sort(Direction.DESC,&quot;createTime&quot;);
       return new PageRequest(page,size, sort);
 }
 
/**
 * 建立查询条件
 */
private class MySpec implements Specification&lt;Task&gt;{
 
    @Override
    public Predicate toPredicate(Root&lt;Task&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) {
 
 //1.混合条件查询
      Path&lt;String&gt; exp1 = root.get(&quot;taskName&quot;);
        Path&lt;Date&gt;  exp2 = root.get(&quot;createTime&quot;);
        Path&lt;String&gt; exp3 = root.get(&quot;taskDetail&quot;);
        Predicate predicate = cb.and(cb.like(exp1, &quot;%taskName%&quot;),cb.lessThan(exp2, new Date()));
        return cb.or(predicate,cb.equal(exp3, &quot;kkk&quot;));
 
       /* 类似的sql语句为:
        Hibernate: 
            select
                count(task0_.id) as col_0_0_ 
            from
                tb_task task0_ 
            where
                (
                    task0_.task_name like ?
                ) 
                and task0_.create_time&lt;? 
                or task0_.task_detail=?
        */
 
//2.多表查询
    Join&lt;Task,Project&gt; join = root.join(&quot;project&quot;, JoinType.INNER);
        Path&lt;String&gt; exp4 = join.get(&quot;projectName&quot;);
        return cb.like(exp4, &quot;%projectName%&quot;);
 
       /* Hibernate: 
        select
            count(task0_.id) as col_0_0_ 
        from
            tb_task task0_ 
        inner join
            tb_project project1_ 
                on task0_.project_id=project1_.id 
        where
            project1_.project_name like ?*/ 
       return null ;  
    }
}
</code></pre>
<p>}
4.实体类task代码如下</p>
<p>@Entity
@Table(name = &quot;tb_task&quot;)
public class Task {</p>
<pre><code>private Long id ;
private String taskName ;
private Date createTime ;
private Project project;
private String taskDetail ;
 
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
public Long getId() {
    return id;
}
public void setId(Long id) {
    this.id = id;
}
 
@Column(name = &quot;task_name&quot;)
public String getTaskName() {
    return taskName;
}
public void setTaskName(String taskName) {
    this.taskName = taskName;
}
 
@Column(name = &quot;create_time&quot;)
@DateTimeFormat(pattern = &quot;yyyy-MM-dd hh:mm:ss&quot;)
public Date getCreateTime() {
    return createTime;
}
public void setCreateTime(Date createTime) {
    this.createTime = createTime;
}




@Column(name = &quot;task_detail&quot;)
public String getTaskDetail() {
    return taskDetail;
}
public void setTaskDetail(String taskDetail) {
    this.taskDetail = taskDetail;
}
 
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = &quot;project_id&quot;)
public Project getProject() {
    return project;
}
public void setProject(Project project) {
    this.project = project;
}
</code></pre>
<p>}
通过重写toPredicate方法，返回一个查询 Predicate，spring data jpa会帮我们进行查询。</p>
<p>也许你觉得，每次都要写一个类来实现Specification很麻烦，那或许你可以这么写</p>
<p>public class TaskSpec {</p>
<pre><code>public static Specification&lt;Task&gt; method1(){
 
    return new Specification&lt;Task&gt;(){
        @Override
        public Predicate toPredicate(Root&lt;Task&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) {
            return null;
        }
 
    };
}
 
public static Specification&lt;Task&gt; method2(){
 
    return new Specification&lt;Task&gt;(){
        @Override
        public Predicate toPredicate(Root&lt;Task&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) {
            return null;
        }
 
    };
}
</code></pre>
<p>}
那么用的时候，我们就这么用</p>
<p>Page<Task> tasks = this.taskDao.findAll(TaskSpec.method1(), pageReq);</p>
<p>五.Spring data jpa + QueryDSL 进行复杂查询
QueryDSL仅仅是一个通用的查询框架，专注于通过Java API构建类型安全的SQL查询。
Querydsl可以通过一组通用的查询API为用户构建出适合不同类型ORM框架或者是SQL的查询语句，也就是说QueryDSL是基于各种ORM框架以及SQL之上的一个通用的查询框架。
借助QueryDSL可以在任何支持的ORM框架或者SQL平台上以一种通用的API方式来构建查询。目前QueryDSL支持的平台包括JPA,JDO,SQL,Java Collections,RDF,Lucene,Hibernate Search。
P.s.配置可以根据官网介绍来配置</p>
<p>1 实体类</p>
<p>城市类:</p>
<p>@Entity
@Table(name = &quot;t_city&quot;, schema = &quot;test&quot;, catalog = &quot;&quot;)
public class TCity {
//省略JPA注解标识
private int id;
private String name;
private String state;
private String country;
private String map;
}</p>
<p>旅馆类:</p>
<p>@Entity
@Table(name = &quot;t_hotel&quot;, schema = &quot;test&quot;, catalog = &quot;&quot;)
public class THotel {
//省略JPA注解标识
private int id;
private String name;
private String address;
private Integer city;//保存着城市的id主键
}
2 单表动态分页查询</p>
<p>Spring Data JPA中提供了QueryDslPredicateExecutor接口,用于支持QueryDSL的查询操作</p>
<p>public interface tCityRepository extends JpaRepository&lt;TCity, Integer&gt;, QueryDslPredicateExecutor<TCity> {
}
这样的话单表动态查询就可以参考如下代码:</p>
<p>//查找出Id小于3,并且名称带有<code>shanghai</code>的记录.</p>
<p>//动态条件
QTCity qtCity = QTCity.tCity; //SDL实体类
//该Predicate为querydsl下的类,支持嵌套组装复杂查询条件
Predicate predicate = qtCity.id.longValue().lt(3).and(qtCity.name.like(&quot;shanghai&quot;));
//分页排序
Sort sort = new Sort(new Sort.Order(Sort.Direction.ASC,&quot;id&quot;));
PageRequest pageRequest = new PageRequest(0,10,sort);
//查找结果
Page<TCity> tCityPage = tCityRepository.findAll(predicate,pageRequest);
3 多表动态查询</p>
<p>QueryDSL对多表查询提供了一个很好地封装,看下面代码:</p>
<p>/**
* 关联查询示例,查询出城市和对应的旅店
* @param predicate 查询条件
* @return 查询实体
*/
@Override
public List<Tuple> findCityAndHotel(Predicate predicate) {
JPAQueryFactory queryFactory = new JPAQueryFactory(em);
JPAQuery<Tuple> jpaQuery = queryFactory.select(QTCity.tCity,QTHotel.tHotel)
.from(QTCity.tCity)
.leftJoin(QTHotel.tHotel)
.on(QTHotel.tHotel.city.longValue().eq(QTCity.tCity.id.longValue()));
//添加查询条件
jpaQuery.where(predicate);
//拿到结果
return jpaQuery.fetch();
}
城市表左连接旅店表,当该旅店属于这个城市时查询出两者的详细字段,存放到一个Tuple的多元组中.相比原生sql,简单清晰了很多.
那么该怎么调用这个方法呢?</p>
<p>@Test
public void findByLeftJoin(){
QTCity qtCity = QTCity.tCity;
QTHotel qtHotel = QTHotel.tHotel;
//查询条件
Predicate predicate = qtCity.name.like(&quot;shanghai&quot;);
//调用
List<Tuple> result = tCityRepository.findCityAndHotel(predicate);
//对多元组取出数据,这个和select时的数据相匹配
for (Tuple row : result) {
System.out.println(&quot;qtCity:&quot;+row.get(qtCity));
System.out.println(&quot;qtHotel:&quot;+row.get(qtHotel));
System.out.println(&quot;--------------------&quot;);
}
System.out.println(result);
}</p>
<p>这样做的话避免了返回Object[]数组,下面是自动生成的sql语句:</p>
<p>select
tcity0_.id as id1_0_0_,
thotel1_.id as id1_1_1_,
tcity0_.country as country2_0_0_,
tcity0_.map as map3_0_0_,
tcity0_.name as name4_0_0_,
tcity0_.state as state5_0_0_,
thotel1_.address as address2_1_1_,
thotel1_.city as city3_1_1_,
thotel1_.name as name4_1_1_ 
from
t_city tcity0_ 
left outer join
t_hotel thotel1_ 
on (
cast(thotel1_.city as signed)=cast(tcity0_.id as signed)
) 
where
tcity0_.name like ? escape '!'
4 多表动态分页查询</p>
<p>分页查询对于queryDSL无论什么样的sql只需要写一遍,会自动转换为相应的count查询,也就避免了文章开始的问题4,下面代码是对上面的查询加上分页功能:</p>
<p>@Override
public QueryResults<Tuple> findCityAndHotelPage(Predicate predicate,Pageable pageable) {
JPAQueryFactory queryFactory = new JPAQueryFactory(em);
JPAQuery<Tuple> jpaQuery = queryFactory.select(QTCity.tCity.id,QTHotel.tHotel)
.from(QTCity.tCity)
.leftJoin(QTHotel.tHotel)
.on(QTHotel.tHotel.city.longValue().eq(QTCity.tCity.id.longValue()))
.where(predicate)
.offset(pageable.getOffset())
.limit(pageable.getPageSize());
//拿到分页结果
return jpaQuery.fetchResults();
}
和上面不同之处在于这里使用了offset和limit限制查询结果.并且返回一个QueryResults,该类会自动实现count查询和结果查询,并进行封装.
调用形式如下:</p>
<pre><code>@Test
public void findByLeftJoinPage(){
    QTCity qtCity = QTCity.tCity;
    QTHotel qtHotel = QTHotel.tHotel;
    //条件
    Predicate predicate = qtCity.name.like(&quot;shanghai&quot;);
    //分页
    PageRequest pageRequest = new PageRequest(0,10);
    //调用查询
    QueryResults&lt;Tuple&gt; result = tCityRepository.findCityAndHotelPage(predicate,pageRequest);
    //结果取出
    for (Tuple row : result.getResults()) {
        System.out.println(&quot;qtCity:&quot;+row.get(qtCity));
        System.out.println(&quot;qtHotel:&quot;+row.get(qtHotel));
        System.out.println(&quot;--------------------&quot;);
    }
    //取出count查询总数
    System.out.println(result.getTotal());
}
</code></pre>
<p>生成的原生count查询sql,当该count查询结果为0的话,则直接返回,并不会再进行具体数据查询:</p>
<p>select
count(tcity0_.id) as col_0_0_ 
from
t_city tcity0_ 
left outer join
t_hotel thotel1_ 
on (
cast(thotel1_.city as signed)=cast(tcity0_.id as signed)
) 
where
tcity0_.name like ? escape '!'
生成的原生查询sql:</p>
<p>select
tcity0_.id as id1_0_0_,
thotel1_.id as id1_1_1_,
tcity0_.country as country2_0_0_,
tcity0_.map as map3_0_0_,
tcity0_.name as name4_0_0_,
tcity0_.state as state5_0_0_,
thotel1_.address as address2_1_1_,
thotel1_.city as city3_1_1_,
thotel1_.name as name4_1_1_ 
from
t_city tcity0_ 
left outer join
t_hotel thotel1_ 
on (
cast(thotel1_.city as signed)=cast(tcity0_.id as signed)
) 
where
tcity0_.name like ? escape '!' limit ?
查看打印,可以发现对应的city也都是同一个对象,hotel是不同的对象.</p>
<p>5 改造
有了上面的经验,改造就变得相当容易了.
首先前面的一堆sql可以写成如下形式,无非是多了一些select和left join</p>
<p>JPAQueryFactory factory = new JPAQueryFactory(entityManager);
factory.select($.pcardCardOrder)
.select($.pcardVcardMake.vcardMakeDes)
.select($.pcardVtype.cardnumRuleId,$.pcardVtype.vtypeNm)
.select($.pcardCardbin)
.leftJoin($.pcardVcardMake).on($.pcardCardOrder.makeId.eq($.pcardVcardMake.vcardMakeId))
//......省略
查询条件使用Predicate代替,放在service拼接,或者写一个生产条件的工厂都可以.</p>
<p>jpaQuery.where(predicate);
最后的分页处理就和之前的一样了</p>
<pre><code>    jpaQuery.offset(pageable.getOffset())
            .limit(pageable.getPageSize());
    return jpaQuery.fetchResults();
</code></pre>
<p>写在最后:</p>
<pre><code>个人认为jpa的意义就在于少用原生sql 为了方便开发 封装已经是在所难免了. 推荐多使用简单查询,需要使用动态查询的时候推荐使用JpaSpecificationExecutor个人认为比较好用.

虽然我还是喜欢原生的写法...
</code></pre>
<p>另外很多时候简单的条件可以在server层进行判断调用不同的Dao层方法就可以。</p>
<p>P.s.参考资料 </p>
<p>使用QueryDSL
Spring Data JPA 实例查询
Spring Data JPA - Reference Documentation
Querydsl Reference Guide</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="一导读"><a class="header" href="#一导读">一、导读</a></h2>
<p>如果一次性加载成千上万的列表数据，在网页上显示将十分的耗时，用户体验不好。所以处理较大数据查询结果展现的时候，分页查询是必不可少的。分页查询必然伴随着一定的排序规则，否则分页数据的状态很难控制，导致用户可能在不同的页看到同一条数据。那么，本文的主要内容就是给大家介绍一下，如何使用Spring Data JPA进行分页与排序。</p>
<h2 id="二实体定义"><a class="header" href="#二实体定义">二、实体定义</a></h2>
<p>我们使用一个简单的实体定义：Article(文章)</p>
<pre><code>@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Entity
@Table(name=&quot;article&quot;)
public class Article {

    @Id
    @GeneratedValue
    private Long id;

    @Column(nullable = false,length = 32)
    private String author;

    @Column(nullable = false, unique = true,length = 32)
    private String title;

    @Column(length = 512)
    private String content;

    private Date createTime;
}
</code></pre>
<ul>
<li>@Entity 表示这个类是一个实体类，接受JPA控制管理，对应数据库中的一个表</li>
<li>@Table 指定这个类对应数据库中的表名。如果这个类名和数据库表名符合驼峰及下划线规则，可以省略这个注解。如FlowType类名对应表名flow_type。</li>
<li>@Id 指定这个字段为表的主键</li>
<li>@GeneratedValue(strategy=GenerationType.IDENTITY) 指定主键的生成方式，一般主键为自增的话，就采用GenerationType.IDENTITY的生成方式</li>
<li>@Column 注解针对一个字段，对应表中的一列。nullable = false表示数据库字段不能为空, unique = true表示数据库字段不能有重复值,length = 32表示数据库字段最大程度为32.</li>
<li>@Data、@AllArgsConstructor、@NoArgsConstructor、@Builder都是插件lombok的注解，用来帮助我们生成set、get方法、构造函数等实体类的模板代码。</li>
</ul>
<h2 id="三repository定义"><a class="header" href="#三repository定义">三、Repository定义</a></h2>
<p>定义一个接口ArticleRepository继承 PagingAndSortingRepository。PagingAndSortingRepository接口不仅包含基础的CURD函数，还支持排序、分页的接口函数定义。</p>
<pre><code>public interface ArticleRepository extends PagingAndSortingRepository&lt;Article,Long&gt; {
     //查询article表的所有数据，传入Pageable分页参数，不需要自己写SQL
    Page&lt;Article&gt; findAll(Pageable pageable);
    //根据author字段查询article表数据，传入Pageable分页参数，不需要自己写SQL
    Page&lt;Article&gt; findByAuthor(String author, Pageable pageable);
    //根据author字段和title字段，查询article表数据，传入Pageable分页参数，不需要自己写SQL
    Slice&lt;Article&gt; findByAuthorAndTitle(String author, String title, Pageable pageable);
}
</code></pre>
<h2 id="四实现分页"><a class="header" href="#四实现分页">四、实现分页</a></h2>
<p>Pageable 是Spring定义的接口，用于分页参数的传递，我们看看如何使用它。首先将ArticleRepository注入到你需要进行持久层操作的类里面，通常是一个@Service注解的类，然后在服务方法内使用如下代码进行分页操作：查询第一页(从0开始)的数据，每页10条数据。</p>
<pre><code>Pageable pageable = PageRequest.of(0, 10);   //第一页
//Pageable pageable = PageRequest.of(0, 10);  //第二页
//Pageable pageable = PageRequest.of(0, 10);  // 第三页
//数据库操作获取查询结果
Page&lt;Article&gt; articlePage = articleRepository.findAll(pageable);
//将查询结果转换为List
List&lt;Article&gt; articleList = articlePage.getContent();
</code></pre>
<p>findAll方法以Page类的对象作为响应，如果我们想获取查询结果List，可以使用getContent()方法。但是笔者不建议这样进行转换，因为前端展示一个分页列表，不仅需要数据，而且还需要一些分页信息。如：当前第几页，每页多少条，总共多少页，总共多少条。这些信息在Page(articlePage)对象里面均可以获取到(下文中有介绍)。</p>
<h2 id="五实现排序"><a class="header" href="#五实现排序">五、实现排序</a></h2>
<p>Spring Data JPA提供了一个 <code>Sort</code>对象，用以提供一种排序机制。让我们看一下排序的方式。</p>
<pre><code>articleRepository.findAll(Sort.by(&quot;createTime&quot;));

articleRepository.findAll(Sort.by(&quot;author&quot;).ascending()
                        .and(Sort.by(&quot;createTime&quot;).descending()));
</code></pre>
<ul>
<li>第一个findAll方法是按照createTime的升序进行排序</li>
<li>第一个findAll方法是按照author的升序排序，再按照createTime的降序进行排序</li>
</ul>
<h3 id="分页和排序在一起"><a class="header" href="#分页和排序在一起"><strong>分页和排序在一起</strong></a></h3>
<pre><code>Pageable pageable = PageRequest.of(0, 10,Sort.by(&quot;createTime&quot;));
</code></pre>
<h2 id="六slice与page"><a class="header" href="#六slice与page">六、Slice与Page</a></h2>
<p>在ArticleRepository我们看到了一个方法返回Slice和另一个方法返回了Page。它们都是Spring Data JPA的数据响应接口，其中 Page 是 Slice的子接口。它们都用于保存和返回数据。</p>
<h3 id="61slice"><a class="header" href="#61slice">6.1.<strong>Slice</strong></a></h3>
<p>让我们看一下 Slice的一些重要方法。</p>
<pre><code>List &lt;T&gt;  getContent（）; //获取切片的内容

Pageable  getPageable（）; //当前切片的分页信息

boolean  hasContent（）; //是否有查询结果？

boolean  isFirst（）;  //是否是第一个切片

boolean  isLast（）;  //是否是最后一个切片

Pageable nextPageable(); // 下一个切片的分页信息

Pageable previousPageable(); // 上一个切片的分页信息
</code></pre>
<h3 id="62page"><a class="header" href="#62page">6.2.<strong>Page</strong></a></h3>
<p>Page是Slice的子接口，以下是的一些重要方法。</p>
<pre><code>//总页数
int getTotalPages();

//总数据条数
long getTotalElements();
</code></pre>
<p><strong>那么，什么时候使用Slice？什么时候使用Page？</strong>
答：通过这两个接口的函数定义可以看出，Slice只关心是不是存在下一个分片(分页)，不会去数据库count计算总条数、总页数。所以比较适合大数据量列表的的鼠标或手指滑屏操作，不关心总共有多少页，只关心有没有下一页。Page比较适合传统应用中的table开发，需要知道总页数和总条数。</p>
<h2 id="期待您的关注"><a class="header" href="#期待您的关注">期待您的关注</a></h2>
<ul>
<li>博主最近新写了一本书：<a href="http://springboot.zimug.com/">《手摸手教您学习SpringBoot系列-16章97节》</a></li>
<li>本文转载注明出处（必须带连接，不能只转文字）：<a href="http://www.zimug.com/">字母哥博客</a>。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p><a href="https://www.cnblogs.com/xiaoqi/p/spring-valid.html">Spring中的@Valid 和 @Validated注解你用对了吗</a></p>
<p><a href="https://www.jianshu.com/p/816c90b6ddc5">自定义注解参数校验</a></p>
<p><a href="https://blog.csdn.net/qq_27802653/article/details/103524075">SpringBoot中使用Hibernate-validator的自定义validator和GlobalExceptionHandLer进行参数校验和异常处理</a></p>
<p><a href="https://blog.csdn.net/FU250/article/details/80247930">使用@Valid+BindingResult进行controller参数校验</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h3 id="220104"><a class="header" href="#220104">22.01.04</a></h3>
<p>Oracle数据库执行insert语句后一定要提交事务，不然无法插入到数据库。</p>
<p><img src="xbell/.%5Cimg%5C2022_01_04_09_19_01.JPG" alt="2022_01_04_09_19_01" /></p>
<h3 id="220106"><a class="header" href="#220106">22.01.06</a></h3>
<h4 id="在oracle里表的别名不能用as列的别名可以用as"><a class="header" href="#在oracle里表的别名不能用as列的别名可以用as">在Oracle里，表的别名不能用as,列的别名可以用as</a></h4>
<pre><code class="language-sql">select a.appname from appinfo a;-- 正确
select a.appname from appinfo as a;-- 错误
</code></pre>
<h4 id="element-ui-table中排序-取消表格默认排序问题"><a class="header" href="#element-ui-table中排序-取消表格默认排序问题">element-ui table中排序 取消表格默认排序问题</a></h4>
<p>sortTable 设置为 custom
一定要设置在列上
<img src="https://images2018.cnblogs.com/blog/1190540/201807/1190540-20180706140942741-400830115.png" alt="img" />
<img src="https://images2018.cnblogs.com/blog/1190540/201807/1190540-20180706140953943-612677602.png" alt="img" /></p>
<pre><code class="language-xml">&lt;el-table-column sortable=&quot;custom&quot; prop=&quot;xm&quot; label=&quot;姓名&quot; show-overflow-tooltip /&gt;
&lt;el-table-column sortable=&quot;custom&quot; prop=&quot;gh&quot; label=&quot;工号&quot; /&gt;
&lt;el-table-column sortable=&quot;custom&quot; prop=&quot;bmmc&quot; label=&quot;部门名称&quot; /&gt;
&lt;!-- 下面这个没添加表示不需要排序 --&gt;
&lt;el-table-column prop=&quot;kpmc&quot; label=&quot;考评轮次名称&quot; /&gt;
</code></pre>
<h3 id="220107"><a class="header" href="#220107">22.01.07</a></h3>
<p>jpa相关解决方案</p>
<blockquote>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><ol>
<li>
<p>jquery 使 input 获取焦点 <code>$(&quot;#credit&quot;).focus();</code></p>
</li>
<li>
<p>jquery 设置 input 的值 <code>$(&quot;#credit&quot;).val(value);</code></p>
</li>
<li>
<p>设置属性值</p>
</li>
</ol>
<pre><code class="language-javascript">$(&quot;#credit&quot;).attr(&quot;required&quot;, false);  //必须输入设为 false
$(&quot;#credit&quot;).attr(&quot;readonly&quot;, true);  //只读设为 true
</code></pre>
<ol start="4">
<li>ajax json请求</li>
</ol>
<pre><code class="language-javascript">$.ajax({
  url: &quot;&lt;%=basePath%&gt;course/submitFrom&quot;,
  type: &quot;POST&quot;,
  data: JSON.stringify(this.form),
  dataType: &quot;json&quot;,
  contentType: &quot;application/json;charset=utf-8&quot;,
  success: function (result) {
    alert(&quot;test&quot;);
  }
});
</code></pre>
<p>后端就可以用map接收</p>
<pre><code class="language-java">@RequestMapping(value = &quot;/submitFrom&quot;, method = RequestMethod.POST)
@ResponseBody
public void submitFrom(@RequestBody HashMap map){
  System.out.println(map);
}
</code></pre>
<ol start="5">
<li>jquery ajax属性async(同步异步)</li>
</ol>
<pre><code class="language-javascript">$.ajax({
  url: &quot;url&quot;,
  type: &quot;GET&quot;,
  asyns: false  //关键是这个参数 是否异步请求=&gt;false:使用同步请求
})
</code></pre>
<ol start="6">
<li>vue ajax请求数据不更新
主要原因是指示的this不同导致的，jquery中是全局dom,vue中是vue dom</li>
</ol>
<pre><code class="language-javascript">selectUser() {
    let vm = this;  //全局 DOM VUE 化
    $.ajax({
        url: &quot;&lt;%=basePath%&gt;course/test&quot;,
        type: &quot;GET&quot;,
        success: function (result) {
            vm.$set(vm, 'message', result);
            // this.$set(vm, 'message', result);
        }
    });
}
</code></pre>
<ol start="7">
<li>清空表单from</li>
</ol>
<pre><code class="language-javascript">$('#myFrom').resetForm();  //清空表单
</code></pre>
<ol start="8">
<li>获取radio值</li>
</ol>
<pre><code class="language-javascript">var status = $(&quot;input[name='status']:checked&quot;).val();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="golang知识"><a class="header" href="#golang知识">golang知识</a></h1>
<p>链接：</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/a31e4ee25305">Golang 微框架 Gin 简介</a></p>
<p><a href="https://laravelacademy.org/post/21861">go教程网址</a>
<a href="golang/"></a>
<a href="golang/"></a>
<a href="golang/"></a></p>
</blockquote>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
)

func main() {

	fmt.Println(&quot;Test&quot;)

	//
	dir, _ := ioutil.ReadDir(&quot;F:\\project\\java\\hqqich.github.io\\src\\onenote&quot;)

	for i := range dir {
		info := dir[i]

		isDir := info.IsDir()
		if isDir {
			continue
		}

		name := info.Name()
		result := name[0 : len(name)-3]

		fmt.Println(&quot;  - [&quot; + result + &quot;](onenote/&quot; + name + &quot;)&quot;)
	}

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java知识"><a class="header" href="#java知识">java知识</a></h1>
<blockquote>
<p>java知识点</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spring"><a class="header" href="#spring">spring</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="postmapping使用"><a class="header" href="#postmapping使用">@postMapping使用</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="杂项"><a class="header" href="#杂项">杂项</a></h1>
<p>JPA提供的四种标准用法为TABLE，SEQUENCE，IDENTITY，AUTO。</p>
<blockquote>
<p>a，TABLE：使用一个特定的数据库表格来保存主键。</p>
<p>b，SEQUENCE：根据底层数据库的序列来生成主键，条件是数据库支持序列。</p>
<p>c，IDENTITY：主键由数据库自动生成（主要是自动增长型）</p>
<p>d，AUTO：主键由程序控制。 </p>
</blockquote>
<h2 id="list--遍历"><a class="header" href="#list--遍历">list  遍历</a></h2>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
* Java之List集合遍历的几种方法
*
* @author：  Rodge
* @time：    2018年10月4日 下午1:21:02
* @version： V1.0.0
*/
public class ListTest {

	public static void main(String[] args) {
		List&lt;String&gt; list = new ArrayList&lt;&gt;();
		list.add(&quot;java&quot;);
		list.add(&quot;C&quot;);
		list.add(&quot;C++&quot;);
		list.add(&quot;C#&quot;);
		list.add(&quot;PHP&quot;);
		
		/*
		 * 第一种：一般for循环
		 */
		for (int i = 0; i &lt; list.size(); i++) {
			System.out.println(&quot;一般for循环：&quot; + list.get(i));
		}
		
		/*
		 * 第二种：增强for循环
		 */
		for (String str : list) {
			System.out.println(&quot;增强for循环：&quot; + str);
		}
		
		/*
		 * 第三种：迭代器1遍历
		 */
		for (Iterator&lt;String&gt; it = list.iterator(); it.hasNext();) {
			System.out.println(&quot;迭代器1遍历：&quot; + it.next());
		}
		
		/*
		 * 第四种：迭代器2遍历
		 */
		Iterator&lt;String&gt; it = list.iterator();
		while (it.hasNext()) {
			System.out.println(&quot;迭代器2遍历：&quot; + it.next());
		}
		
		/*
		 * 第五种：java8 Lambda表达式
		 */
		list.forEach(s -&gt; {
			System.out.println(&quot;java8 Lambda表达式：&quot; + s);
		});
		
		/*
		 * 第六种：java8 stream 有序流
		 */
		list.stream().forEach(s -&gt; {
			System.out.println(&quot;java8 stream 有序流：&quot; + s);
		});
		
		/*
		 * 第七种：java8 stream 并行流
		 */
		list.parallelStream().forEach(s -&gt; {
			System.out.println(&quot;java8 stream 并行流：&quot; + s);
		});
		
	}

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="column注解及属性详解"><a class="header" href="#column注解及属性详解">@Column注解及属性详解</a></h1>
<h4 id="column注解"><a class="header" href="#column注解">@Column注解</a></h4>
<p>用来标识实体类中属性与数据表中字段的对应关系</p>
<h6 id="1源码"><a class="header" href="#1源码">（1）源码：</a></h6>
<pre><code class="language-java">/*
 * Copyright (c) 2008, 2009, 2011 Oracle, Inc. All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 and Eclipse Distribution License v. 1.0
 * which accompanies this distribution.  The Eclipse Public License is available
 * at http://www.eclipse.org/legal/epl-v10.html and the Eclipse Distribution License
 * is available at http://www.eclipse.org/org/documents/edl-v10.php.
 */

package javax.persistence;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import java.lang.annotation.Retention;
import java.lang.annotation.Target;


@Target({METHOD, FIELD})
@Retention(RUNTIME)
public @interface Column {

	/**
	 * (Optional) The name of the column. Defaults to
	 * the property or field name.
	 */
	String name() default &quot;&quot;;


	/**
	 * (Optional) Whether the column is a unique key.  This is a shortcut for the
	 * &lt;code&gt;UniqueConstraint&lt;/code&gt; annotation at the table level and is useful for when the unique
	 * key constraint corresponds to only a single column. This constraint applies in addition to
	 * any constraint entailed by primary key mapping and to constraints specified at the table
	 * level.
	 */
	boolean unique() default false;


	/**
	 * (Optional) Whether the database column is nullable.
	 */
	boolean nullable() default true;


	/**
	 * (Optional) Whether the column is included in SQL INSERT
	 * statements generated by the persistence provider.
	 */
	boolean insertable() default true;


	/**
	 * (Optional) Whether the column is included in SQL UPDATE
	 * statements generated by the persistence provider.
	 */
	boolean updatable() default true;

	/**
	 * (Optional) The SQL fragment that is used when
	 * generating the DDL for the column.
	 *
	 *
	 * &lt;p&gt; Defaults to the generated SQL to create a
	 * column of the inferred type.
	 */
	String columnDefinition() default &quot;&quot;;


	/**
	 * (Optional) The name of the table that contains the column.
	 * &lt;p&gt;
	 * &lt;p&gt;
	 * If absent the column is assumed to be in the primary table.
	 */
	String table() default &quot;&quot;;


	/**
	 * (Optional) The column length. (Applies only if a
	 * string-valued column is used.)
	 */
	int length() default 255;


	/**
	 * (Optional) The precision for a decimal (exact numeric)
	 * column. (Applies only if a decimal column is used.)
	 * Value must be set by developer if used when generating
	 * the DDL for the column.
	 */
	int precision() default 0;


	/**
	 * (Optional) The scale for a decimal (exact numeric) column.
	 * (Applies only if a decimal column is used.)
	 */
	int scale() default 0;

}
</code></pre>
<h6 id="2column属性详解"><a class="header" href="#2column属性详解">（2）@Column属性详解：</a></h6>
<p>name
定义了被标注字段在数据库表中所对应字段的名称；</p>
<p>unique
表示该字段是否为唯一标识，默认为false。如果表中有一个字段需要唯一标识，则既可以使用该标记，也可以使用@Table标记中的@UniqueConstraint。</p>
<p>nullable
表示该字段是否可以为null值，默认为true。</p>
<p>insertable
表示在使用“INSERT”脚本插入数据时，是否需要插入该字段的值。</p>
<p>updatable
表示在使用“UPDATE”脚本插入数据时，是否需要更新该字段的值。insertable和updatable属性一般多用于只读的属性，例如主键和外键等。这些字段的值通常是自动生成的。</p>
<p>columnDefinition（大多数情况，几乎不用）
表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用。（也就是说，如果DB中表已经建好，该属性没有必要使用。）</p>
<p>table
表示当映射多个表时，指定表的表中的字段。默认值为主表的表名。</p>
<p>length
表示字段的长度，当字段的类型为varchar时，该属性才有效，默认为255个字符。</p>
<p>precision和scale
precision属性和scale属性表示精度，当字段类型为double时，precision表示数值的总长度，scale表示小数点所占的位数。</p>
<h6 id="3column可以标注在属性前或getter方法前"><a class="header" href="#3column可以标注在属性前或getter方法前">（3）@Column可以标注在属性前或getter方法前；</a></h6>
<p>Ⅰ.@Column标注在属性前（<strong>建议使用这一种方式）</strong></p>
<pre><code class="language-java">import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;


/**
 * 一卡通消费记录表
 *
 * @author Qian
 */

@Entity
@Table(name = &quot;pb_op_card_consume&quot;)
@Data
public class CardConsume {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = &quot;id&quot;, length = 20, nullable = false)
	private int id;
	
	/**
	 * 交易编号
	 */
	@Column(name = &quot;tradeNo&quot;, length = 50, nullable = false)
	private String tradeNo;
	
}
</code></pre>
<p>Ⅱ.@Column标注getter方法前</p>
<pre><code class="language-html">import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Table;

/**
 * 一卡通消费记录表
 * @author Qian
 *
 */
@Entity
@Table(name = &quot;pb_op_card_consume&quot;)
public class CardConsume {

    /**
     * 交易编号
     */
    private String tradeNo;

	@Column(name = &quot;tradeNo&quot; ,length = 50 , nullable = false)
    public String getTradeNo() {
        return tradeNo;
    }

    public void setTradeNo(String tradeNo) {
        this.tradeNo = tradeNo;
    }

}
</code></pre>
<p>提示：JPA规范中并没有明确指定那种标注方法，只要两种标注方式任选其一都可以。</p>
<p>（4）示例（其中3、4不常用）</p>
<p>Example 1:  指定字段“tradeNo”交易编号的长度为50，且值不能为null</p>
<pre><code class="language-html">@Column(name = &quot;tradeNo&quot;, length = 50, nullable = false)
private String tradeNo;
</code></pre>
<p>Example 2:  指定字段“totalAmount”交易金额的精度（长度）为10，小数点位数为2位，且值不能为null</p>
<pre><code class="language-html">@Column(name = &quot;totalAmount&quot;, precision = 10, scale = 2, nullable = false)
private BigDecimal totalAmount;
</code></pre>
<p>Example 3:  字段“text”，指定建表时SQL语句 如“varchar(50) NOT NULL”</p>
<pre><code class="language-html">@Column(name = &quot;text&quot;, columnDefinition = &quot;varchar(50) not null&quot;)
private String text;
</code></pre>
<p>等同于SQL</p>
<pre><code class="language-html">CREATE TABLE [dbo].[my_test] (
    [id] int NOT NULL IDENTITY(1,1) ,
    [text] varchar(50) NOT NULL
)
</code></pre>
<p>columnDefinition，若不指定该属性，通常使用默认的类型建表，若此时需要自定义建表的类型时，可在该属性中设置。</p>
<p>Example 4:  字段值为只读的，不允许插入和修改。通常用于主键和外键</p>
<pre><code class="language-html">@Column(name = &quot;id&quot;, insertable = false, updatable = false)
private Integer id;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="requestbody的使用"><a class="header" href="#requestbody的使用">@RequestBody的使用</a></h1>
<p>**提示：**建议一定要看后面的@RequestBody的核心逻辑源码以及六个重要结论！本文前半部分的内容都是一些基
本知识常识，可选择性跳过。</p>
<p>**<em>声明</em>：**本文是基于SpringBoot，进行的演示说明。</p>
<hr />
<h3 id="基础知识介绍"><a class="header" href="#基础知识介绍">基础知识介绍：</a></h3>
<p>​    @RequestBody主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的)；GET方式无请求体，所以使用@RequestBody接收数据时，前端不能使用GET方式提交数据，而是用POST方式进行提交。在后端的同一个接收方法里，@RequestBody与@RequestParam()可以同时使用，@RequestBody最多只能有一个，而@RequestParam()可以有多个。</p>
<p>注：一个请求，只有一个RequestBody；一个请求，可以有多个RequestParam。</p>
<p>注：当同时使用@RequestParam（）和@RequestBody时，@RequestParam（）指定的参数可以是普通元素、
数组、集合、对象等等(即:当，@RequestBody 与@RequestParam()可以同时使用时，原SpringMVC接收
参数的机制不变，只不过RequestBody 接收的是请求体里面的数据；而RequestParam接收的是key-value
里面的参数，所以它会被切面进行处理从而可以用普通元素、数组、集合、对象等接收)。
即：如果参数时放在请求体中，application/json传入后台的话，那么后台要用@RequestBody才能接收到；
如果不是放在请求体中的话，那么后台接收前台传过来的参数时，要用@RequestParam来接收，或
则形参前 什么也不写也能接收。</p>
<p>注：如果参数前写了@RequestParam(xxx)，那么前端必须有对应的xxx名字才行(不管其是否有值，当然可以通
过设置该注解的required属性来调节是否必须传)，如果没有xxx名的话，那么请求会出错，报400。</p>
<p>注：如果参数前不写@RequestParam(xxx)的话，那么就前端可以有可以没有对应的xxx名字才行，如果有xxx名
的话，那么就会自动匹配；没有的话，请求也能正确发送。
追注：这里与feign消费服务时不同；feign消费服务时，如果参数前什么也不写，那么会被默认是
@RequestBody的。</p>
<p>如果后端参数是一个对象，且该参数前是以@RequestBody修饰的，那么前端传递json参数时，必须满足以下要求：</p>
<ul>
<li>后端@RequestBody注解对应的类在将HTTP的输入流(含请求体)装配到目标类(即：@RequestBody后面的类)时，会根据json字符串中的key来匹配对应实体类的属性，如果匹配一致且json中的该key对应的值符合(或可转换为)，这一条我会在下面详细分析，其他的都可简单略过，但是****<em>*本文末的核心逻辑代码以及几个结论一定要看！**</em>*** 实体类的对应属性的类型要求时,会调用实体类的setter方法将值赋给该属性。</li>
<li>json字符串中，如果value为&quot;&quot;的话，后端对应属性如果是String类型的，那么接受到的就是&quot;&quot;，如果是后端属性的类型是Integer、Double等类型，那么接收到的就是null。</li>
<li>json字符串中，如果value为null的话，后端对应收到的就是null。</li>
<li>如果某个参数没有value的话，在传json字符串给后端时，要么干脆就不把该字段写到json字符串中；要么写value时， 必须有值，null 或&quot;&quot;都行。千万不能有类似&quot;stature&quot;:，这样的写法，如:</li>
</ul>
<p><img src="https://img-blog.csdn.net/2018081416513428?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" /></p>
<p>注：关于@RequestParam()的用法，这里就不再一一说明了，可详见 《程序员成长笔记(一)》中的相关章节。</p>
<hr />
<h3 id="示例详细说明"><a class="header" href="#示例详细说明"><strong><em>*示例详细说明*</em>：</strong></a></h3>
<p>先给出两个等下要用到的实体类</p>
<p>User实体类：</p>
<p><img src="https://img-blog.csdn.net/2018070916051666?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" /></p>
<p>Team实体类：</p>
<p><img src="https://img-blog.csdn.net/20180709160527153?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" /></p>
<p>**<em>*@RequestBody直接以String接收*<em>前端传过来的json数据：</em></em></p>
<p>后端对应的Controller：</p>
<p><img src="https://img-blog.csdn.net/20180709160555265?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" /></p>
<p>使用PostMan测试：</p>
<p><img src="https://img-blog.csdn.net/20180709160600561?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" /></p>
<p>**<em>*@RequestBody以简单对象接收*<em>前端传过来的json数据：</em></em></p>
<p>后端对应的Controller：</p>
<p><img src="https://img-blog.csdn.net/20180709160606459?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" /></p>
<p>使用PostMan测试：</p>
<p><img src="https://img-blog.csdn.net/20180709160611656?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" /></p>
<p>**<em>*@RequestBody以复杂对象接收*<em>前端传过来的json数据：</em></em></p>
<p>后端对应的Controller：</p>
<p><img src="https://img-blog.csdn.net/20180709160616858?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" /></p>
<p>使用PostMan测试：</p>
<p><img src="https://img-blog.csdn.net/20180709160621609?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" /></p>
<p><strong><em>*@RequestBody与简单的@RequestParam()同时使用*</em>：</strong></p>
<p>后端对应的Controller：</p>
<p><img src="https://img-blog.csdn.net/20180709160627264?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" /></p>
<p>使用PostMan测试：</p>
<p><img src="https://img-blog.csdn.net/20180709160632187?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" /></p>
<p><strong><em>*@RequestBody与复杂的@RequestParam()同时使用*</em>：</strong></p>
<p>后端对应的Controller：</p>
<p><img src="https://img-blog.csdn.net/20180709160638747?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" /></p>
<p>使用PostMan测试：</p>
<p><img src="https://img-blog.csdn.net/20180709160643571?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" /></p>
<p><strong><em>*@RequestBody接收请求体中的json数据；不加注解接收URL中的数据并组装为对象*</em>：</strong></p>
<p>后端对应的Controller：</p>
<p><img src="https://img-blog.csdn.net/20180709160650553?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" /></p>
<p>使用PostMan测试：</p>
<p><img src="https://img-blog.csdn.net/20180709160657535?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" /></p>
<p>注：如果在后端方法参数前，指定了@RequestParam()的话，那么前端必须要有对应字段才行(当然可以通过设置
该注解的required属性来调节是否必须传)，否者会报错；如果参数前没有任何该注解，那么前端可以传，也可
以不传，如：</p>
<p><img src="https://img-blog.csdn.net/20180709160707815?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" /></p>
<p>上图中，如果我们传参中没有指定token，那么请求能正常进去，但是token为null；如果在String token前指定了@RequestParam(“token”)，那么前端必须要有token这个键时，请求才能正常进去，否者报400错误。</p>
<hr />
<h3 id="requestbody与前端传过来的json数据的匹配规则"><a class="header" href="#requestbody与前端传过来的json数据的匹配规则">@RequestBody与前端传过来的json数据的匹配规则</a></h3>
<p>声明：根据不同的Content-Type等情况,Spring-MVC会采取不同的HttpMessageConverter实现来进行信息转换解析。
下面介绍的是最常用的：前端以Content-Type 为application/json,传递json字符串数据;后端以@RequestBody
模型接收数据的情况。</p>
<p><strong>解析json数据大体流程概述</strong>**：**
**Http传递请求体信息，最终会被封装进com.fasterxml.jackson.core.json.UTF8StreamJsonParser中(提示：Spring采用CharacterEncodingFilter设置了默认编码为UTF-8)，然后在*<em>public*</em> *<em>class*</em> *<em>BeanDeserializer*</em> *<em>extends*</em> *<em>BeanDeserializerBase*</em> *<em>implements*</em> *<em>java.io.Serializable*</em>*<em>中，通过*</em> *<em>public*</em> *<em>Object deserializeFromObject(JsonParser*</em> *<em>p*</em>*<em>, DeserializationContext*</em> *<em>ctxt*</em>*<em>)*</em> *<em>throws*</em> *<em>IOException*</em>**方法****<strong>进行解析</strong>。</p>
<h3 id="核心逻辑分析示例"><a class="header" href="#核心逻辑分析示例">核心逻辑分析示例：</a></h3>
<p>​    假设前端传的json串是这样的： <strong>{&quot;name1&quot;:&quot;邓沙利文&quot;,&quot;age&quot;:123,&quot;mot&quot;:&quot;我是一只小小小小鸟~&quot;}</strong> 后端的模型只有name和age属性，以及对应的setter/getter方法；给出一般用到的deserializeFromObject(JsonParser p, DeserializationContext ctxt)方法的****核心逻辑：****</p>
<p><img src="https://img-blog.csdn.net/20180915034035239?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" /></p>
<hr />
<h3 id="小技巧之指定模型中的属性对应什么key"><a class="header" href="#小技巧之指定模型中的属性对应什么key">小技巧之指定模型中的属性对应什么key</a></h3>
<p>这里简单介绍，更多的可参考：</p>
<p>​      <strong><em>*</em>*public****</strong> *<strong>*<em>*class**</em>*</strong> BeanPropertyMap <strong><em>*</em>*implements****</strong> Iterable<SettableBeanProperty>,java.io.Serializable</p>
<p>给出Controller中的测试类:</p>
<p><img src="https://img-blog.csdn.net/20180915034403962?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" /></p>
<p>给出模型中的属性(setter/getter方法没截出来)：</p>
<p><img src="https://img-blog.csdn.net/20180915034429725?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" /></p>
<p>使用postman测试一下，示例：</p>
<p><img src="https://img-blog.csdn.net/20180915034441260?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" /></p>
<p>上图简单测试了一下，但是测得并不全面,这里就不带大家一起测试了，直接给出。</p>
<hr />
<h3 id="全面的结论"><a class="header" href="#全面的结论"><strong>全面的结论</strong>：</a></h3>
<p><strong><em>*</em>*结论****</strong><em><strong>*<em>*①**</em>***：*</strong></em><strong>@JsonAlias</strong>注解，实现:json转模型时，使json中的特定key能转化为特定的模型属性;但是模型转json时，
对应的转换后的key仍然与属性名一致，见：上图示例中的name字段的请求与响应。
以下图进一步说明：</p>
<p><img src="https://img-blog.csdn.net/2018091503455519?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" /></p>
<p>​         此时，json字符串转换为模型时，json中key为Name或为name123或为name的都能识别。</p>
<p><strong><em>*</em>*结论****</strong><em><strong>*<em>*②**</em>***：*</strong></em><strong>@JsonProperty</strong>注解，实现：json转模型时，使json中的特定key能转化为指定的模型属性；同样的，模
型转json时，对应的转换后的key为指定的key，见：示例中的motto字段的请求与响应。
以下图进一步说明：</p>
<p><img src="https://img-blog.csdn.net/20180915034605938?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" /></p>
<p>​        此时，json字符串转换为模型时，key为MOTTO的能识别，但key为motto的不能识别。</p>
<p><strong><em>*</em>*结论****</strong>*<strong>*<em>*③**</em>*<em>*：*</em></strong>@JsonAlias注解需要依赖于setter、getter，而@JsonProperty注解不需要。</p>
<p><strong><em>*</em>*结论****</strong>****<em>*④**</em>***：****在不考虑上述两个注解的一般情况下，key与属性匹配时,默认大小写敏感。</p>
<p><strong><em>*</em>*结论****</strong>****<em>*⑤**</em>***：****有多个相同的key的json字符串中，转换为模型时，会以相同的几个key中，排在最后的那个key的值给模
型属性复制，因为setter会覆盖原来的值。见示例中的gender属性。</p>
<p><strong><em>*</em>*结论****</strong>****<em>*⑥**</em>***：****后端@RequestBody注解对应的类在将HTTP的输入流(含请求体)装配到目标类(即:@RequestBody后面
的类)时，会根据json字符串中的key来匹配对应实体类的属性，如果匹配一致且json中的该key对应的值
符合(或可转换为)实体类的对应属性的类型要求时，会调用实体类的setter方法将值赋给该属性。</p>
<h3 id=""><a class="header" href="#"></a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparable和comparator的区别"><a class="header" href="#comparable和comparator的区别">Comparable和Comparator的区别</a></h1>
<p>初次碰到这个问题是之前有一次电话面试，问了一个小时的问题，其中有一个问题就问到Comparable和Comparator的区别，当时没答出 来。之后是公司入职时候做的一套Java编程题，里面用JUnit跑用例的时候也用到了Comparator接口，再加上JDK的大量的类包括常见的  String、Byte、Char、Date等都实现了Comparable接口，因此要学习一下这两个类的区别以及用法。</p>
<p><strong>Comparable</strong></p>
<p>Comparable可以认为是一个<strong>内比较器</strong>，实现了Comparable接口的类有一个特点，就是这些类是可以和自己比较的，至于具体和另一个实现了Comparable接口的类如何比较，则依赖compareTo方法的实现，compareTo方法也被称为<strong>自然比较方法</strong>。如果开发者add进入一个Collection的对象想要Collections的sort方法帮你自动进行排序的话，那么这个对象必须实现Comparable接口。compareTo方法的返回值是int，有三种情况：</p>
<p>1、比较者大于被比较者（也就是compareTo方法里面的对象），那么返回正整数</p>
<p>2、比较者等于被比较者，那么返回0</p>
<p>3、比较者小于被比较者，那么返回负整数</p>
<p>写个很简单的例子：</p>
<pre><code>public class Domain implements Comparable&lt;Domain&gt;
{
    private String str;

    public Domain(String str)
    {
        this.str = str;
    }

    public int compareTo(Domain domain)
    {
        if (this.str.compareTo(domain.str) &gt; 0)
            return 1;
        else if (this.str.compareTo(domain.str) == 0)
            return 0;
        else 
            return -1;
    }
    
    public String getStr()
    {
        return str;
    }
}
</code></pre>
<pre><code>public static void main(String[] args)
    {
        Domain d1 = new Domain(&quot;c&quot;);
        Domain d2 = new Domain(&quot;c&quot;);
        Domain d3 = new Domain(&quot;b&quot;);
        Domain d4 = new Domain(&quot;d&quot;);
        System.out.println(d1.compareTo(d2));
        System.out.println(d1.compareTo(d3));
        System.out.println(d1.compareTo(d4));
    }
</code></pre>
<p>运行结果为：</p>
<pre><code>0
1
-1
</code></pre>
<p>注意一下，前面说实现Comparable接口的类是可以支持和自己比较的，但是其实代码里面Comparable的泛型未必就一定要是Domain，将泛型指定为String或者指定为其他任何任何类型都可以----只要开发者指定了具体的比较算法就行。</p>
<p><strong>Comparator</strong></p>
<p>Comparator可以认为是是一个<strong>外比较器</strong>，个人认为有两种情况可以使用实现Comparator接口的方式：</p>
<p>1、一个对象不支持自己和自己比较（没有实现Comparable接口），但是又想对两个对象进行比较</p>
<p>2、一个对象实现了Comparable接口，但是开发者认为compareTo方法中的比较方式并不是自己想要的那种比较方式</p>
<p>Comparator接口里面有一个compare方法，方法有两个参数T o1和T o2，是泛型的表示方式，分别表示待比较的两个对象，方法返回值和Comparable接口一样是int，有三种情况：</p>
<p>1、o1大于o2，返回正整数</p>
<p>2、o1等于o2，返回0</p>
<p>3、o1小于o3，返回负整数</p>
<p>写个很简单的例子，上面代码的Domain不变（假设这就是第2种场景，我对这个compareTo算法实现不满意，要自己写实现）：</p>
<pre><code>public class DomainComparator implements Comparator&lt;Domain&gt;
{
    public int compare(Domain domain1, Domain domain2)
    {
        if (domain1.getStr().compareTo(domain2.getStr()) &gt; 0)
            return 1;
        else if (domain1.getStr().compareTo(domain2.getStr()) == 0)
            return 0;
        else 
            return -1;
    }
}
</code></pre>
<pre><code>public static void main(String[] args)
{
    Domain d1 = new Domain(&quot;c&quot;);
    Domain d2 = new Domain(&quot;c&quot;);
    Domain d3 = new Domain(&quot;b&quot;);
    Domain d4 = new Domain(&quot;d&quot;);
    DomainComparator dc = new DomainComparator();
    System.out.println(dc.compare(d1, d2));
    System.out.println(dc.compare(d1, d3));
    System.out.println(dc.compare(d1, d4));
}
</code></pre>
<p>看一下运行结果：</p>
<pre><code>0
1
-1
</code></pre>
<p>当然因为泛型指定死了，所以实现Comparator接口的实现类只能是两个相同的对象（不能一个Domain、一个String）进行比较了，因此实现Comparator接口的实现类一般都会以&quot;待比较的实体类+Comparator&quot;来命名</p>
<p><strong>总结</strong></p>
<p>总结一下，两种比较器Comparable和Comparator，后者相比前者有如下优点：</p>
<p>1、如果实现类没有实现Comparable接口，又想对两个类进行比较（或者实现类实现了Comparable接口，但是对compareTo方法内的比较算法不满意），那么可以实现Comparator接口，自定义一个比较器，写比较算法</p>
<p>2、实现Comparable接口的方式比实现Comparator接口的耦合性  要强一些，如果要修改比较算法，要修改Comparable接口的实现类，而实现Comparator的类是在外部进行比较的，不需要对实现类有任何修  改。从这个角度说，其实有些不太好，尤其在我们将实现类的.class文件打成一个.jar文件提供给开发者使用的时候。实际上实现Comparator 接口的方式后面会写到就是一种典型的<strong>策略模式</strong>。</p>
<p>当然，这不是鼓励用Comparator，意思是开发者还是要在具体场景下选择最合适的那种比较器而已。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="druid数据库连接池"><a class="header" href="#druid数据库连接池">Druid数据库连接池</a></h1>
<ol>
<li>maven添加druid以及mysql连接</li>
</ol>
<pre><code class="language-XML">  &lt;dependency&gt;
       &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
       &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
       &lt;version&gt;1.1.9&lt;/version&gt;
   &lt;/dependency&gt;
   &lt;dependency&gt;
       &lt;groupId&gt;mysql&lt;/groupId&gt;
       &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
   &lt;/dependency&gt;
   &lt;dependency&gt;
       &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
       &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
       &lt;version&gt;1.3.2&lt;/version&gt;
   &lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>配置项</li>
</ol>
<pre><code class="language-yml">
logging.level.com.dobi.order.deal.dao=debug

#spring.profiles.include=druid
mybatis.mapper-locations=classpath:mapper/*.xml

spring.datasource.druid.url=jdbc:mysql://172.16.8.218:3306/dobi_ry?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false
spring.datasource.druid.username=dobi
spring.datasource.druid.password=dobi@123
spring.datasource.druid.driver-class-name=com.mysql.jdbc.Driver
#com.mysql.cj.jdbc.Driver

#\u8FDE\u63A5\u6C60\u914D\u7F6E
spring.datasource.druid.initial-size=5
spring.datasource.druid.max-active=100
spring.datasource.druid.min-idle=5
spring.datasource.druid.max-wait=60000
spring.datasource.druid.pool-prepared-statements=true
spring.datasource.druid.max-pool-prepared-statement-per-connection-size=20
spring.datasource.druid.validation-query=SELECT 1 FROM DUAL
spring.datasource.druid.validation-query-timeout=60000
spring.datasource.druid.test-on-borrow=false
spring.datasource.druid.test-on-return=false
spring.datasource.druid.test-while-idle=true
spring.datasource.druid.time-between-eviction-runs-millis=60000
spring.datasource.druid.min-evictable-idle-time-millis=100000

###\u76D1\u63A7\u914D\u7F6E begin###
# WebStatFilter\u914D\u7F6E\uFF0C\u8BF4\u660E\u8BF7\u53C2\u8003Druid Wiki\uFF0C\u914D\u7F6E_\u914D\u7F6EWebStatFilter
spring.datasource.druid.web-stat-filter.enabled=true
spring.datasource.druid.web-stat-filter.url-pattern=/*
spring.datasource.druid.web-stat-filter.exclusions=*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*
# StatViewServlet\u914D\u7F6E\uFF0C\u8BF4\u660E\u8BF7\u53C2\u8003Druid Wiki\uFF0C\u914D\u7F6E_StatViewServlet\u914D\u7F6E
spring.datasource.druid.stat-view-servlet.enabled= true
spring.datasource.druid.stat-view-servlet.url-pattern= /druid/*
spring.datasource.druid.stat-view-servlet.reset-enable= false
spring.datasource.druid.stat-view-servlet.login-username= admin
spring.datasource.druid.stat-view-servlet.login-password= admin
spring.datasource.druid.stat-view-servlet.allow= 127.0.0.1
###\u76D1\u63A7\u914D\u7F6E end###

# \u914D\u7F6EStatFilter
spring.datasource.druid.filter.stat.db-type=mysql
spring.datasource.druid.filter.stat.log-slow-sql=true
spring.datasource.druid.filter.stat.slow-sql-millis=5000

# \u914D\u7F6EWallFilter
spring.datasource.druid.filter.wall.enabled=true
spring.datasource.druid.filter.wall.db-type=mysql
spring.datasource.druid.filter.wall.config.delete-allow=false
spring.datasource.druid.filter.wall.config.drop-table-allow=false
</code></pre>
<ol start="3">
<li>在启动类Application当中注解扫描dao层包</li>
</ol>
<pre><code class="language-java">@SpringBootApplication
@MapperScan(basePackages = &quot;com.dobi.order.deal.dao&quot;)
@EnableTransactionManagement
</code></pre>
<ol start="4">
<li>监控
http://localhost:5353/druid/login.html</li>
</ol>
<p><code>spring.datasource.druid.stat-view-servlet.allow= 127.0.0.1上配置的ip以及对应项目的端口</code>
查看数据库连接状况</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="elasticsearch数据类型及其属性"><a class="header" href="#elasticsearch数据类型及其属性">Elasticsearch数据类型及其属性</a></h1>
<h4 id="elasticsearch数据类型及其属性-1"><a class="header" href="#elasticsearch数据类型及其属性-1">Elasticsearch数据类型及其属性</a></h4>
<p><strong>一、数据类型</strong></p>
<h5 id="字段类型概述"><a class="header" href="#字段类型概述">字段类型概述</a></h5>
<div class="table-wrapper"><table><thead><tr><th>一级分类</th><th style="text-align: left">二级分类</th><th style="text-align: left">具体类型</th></tr></thead><tbody>
<tr><td>核心类型</td><td style="text-align: left">字符串类型</td><td style="text-align: left">string,text,keyword</td></tr>
<tr><td>h</td><td style="text-align: left">整数类型</td><td style="text-align: left">integer,long,short,byte</td></tr>
<tr><td>h</td><td style="text-align: left">浮点类型</td><td style="text-align: left">double,float,half_float,scaled_float</td></tr>
<tr><td>h</td><td style="text-align: left">逻辑类型</td><td style="text-align: left">boolean</td></tr>
<tr><td>h</td><td style="text-align: left">日期类型</td><td style="text-align: left">date</td></tr>
<tr><td>h</td><td style="text-align: left">范围类型</td><td style="text-align: left">range</td></tr>
<tr><td>h</td><td style="text-align: left">二进制类型</td><td style="text-align: left">binary</td></tr>
<tr><td>复合类型</td><td style="text-align: left">数组类型</td><td style="text-align: left">array</td></tr>
<tr><td>f</td><td style="text-align: left">对象类型</td><td style="text-align: left">object</td></tr>
<tr><td>f</td><td style="text-align: left">嵌套类型</td><td style="text-align: left">nested</td></tr>
<tr><td>地理类型</td><td style="text-align: left">地理坐标类型</td><td style="text-align: left">geo_point</td></tr>
<tr><td>d</td><td style="text-align: left">地理地图</td><td style="text-align: left">geo_shape</td></tr>
<tr><td>特殊类型</td><td style="text-align: left">IP类型</td><td style="text-align: left">ip</td></tr>
<tr><td>t</td><td style="text-align: left">范围类型</td><td style="text-align: left">completion</td></tr>
<tr><td>t</td><td style="text-align: left">令牌计数类型</td><td style="text-align: left">token_count</td></tr>
<tr><td>t</td><td style="text-align: left">附件类型</td><td style="text-align: left">attachment</td></tr>
<tr><td>t</td><td style="text-align: left">抽取类型</td><td style="text-align: left">percolator</td></tr>
</tbody></table>
</div>
<h5 id="核心类型"><a class="header" href="#核心类型">核心类型</a></h5>
<ul>
<li>
<p><strong>1、字符串类型</strong>
　　string类型: 在ElasticSearch 旧版本中使用较多，从ElasticSearch 5.x开始不再支持string，由text和keyword类型替代。
　　text 类型：当一个字段是要被全文搜索的，比如Email内容、产品描述，应该使用text类型。设置text类型以后，字段内容会被分析，在生成倒排索引以前，字符串会被分析器分成一个一个词项。text类型的字段不用于排序，很少用于聚合。
　　keyword
keyword类型适用于索引结构化的字段，比如email地址、主机名、状态码和标签。如果字段需要进行过滤(比如查找已发布博客中status属性为published的文章)、排序、聚合。keyword类型的字段只能通过精确值搜索到。</p>
</li>
<li>
<p><strong>2、整数类型</strong></p>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th style="text-align: center">取值范围</th></tr></thead><tbody>
<tr><td>byte</td><td style="text-align: center">-128~127</td></tr>
<tr><td>short</td><td style="text-align: center">-32768~32767</td></tr>
<tr><td>integer</td><td style="text-align: center">-231~231-1</td></tr>
<tr><td>short</td><td style="text-align: center">-263~263-1</td></tr>
</tbody></table>
</div>
<p>在满足需求的情况下，尽可能选择范围小的数据类型。比如，某个字段的取值最大值不会超过100，那么选择byte类型即可。迄今为止吉尼斯记录的人类的年龄的最大值为134岁，对于年龄字段，short足矣。字段的长度越短，索引和搜索的效率越高。</p>
</li>
<li>
<p><strong>3、浮点类型</strong></p>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th style="text-align: center">取值范围</th></tr></thead><tbody>
<tr><td>doule</td><td style="text-align: center">64位双精度IEEE 754浮点类型</td></tr>
<tr><td>float</td><td style="text-align: center">32位单精度IEEE 754浮点类型</td></tr>
<tr><td>half_float</td><td style="text-align: center">16位半精度IEEE 754浮点类型</td></tr>
<tr><td>scaled_float</td><td style="text-align: center">缩放类型的的浮点数</td></tr>
</tbody></table>
</div>
<p>对于float、half_float和scaled_float,-0.0和+0.0是不同的值，使用term查询查找-0.0不会匹配+0.0，同样range查询中上边界是-0.0不会匹配+0.0，下边界是+0.0不会匹配-0.0。</p>
<p>其中scaled_float，比如价格只需要精确到分，price为57.34的字段缩放因子为100，存起来就是5734
优先考虑使用带缩放因子的scaled_float浮点类型。</p>
</li>
<li>
<p><strong>4、date类型</strong>
日期类型表示格式可以是以下几种：
（1）日期格式的字符串，比如 “2018-01-13” 或 “2018-01-13 12:10:30”
（2）long类型的毫秒数( milliseconds-since-the-epoch，epoch就是指UNIX诞生的UTC时间1970年1月1日0时0分0秒)
（3）integer的秒数(seconds-since-the-epoch)</p>
</li>
<li>
<p>5、boolean类型　true和false</p>
</li>
<li>
<p><strong>6、 binary类型</strong>
　　进制字段是指用base64来表示索引中存储的二进制数据，可用来存储二进制形式的数据，例如图像。默认情况下，该类型的字段只存储不索引。二进制类型只支持index_name属性。</p>
</li>
<li>
<p><strong>7、array类型</strong>
（1）字符数组: [ “one”, “two” ]
（2）整数数组: productid:[ 1, 2 ]
（3）对象（文档）数组: “user”:[ { “name”: “Mary”, “age”: 12 }, { “name”: “John”, “age”: 10 }]，
注意：lasticSearch不支持元素为多个数据类型：[ 10, “some string” ]</p>
</li>
<li>
<p><strong>8、 object类型</strong>
JSON对象，文档会包含嵌套的对象</p>
</li>
<li>
<p><strong>9、ip类型</strong>
p类型的字段用于存储IPv4或者IPv6的地址</p>
</li>
</ul>
<h4 id="二mapping-支持属性"><a class="header" href="#二mapping-支持属性">二、Mapping 支持属性</a></h4>
<ul>
<li>
<p>1、enabled：仅存储、不做搜索和聚合分析</p>
<pre><code class="language-bash">  &quot;enabled&quot;:true （缺省）| false
</code></pre>
</li>
<li>
<p>2、index：是否构建倒排索引（即是否分词，设置false，字段将不会被索引）</p>
<pre><code class="language-bash">      &quot;index&quot;: true（缺省）| false
</code></pre>
</li>
<li>
<p>3、index_option：存储倒排索引的哪些信息</p>
<pre><code class="language-bash">  4个可选参数：
      docs：索引文档号
      freqs：文档号+词频
      positions：文档号+词频+位置，通常用来距离查询
      offsets：文档号+词频+位置+偏移量，通常被使用在高亮字段
  分词字段默认是positions，其他默认时docs
  
  &quot;index_options&quot;: &quot;docs&quot;
</code></pre>
</li>
<li>
<p>4、norms：是否归一化相关参数、如果字段仅用于过滤和聚合分析、可关闭
分词字段默认配置，不分词字段：默认{“enable”: false}，存储长度因子和索引时boost，建议对需要参加评分字段使用，会额外增加内存消耗</p>
<pre><code class="language-bash">  &quot;norms&quot;: {&quot;enable&quot;: true, &quot;loading&quot;: &quot;lazy&quot;}
</code></pre>
</li>
<li>
<p>5、doc_value：是否开启doc_value，用户聚合和排序分析
对not_analyzed字段，默认都是开启，分词字段不能使用，对排序和聚合能提升较大性能，节约内存</p>
<pre><code class="language-bash">  &quot;doc_value&quot;: true（缺省）| false
</code></pre>
</li>
<li>
<p>6、fielddata：是否为text类型启动fielddata，实现排序和聚合分析
针对分词字段，参与排序或聚合时能提高性能，不分词字段统一建议使用doc_value</p>
<pre><code class="language-bash">  &quot;fielddata&quot;: {&quot;format&quot;: &quot;disabled&quot;}
</code></pre>
</li>
<li>
<p>7、store：是否单独设置此字段的是否存储而从_source字段中分离，只能搜索，不能获取值</p>
<pre><code class="language-bash">  &quot;store&quot;: false（默认）| true
</code></pre>
</li>
<li>
<p>8、coerce：是否开启自动数据类型转换功能，比如：字符串转数字，浮点转整型</p>
<pre><code class="language-bash">  &quot;coerce: true（缺省）| false&quot;
</code></pre>
</li>
<li>
<p>9、multifields：灵活使用多字段解决多样的业务需求</p>
</li>
<li>
<p>11、dynamic：控制mapping的自动更新</p>
<pre><code class="language-ruby">  &quot;dynamic&quot;: true（缺省）| false | strict
</code></pre>
</li>
</ul>
<p>1</p>
<ul>
<li>
<p>12、data_detection：是否自动识别日期类型</p>
<pre><code class="language-bash">  &quot;data_detection&quot;：true（缺省）| false
</code></pre>
</li>
</ul>
<p><a href="https://blog.csdn.net/zx711166/article/details/82427837/">dynamic和data_detection的详解：Elasticsearch dynamic mapping（动态映射） 策略</a>.</p>
<ul>
<li>
<p>13、analyzer：指定分词器，默认分词器为standard analyzer</p>
<pre><code class="language-bash">  &quot;analyzer&quot;: &quot;ik&quot;
</code></pre>
</li>
<li>
<p>14、boost：字段级别的分数加权，默认值是1.0</p>
<pre><code class="language-bash">  &quot;boost&quot;: 1.23
</code></pre>
</li>
<li>
<p>15、fields：可以对一个字段提供多种索引模式，同一个字段的值，一个分词，一个不分词</p>
<pre><code class="language-bash">  &quot;fields&quot;: {&quot;raw&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;index&quot;: &quot;not_analyzed&quot;}}
</code></pre>
</li>
<li>
<p>16、ignore_above：超过100个字符的文本，将会被忽略，不被索引</p>
<pre><code class="language-bash">  &quot;ignore_above&quot;: 100
</code></pre>
</li>
<li>
<p>17、include_in_all：设置是否此字段包含在_all字段中，默认时true，除非index设置成no</p>
<pre><code class="language-bash">  &quot;include_in_all&quot;: true
</code></pre>
</li>
<li>
<p>18、null_value：设置一些缺失字段的初始化，只有string可以使用，分词字段的null值也会被分词</p>
<pre><code class="language-bash">  &quot;null_value&quot;: &quot;NULL&quot;
</code></pre>
</li>
<li>
<p>19、position_increament_gap：影响距离查询或近似查询，可以设置在多值字段的数据上或分词字段上，查询时可以指定slop间隔，默认值时100</p>
<pre><code class="language-bash">  &quot;position_increament_gap&quot;: 0
</code></pre>
</li>
<li>
<p>20、search_analyzer：设置搜索时的分词器，默认跟analyzer是一致的，比如index时用standard+ngram，搜索时用standard用来完成自动提示功能</p>
<pre><code class="language-bash">  &quot;search_analyzer&quot;: &quot;ik&quot;
</code></pre>
</li>
<li>
<p>21、similarity：默认时TF/IDF算法，指定一个字段评分策略，仅仅对字符串型和分词类型有效</p>
<pre><code class="language-bash">  &quot;similarity&quot;: &quot;BM25&quot;
</code></pre>
</li>
<li>
<p>22、trem_vector：默认不存储向量信息，支持参数yes（term存储），with_positions（term+位置），with_offsets（term+偏移量），with_positions_offsets（term+位置+偏移量）对快速高亮fast vector highlighter能提升性能，但开启又会加大索引体积，不适合大数据量用</p>
<pre><code class="language-bash">  &quot;trem_vector&quot;: &quot;no&quot;
</code></pre>
</li>
</ul>
<h4 id="三mapping-字段设置流程"><a class="header" href="#三mapping-字段设置流程">三、Mapping 字段设置流程</a></h4>
<p><img src="https://upload-images.jianshu.io/upload_images/11362584-34bc6bfcdf6a79f8?imageMogr2/auto-orient/strip%7CimageView2/2/w/951/format/webp" alt="img" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gson"><a class="header" href="#gson">GSON</a></h1>
<p>GSON弥补了JSON的许多不足的地方，在实际应用中更加适用于Java开发。在这里，我们主要讲解的是利用GSON来操作java对象和json数据之间的相互转换，包括了常见的对象序列化和反序列化的知识。</p>
<h2 id="一前言"><a class="header" href="#一前言">一、前言</a></h2>
<p>因为json有2种类型：</p>
<ul>
<li>一种是对象，<code>object</code> -&gt; <code>{key:value,key:value,...}</code> 。</li>
<li>另一种是数组，<code>array</code> -&gt; <code>[value,value,...]</code> 。</li>
</ul>
<p>所以针对这两种类型，来展开对json数据的操作。</p>
<p>GSON在解析json的时候，大体上有2种类型，一种是直接在内存中生成object或array，通过手工指定key来获取值；另一种是借助javabean来进行映射获取值。</p>
<h2 id="二对-json-数据进行反序列化得到java-对象"><a class="header" href="#二对-json-数据进行反序列化得到java-对象">二、对 <code>json</code> 数据进行反序列化，得到<code>java</code> 对象</a></h2>
<h3 id="1不借助java-类直接解析json-数据"><a class="header" href="#1不借助java-类直接解析json-数据">1、不借助<code>java</code> 类，直接解析<code>json</code> 数据</a></h3>
<h4 id="1json-是对象类型"><a class="header" href="#1json-是对象类型">1、<code>json</code> 是对象类型</a></h4>
<p>当ajax传过来的json数据属于对象时，不论这个对象简单还是复杂，都可以轻松地把它们给解析出来。</p>
<p>ajax传过来的json数据（是对象形式）：</p>
<pre><code class="language-javascript">var data_json =  {
        &quot;sex&quot;: '男',
        &quot;hobby&quot;:[&quot;baskte&quot;,&quot;tennis&quot;],
        &quot;introduce&quot;: {
            &quot;name&quot;:&quot;tom&quot;,
            &quot;age&quot;:23
        }
    };

data: JSON.stringify(data_json),
</code></pre>
<p>GSON解析：</p>
<pre><code class="language-java">BufferedReader reader = request.getReader();
    // 读取json数据
    StringBuffer buffer = new StringBuffer();
    String s;
    while ((s = reader.readLine()) != null) {
        buffer.append(s);
    }
    String json = buffer.toString();
    System.out.println(&quot;json:&quot; + json);  

    // json解析器，解析json数据
    JsonParser parser = new JsonParser();
    JsonElement element = parser.parse(json);
    // json属于对象类型时
    if (element.isJsonObject()) {  
        JsonObject object = element.getAsJsonObject();  // 转化为对象

        // 1. value为string时，取出string
        String sex = object.get(&quot;sex&quot;).getAsString();                         System.out.println(&quot;sex:&quot; + sex);

        // 2. value为array时，取出array
        JsonArray hobbies = object.getAsJsonArray(&quot;hobby&quot;);  // 
        for (int i = 0; i &lt; hobbies.size(); i++) {
            String hobby = hobbies.get(i).getAsString();
            System.out.println(&quot;hobby:&quot; + hobby);
        }

        // 3. value为object时，取出object
        JsonObject introduce = object.getAsJsonObject(&quot;introduce&quot;);
        String name = introduce.get(&quot;name&quot;).getAsString();
        int age = introduce.get(&quot;age&quot;).getAsInt();
        System.out.println(&quot;name:&quot; + name+&quot;;age:&quot; + age);
    }
</code></pre>
<p><strong>解读：</strong></p>
<p>很明显，对于传过来的对象类型的json数据，使用GSON是很方便进行解析的，在得到了json数据对应的<code>JsonObject</code> 对象之后，我们就可以很简单地进行操作了。这种方法是直接获取json中的值，而没有进行java对象的还原（简单情况下，没有必要生成相应的javabean）。</p>
<h4 id="2json-是数组类型"><a class="header" href="#2json-是数组类型">2、<code>json</code> 是数组类型</a></h4>
<p>ajax传过来的json数据（是数组形式）：</p>
<pre><code class="language-javascript">var data_json =  [
    &quot;cake&quot;,
    2,
    {&quot;brother&quot;:&quot;tom&quot;,&quot;sister&quot;:&quot;lucy&quot;},
    [&quot;red&quot;,&quot;orange&quot;]
];

data: JSON.stringify(data_json),
</code></pre>
<p>GSON解析：</p>
<pre><code class="language-java">BufferedReader reader = request.getReader();
    StringBuffer buffer = new StringBuffer();
    String s;
    while ((s = reader.readLine()) != null) {
        buffer.append(s);
    }
    String json = buffer.toString();
    System.out.println(&quot;json:&quot;+json);

    // json解析器，解析json数据
    JsonParser parser = new JsonParser();
    JsonElement element = parser.parse(json);
    // json属于数组类型
    if (element.isJsonArray()) {  
        JsonArray array = element.getAsJsonArray();

        // 1. value为string时，取出string
        String array_1 = array.get(0).getAsString();
        System.out.println(&quot;array_1:&quot;+array_1);

        // 2. value为int时，取出int
        int array_2 = array.get(1).getAsInt();
        System.out.println(&quot;array_2:&quot;+array_2);

        // 3. value为object时，取出object
        JsonObject array_3 = array.get(2).getAsJsonObject();
        String brother = array_3.get(&quot;brother&quot;).getAsString();
        String sister = array_3.get(&quot;sister&quot;).getAsString();
        System.out.println(&quot;brother:&quot;+brother+&quot;;sister:&quot;+sister);

        // 4. value为array时，取出array
        JsonArray array_4 = array.get(3).getAsJsonArray();
        for (int i = 0; i &lt; array_4.size(); i++) {
        System.out.println(array_4.get(i).getAsString());
        }

    }
</code></pre>
<p><strong>解读：</strong></p>
<p>当json是数组类型的时候，使用GSON操作和上一小节几乎差不多，只不过是第一步生成的json对象是数组而已。上面2种方式解析json十分简单，在日常使用中足够了。</p>
<p>但是对于有规律的json数据，比如往往是可以映射成一个javabean对象，那么我们就没有必要一个个手工取值了，我们可以借助javabean配合GSON来更加快速地解析json数据。</p>
<h3 id="2借助java-类生成对应java-对象来解析数据"><a class="header" href="#2借助java-类生成对应java-对象来解析数据">2、借助<code>java</code> 类，生成对应<code>java</code> 对象来解析数据</a></h3>
<p>详细的前端<code>json</code> 数据，可以看前面的反例，以下只是使用直接的<code>json</code>数据进行说明。</p>
<p>生成对于的java对象之后，就可以通过getter方法来获取相应的数据了。</p>
<p><strong>通用代码：</strong></p>
<p>在这个方法里，借助json数据来生成java对象的代码都是一致的：</p>
<pre><code class="language-java">Gson gson = new Gson();
BeanType bean = gson.fronJson(jsonData, BeanType.class);
</code></pre>
<h4 id="1-json-是对象类型"><a class="header" href="#1-json-是对象类型">1. <code>json</code> 是对象类型</a></h4>
<h5 id="11-基本案列"><a class="header" href="#11-基本案列">1.1 基本案列</a></h5>
<p><strong><code>json</code> 数据</strong></p>
<pre><code class="language-javascript">{&quot;name&quot;:&quot;tom&quot;,&quot;salary&quot;:2999}
</code></pre>
<p><strong>java类</strong></p>
<pre><code class="language-java">public class MyEntry {
    private String name;
    private int age;
    public String address;
    public int salary;
    // getter、setter、toString
}
</code></pre>
<p><strong><code>java</code> 代码</strong></p>
<pre><code class="language-java">String json1 = &quot;{\&quot;name\&quot;:\&quot;tom\&quot;,\&quot;salary\&quot;:2999}&quot;;
Gson gson1 = new Gson();
MyEntry entry1 = gson1.fromJson(json1, MyEntry.class);
System.out.println(entry1.toString());  // name:tom,age:0,address:null,salary:2999
</code></pre>
<p><strong>解读</strong></p>
<p>可以看出，对于不完整的<code>json</code> 数据，在我们映射了相应的<code>java</code> 类之后，转化得到的java对象，未赋值的字段都是默认值。这就符合java的规范和常理。</p>
<h5 id="12-字段名并不一致怎么办"><a class="header" href="#12-字段名并不一致怎么办">1.2 字段名并不一致怎么办？</a></h5>
<p>如果前端传过来的<code>json</code> 数据的key和我们java类的字段不一致，就需要我们在java类中手工进行指定。</p>
<p><strong><code>@SerializedName()</code> 注解</strong></p>
<p>比如对于上面的<code>json</code> 数据，<code>salary</code> 改成<code>money</code> ，我们得到的java对象中，<code>salary</code> 就会变成默认值：0。</p>
<p>因此，我们要使用注解:</p>
<pre><code class="language-java">@SerializedName(&quot;money&quot;)
private String salary;

@SerializedName({&quot;money&quot;, &quot;salary&quot;})  // 可以有多个备选值
private String salary;
</code></pre>
<h5 id="13-如何限定某个字段不参加序列化或反序列化"><a class="header" href="#13-如何限定某个字段不参加序列化或反序列化">1.3 如何限定某个字段不参加序列化或反序列化？</a></h5>
<p><strong><code>@Expose()注解</code></strong></p>
<p>如果想要让java类的某些字段不参加序列化或反序列化，可以显示来设置。如：</p>
<pre><code class="language-java">@Expose(serialize=false,deserialize=false)
private String name;
</code></pre>
<p>上面的<code>name</code> 字段将不参加序列化及反序列化。</p>
<h5 id="14-复合的对象怎么处理"><a class="header" href="#14-复合的对象怎么处理">1.4 复合的对象怎么处理？</a></h5>
<p>当<code>json</code> 数据是对象形式时，常见的<code>value</code> 会是一个数组或对象。如：</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;tom&quot;,
  &quot;age&quot;: 0,
  &quot;money&quot;: 2999,
  &quot;hobbies&quot;: [
    &quot;basket&quot;,
    &quot;tennis&quot;
  ],
  &quot;collections&quot;: {
    &quot;2&quot;: &quot;paint&quot;,
    &quot;3&quot;: &quot;mouse&quot;
  }
}
</code></pre>
<p>举一反三，<code>value</code> 是数组时（hobbies），对应在java类中也是数组；<code>value</code> 是对象时，对应在java类中就是map（k-v对）了。</p>
<p>因此，我们可以很容易得到对应的java类：</p>
<pre><code class="language-java">private List&lt;String&gt; hobbies;
private Map&lt;Integer, String&gt; collections;
</code></pre>
<p><strong>解读：</strong> 可知，再复杂的<code>json</code> 数据，我们也可以构造出对应的java类。</p>
<h4 id="2-json-是数组类型"><a class="header" href="#2-json-是数组类型">2. <code>json</code> 是数组类型</a></h4>
<h5 id="11-基本案例"><a class="header" href="#11-基本案例">1.1 基本案例：</a></h5>
<p>json数据</p>
<pre><code class="language-json">[&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;]
</code></pre>
<p>显然，数组在java中对应的也是数组。</p>
<p>java代码</p>
<pre><code class="language-java">String json2 = &quot;[\&quot;apple\&quot;, \&quot;pear\&quot;, \&quot;banana\&quot;]&quot;;
Gson gson2 = new Gson();
// 传入的java类型是String[].class
String[] fruits = gson2.fromJson(json2, String[].class);  
</code></pre>
<h5 id="12-我想用list-数组"><a class="header" href="#12-我想用list-数组">1.2 我想用<code>List</code> 数组</a></h5>
<p>对于上面这种简单的数组形式的json数据，我们还可以反序列化为List类型的数组。因为List进行增删改都比较方便。</p>
<p>这里就要使用泛型了，具体的泛型讲解，会在下面进行说明。</p>
<pre><code class="language-java">String json2 = &quot;[\&quot;apple\&quot;, \&quot;pear\&quot;, \&quot;banana\&quot;]&quot;;
Gson gson2 = new Gson();
List&lt;String&gt; fruitList = gson2.fromJson(json2, new TypeToken&lt;List&lt;String&gt;&gt;(){}.getType());
</code></pre>
<h3 id="3使用泛型"><a class="header" href="#3使用泛型">3、使用泛型</a></h3>
<p>有的时候，传过来的json数据在格式上是很相近的，只不过某个字段的value不固定，如果为此生成多个相似的java类就十分多余了。</p>
<p>如：前端传过来的json数据主要是2类：</p>
<pre><code class="language-json">{&quot;code&quot;:&quot;0&quot;,&quot;message&quot;:&quot;success&quot;,&quot;data&quot;:{}}
</code></pre>
<pre><code class="language-json">{&quot;code&quot;:&quot;0&quot;,&quot;message&quot;:&quot;success&quot;,&quot;data&quot;:[]}
</code></pre>
<p>对于字段<code>data</code> ，有时候是对象，有时候是数组。</p>
<p>这里，我们将使用<code>Result&lt;T&gt;</code> 来映射<code>json</code>数据，使用<code>MyEntry</code> 类来映射<code>json</code> 数据的<code>data</code> 部分。这意味着，对于不同的json数据，我们将不再生成多个java类，而是动态生成所需的java对象。</p>
<p>result对象</p>
<pre><code class="language-java">public class Result&lt;T&gt;{
    public int code;
    public String message;
    public T data;
    // getter、setter
}
</code></pre>
<h5 id="11-data为对象的json1"><a class="header" href="#11-data为对象的json1">1.1 data为对象的json1：</a></h5>
<pre><code class="language-json">{
  &quot;code&quot;: 0,
  &quot;message&quot;: &quot;success&quot;,
  &quot;data&quot;: [
    {
      &quot;name&quot;: &quot;tom&quot;,
      &quot;age&quot;: 32,
      &quot;address&quot;: &quot;street one&quot;,
      &quot;salary&quot;: 4999
    },
    {
      &quot;name&quot;: &quot;tom&quot;,
      &quot;age&quot;: 32,
      &quot;address&quot;: &quot;street one&quot;,
      &quot;salary&quot;: 4999
    }
  ]
}
</code></pre>
<p>java代码</p>
<pre><code class="language-java">String typeJson1 = &quot;{\n&quot; +
                        &quot;  \&quot;code\&quot;:0,\n&quot; +
                        &quot;  \&quot;message\&quot;:\&quot;success\&quot;,\n&quot; +
                        &quot;  \&quot;data\&quot;:{\n&quot; +
                        &quot;    \&quot;name\&quot;:\&quot;tom\&quot;,\n&quot; +
                        &quot;    \&quot;age\&quot;:32,\n&quot; +
                        &quot;    \&quot;address\&quot;:\&quot;street one\&quot;,\n&quot; +
                        &quot;    \&quot;salary\&quot;:4999\n&quot; +
                        &quot;  }\n&quot; +
                        &quot;}&quot;;
Gson typeGson1 = new Gson();
// 动态生成所需的java类的类型
Type type1 = new TypeToken&lt;Result&lt;MyEntry&gt;&gt;(){}.getType();
// 动态生成java对象
Result&lt;MyEntry&gt; result1 = typeGson1.fromJson(typeJson1, type1);
System.out.println(result1);
</code></pre>
<h5 id="12-data为数值的json2"><a class="header" href="#12-data为数值的json2">1.2 data为数值的json2：</a></h5>
<pre><code class="language-json">{
  &quot;code&quot;: 0,
  &quot;message&quot;: &quot;success&quot;,
  &quot;data&quot;: [
    {
      &quot;name&quot;: &quot;tom&quot;,
      &quot;age&quot;: 32,
      &quot;address&quot;: &quot;street one&quot;,
      &quot;salary&quot;: 4999
    },
    {
      &quot;name&quot;: &quot;lucy&quot;,
      &quot;age&quot;: 24,
      &quot;address&quot;: &quot;street three&quot;,
      &quot;salary&quot;: 2333
    }
  ]
}
</code></pre>
<p>java代码</p>
<pre><code class="language-java">String typeJson2 = &quot;{\n&quot; +
                        &quot;  \&quot;code\&quot;: 0,\n&quot; +
                        &quot;  \&quot;message\&quot;: \&quot;success\&quot;,\n&quot; +
                        &quot;  \&quot;data\&quot;: [\n&quot; +
                        &quot;    {\n&quot; +
                        &quot;      \&quot;name\&quot;: \&quot;tom\&quot;,\n&quot; +
                        &quot;      \&quot;age\&quot;: 32,\n&quot; +
                        &quot;      \&quot;address\&quot;: \&quot;street one\&quot;,\n&quot; +
                        &quot;      \&quot;salary\&quot;: 4999\n&quot; +
                        &quot;    },\n&quot; +
                        &quot;    {\n&quot; +
                        &quot;      \&quot;name\&quot;: \&quot;lucy\&quot;,\n&quot; +
                        &quot;      \&quot;age\&quot;: 24,\n&quot; +
                        &quot;      \&quot;address\&quot;: \&quot;street three\&quot;,\n&quot; +
                        &quot;      \&quot;salary\&quot;: 2333\n&quot; +
                        &quot;    }\n&quot; +
                        &quot;  ]\n&quot; +
                        &quot;}&quot;;
Gson typeGson2 = new Gson();
// 再次动态生成java类型
Type type2 = new TypeToken&lt;Result&lt;List&lt;MyEntry&gt;&gt;&gt;(){}.getType();
// 再次动态生成java对象
Result&lt;List&lt;MyEntry&gt;&gt; result2 = typeGson2.fromJson(typeJson2, type2);
System.out.println(result2);
</code></pre>
<h2 id="四java-对象序列化为json-数据"><a class="header" href="#四java-对象序列化为json-数据">四、<code>java</code> 对象序列化为<code>json</code> 数据</a></h2>
<p>这一部分，主要是讲解如何将一个java对象序列化为json数据，也会涉及到如何组装这个java对象。</p>
<h3 id="1由具体的java类对象序列化为json-数据"><a class="header" href="#1由具体的java类对象序列化为json-数据">1、由具体的<code>java</code>类对象，序列化为<code>json</code> 数据</a></h3>
<p>我们可以直接把java对象给序列化为json数据。对于未设置的属性，会采取默认值；但是如果默认是null的话，该属性就不会被序列化。</p>
<p>java类，我们仍然采用的是<code>MyEntry</code> 类。</p>
<pre><code class="language-java">MyEntry entry2 = new MyEntry();
entry2.setName(&quot;tom&quot;);
entry2.setSalary(2999);
List&lt;String&gt; hobbies = new ArrayList&lt;&gt;();
hobbies.add(&quot;basket&quot;);
hobbies.add(&quot;tennis&quot;);
entry2.setHobbies(hobbies);
Map&lt;Integer, String&gt; collections = new HashMap&lt;&gt;();
collections.put(2, &quot;paint&quot;);
collections.put(3, &quot;mouse&quot;);
entry2.setCollections(collections);
Gson gson2 = new Gson();
String json2 = gson2.toJson(entry2);
System.out.println(json2);
// {&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:0,&quot;money&quot;:2999,&quot;hobbies&quot;:[&quot;basket&quot;,&quot;tennis&quot;],&quot;collections&quot;:{&quot;2&quot;:&quot;paint&quot;,&quot;3&quot;:&quot;mouse&quot;}}
</code></pre>
<p>对于非值属性，即引用属性，如hobbies、collections，如果没有设置值的话，在序列化后的json数据中，是不会出现的。而如果是值属性的话，没有设置值的情况下，在json数据中会是使用java中的默认值。</p>
<h4 id="11-要生成对象形式的json-数据"><a class="header" href="#11-要生成对象形式的json-数据">1.1 要生成对象形式的<code>json</code> 数据</a></h4>
<ul>
<li>第一种方法是上面的，直接使用java类对象</li>
<li>还可以使用生成map对象，进行序列化</li>
</ul>
<h4 id="12-要生成数组形式的json-数据"><a class="header" href="#12-要生成数组形式的json-数据">1.2 要生成数组形式的<code>json</code> 数据</a></h4>
<ul>
<li>第一种，使用<code>String[]</code> 字符串数组来生成</li>
<li>还可以使用List对象来序列化</li>
<li>还可以使用Set对象来序列化</li>
</ul>
<p>对于序列化的要求，更多的情况会使用注解来选择需要/不需要进行序列化的字段。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="idea自动部署web工程至远程服务器学习笔记"><a class="header" href="#idea自动部署web工程至远程服务器学习笔记"><a href="https://www.cnblogs.com/rmxd/p/11418812.html">IDEA自动部署WEB工程至远程服务器（学习笔记）</a></a></h1>
<p><strong>目录</strong></p>
<ul>
<li>一、部署Web工程的几种方式
<ul>
<li><a href="https://www.cnblogs.com/rmxd/p/11418812.html#_label0_0">①本地打war，上传至远程服务器tomcat容器即可</a></li>
<li><a href="https://www.cnblogs.com/rmxd/p/11418812.html#_label0_1">②IDEA自动部署至远程服务器</a></li>
</ul>
</li>
<li>二、IDEA自动部署至远程服务器
<ul>
<li><a href="https://www.cnblogs.com/rmxd/p/11418812.html#_label1_0">①搭建服务器的tomcat环境</a></li>
<li><a href="https://www.cnblogs.com/rmxd/p/11418812.html#_label1_1">②本地IDEA关联远程服务器</a></li>
<li><a href="https://www.cnblogs.com/rmxd/p/11418812.html#_label1_2">③tomcat配置文件：server.xml</a></li>
</ul>
</li>
</ul>
<hr />
<p><a href="https://www.cnblogs.com/rmxd/p/11418812.html#_labelTop">回到顶部</a></p>
<h2 id="一部署web工程的几种方式"><a class="header" href="#一部署web工程的几种方式">一、部署Web工程的几种方式</a></h2>
<h3 id="①本地打war上传至远程服务器tomcat容器即可"><a class="header" href="#①本地打war上传至远程服务器tomcat容器即可">①本地打war，上传至远程服务器tomcat容器即可</a></h3>
<p>　　优点：简单粗暴</p>
<p>　　缺点：浪费时间</p>
<h3 id="②idea自动部署至远程服务器"><a class="header" href="#②idea自动部署至远程服务器">②IDEA自动部署至远程服务器</a></h3>
<p>　　优点：节省大量时间</p>
<p>　　缺点：配置稍多（第一次）</p>
<p><a href="https://www.cnblogs.com/rmxd/p/11418812.html#_labelTop">回到顶部</a></p>
<h2 id="二idea自动部署至远程服务器"><a class="header" href="#二idea自动部署至远程服务器">二、IDEA自动部署至远程服务器</a></h2>
<h3 id="①搭建服务器的tomcat环境"><a class="header" href="#①搭建服务器的tomcat环境">①搭建服务器的tomcat环境</a></h3>
<h3 id="②本地idea关联远程服务器"><a class="header" href="#②本地idea关联远程服务器">②本地IDEA关联远程服务器</a></h3>
<h4 id="打开idea按如下图配置"><a class="header" href="#打开idea按如下图配置">　　打开IDEA，按如下图配置：</a></h4>
<p>　　<img src="https://img2018.cnblogs.com/blog/1733080/201908/1733080-20190827154341957-102207508.png" alt="img" /></p>
<h4 id="进入配置界面"><a class="header" href="#进入配置界面">　　进入配置界面</a></h4>
<p>　　<img src="https://img2018.cnblogs.com/blog/1733080/201908/1733080-20190827154624002-420957465.png" alt="img" /></p>
<h4 id="继续配置"><a class="header" href="#继续配置">　　继续配置</a></h4>
<p>　　<img src="https://img2018.cnblogs.com/blog/1733080/201908/1733080-20190827154838952-1500441985.png" alt="img" /></p>
<p>　　上传本地工程包：<strong>这样，我们在本地修改某个java文件，直接提交该class即可，无需打war上传等繁琐的过程。</strong></p>
<p>　　<img src="https://img2018.cnblogs.com/blog/1733080/201908/1733080-20190827155216301-728389791.png" alt="img" /></p>
<h3 id="③tomcat配置文件serverxml"><a class="header" href="#③tomcat配置文件serverxml">③tomcat配置文件：server.xml</a></h3>
<p><a href="https://www.cnblogs.com/rmxd/p/11419193.html">Tomcat部署Web项目的3种方式</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jsr303实现参数效验"><a class="header" href="#jsr303实现参数效验">JSR303实现参数效验</a></h1>
<h2 id="0x01-导入依赖"><a class="header" href="#0x01-导入依赖">0x01 导入依赖</a></h2>
<pre><code class="language-xml">&lt;!--  jsr303  --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="0x02-使用注解"><a class="header" href="#0x02-使用注解">0x02 使用注解</a></h2>
<pre><code class="language-java">//一定要是这个注解 `javax.validation.constraints`
import javax.validation.constraints.NotNull;

@Data
@AllArgsConstructor
@NoArgsConstructor
@ToString
public class UserVo {

  private String name;

  private String password;

  @NotNull(message = &quot;numble不能为空&quot;)
  private String numble;

}
</code></pre>
<pre><code class="language-java">@RequestMapping(&quot;/test&quot;)
@ResponseBody
//使用 @valid 注解开启参数验证（重要！！！！！！！！！）
public String test(@Valid @RequestBody UserVo user){
	System.out.println(user.toString());
    return &quot;success&quot;;
  }
</code></pre>
<p>=&gt; POST <code>127.0.0.1:8183/test</code> <code>{&quot;name&quot;:&quot;hqqich&quot;,&quot;password&quot;:&quot;pass123&quot;}</code></p>
<p>&lt;= <code>Resolved [org.springframework.web.bind.MethodArgumentNotValidException: Validation failed for argument [0] in public java.lang.String com.example.miaosha.controller.DeomController.test(com.example.miaosha.vo.UserVo): [Field error in object 'userVo' on field 'numble': rejected value [null]; codes [NotNull.userVo.numble,NotNull.numble,NotNull.java.lang.String,NotNull]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [userVo.numble,numble]; arguments []; default message [numble]]; default message [numble不能为空]] ]</code></p>
<p>=&gt; POST  <code>127.0.0.1:8183/test</code> <code>{&quot;name&quot;:&quot;hqqich&quot;,&quot;numble&quot;:&quot;123&quot;}</code></p>
<p>&lt;= <code>success</code></p>
<h2 id="0x03-自定义注解以判断手机号码是否正确"><a class="header" href="#0x03-自定义注解以判断手机号码是否正确">0x03 自定义注解（以判断手机号码是否正确）</a></h2>
<ul>
<li>
<p>新建注解<code>IsMobile.java</code></p>
<pre><code class="language-java">import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import javax.validation.Constraint;
import javax.validation.Payload;

@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
//这里填的是待会要创建的自定义判断器
@Constraint(
    validatedBy = {IsMobileValidator.class}
)
public @interface IsMobile {

  //默认为true, 表示启用注解，
  boolean requirde() default true;

  //异常时的提示信息
  String message() default &quot;手机号码格式错误&quot;;

  Class&lt;?&gt;[] groups() default {};
  Class&lt;? extends Payload&gt;[] payload() default {};
}
</code></pre>
</li>
<li>
<p>新建判断器<code>IsMobileValidator.java</code>继承自<code>ConstraintValidator&lt;IsMobile, String&gt;</code>泛型指向 刚创建的注解，<font color="#ff0000">两两相互连接</font></p>
<pre><code class="language-java">import com.example.miaosha.util.ValidatorUtil;
import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
import org.springframework.util.StringUtils;

public class IsMobileValidator implements ConstraintValidator&lt;IsMobile, String&gt; {

  private boolean requirde;

  @Override
  public void initialize(IsMobile constraintAnnotation) {
    requirde = constraintAnnotation.requirde();
  }

  @Override
  public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) {

    if (requirde){
      return ValidatorUtil.isMobile(s);
    }else {
      if (StringUtils.isEmpty(s)){
        return true;
      }else {
        return ValidatorUtil.isMobile(s);
      }
    }
  }
}
</code></pre>
</li>
<li>
<p>新建工具类<code>ValidatorUtil.java</code></p>
<pre><code class="language-java">public class ValidatorUtil {
  /**
   * 判定字符串是否是号码
   * @param numble
   * @return
   */
  public static boolean isMobile(String numble){
    String regex = &quot;^((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(18[0,5-9]))\\d{8}$&quot;;
    return Pattern.matches(regex, numble);
  }
}
</code></pre>
</li>
<li>
<p>测试</p>
<pre><code class="language-java">//一定要是这个注解 `javax.validation.constraints`
import javax.validation.constraints.NotNull;
//导入自定义注解
import com.example.miaosha.validator.IsMobile;

@Data
@AllArgsConstructor
@NoArgsConstructor
@ToString
public class UserVo {

  private String name;

  private String password;

  @NotNull(message = &quot;numble不能为空&quot;)
  @IsMobile
  private String numble;

}
</code></pre>
<p>当请求中numble字段不是手机号码时，出现异常</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="js简单实现多级select联动菜单效果代码"><a class="header" href="#js简单实现多级select联动菜单效果代码">JS简单实现多级Select联动菜单效果代码</a></h1>
<p>更新时间：2015年09月06日 09:39:45  作者：企鹅</p>
<p>这篇文章主要介绍了JS简单实现多级Select联动菜单效果代码,涉及JavaScript数组元素的遍历及动态设置select的实现技巧,需要的朋友可以参考下</p>
<p>本文实例讲述了JS简单实现多级Select联动菜单效果代码。分享给大家供大家参考。具体如下：</p>
<p>JS联动菜单，简单代码实现JS多级Select联动菜单，也就是大家常用的一款菜单，Select联动状态的菜单，网页上经常见到的效果，希望大家能用得上。</p>
<p>运行效果截图如下：</p>
<p><img src="https://img.jbzj.com/file_images/article/201509/20159694932770.jpg?20158694953" alt="img" /></p>
<p>在线演示地址如下：</p>
<p>http://demo.jb51.net/js/2015/js-simple-select-ld-menu-codes/</p>
<p>具体代码如下：</p>
<pre><code class="language-html">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;JS联动下拉框&lt;/title&gt;
&lt;script language=&quot;javascript&quot; &gt;
/* 
** ====================================
** 类名：CLASS_LIANDONG_YAO 
** 功能：多级连动菜单 
** 作者：YAODAYIZI 
**/  
 function CLASS_LIANDONG_YAO(array)
 {
 //数组，联动的数据源
  this.array=array; 
  this.indexName='';
  this.obj='';
  //设置子SELECT
 // 参数：当前onchange的SELECT ID，要设置的SELECT ID
 this.subSelectChange=function(selectName1,selectName2)
  {
  //try
  //{
 var obj1=document.all[selectName1];
 var obj2=document.all[selectName2];
 var objName=this.toString();
 var me=this;
 obj1.onchange=function()
 {
  me.optionChange(this.options[this.selectedIndex].value,obj2.id)
 }
  }
  //设置第一个SELECT
 // 参数：indexName指选中项,selectName指select的ID
  this.firstSelectChange=function(indexName,selectName) 
  {
  this.obj=document.all[selectName];
  this.indexName=indexName;
  this.optionChange(this.indexName,this.obj.id)
  }
 // indexName指选中项,selectName指select的ID
  this.optionChange=function (indexName,selectName)
  {
 var obj1=document.all[selectName];
 var me=this;
 obj1.length=0;
 obj1.options[0]=new Option(&quot;请选择&quot;,'');
 for(var i=0;i&lt;this.array.length;i++)
 { 
  if(this.array[i][1]==indexName)
  {
  //alert(this.array[i][1]+&quot; &quot;+indexName);
 obj1.options[obj1.length]=new Option(this.array[i][2],this.array[i][0]);
  }
 }
  } 
 }
 &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form name=&quot;form1&quot; method=&quot;post&quot;&gt;
  &amp;nbsp;
  &lt;SELECT ID=&quot;s1&quot; NAME=&quot;s1&quot; &gt;
 &lt;OPTION selected&gt;&lt;/OPTION&gt;
  &lt;/SELECT&gt;
  &lt;SELECT ID=&quot;s2&quot; NAME=&quot;s2&quot; &gt;
 &lt;OPTION selected&gt;&lt;/OPTION&gt;
  &lt;/SELECT&gt;
  &lt;SELECT ID=&quot;s3&quot; NAME=&quot;s3&quot;&gt;
 &lt;OPTION selected&gt;&lt;/OPTION&gt;
  &lt;/SELECT&gt;
  &lt;br&gt;
  &lt;br&gt;&lt;br&gt;
  &lt;SELECT ID=&quot;x1&quot; NAME=&quot;x1&quot; &gt;
 &lt;OPTION selected&gt;&lt;/OPTION&gt;
  &lt;/SELECT&gt;
  &lt;SELECT ID=&quot;x2&quot; NAME=&quot;x2&quot; &gt;
 &lt;OPTION selected&gt;&lt;/OPTION&gt;
  &lt;/SELECT&gt;
  &lt;SELECT ID=&quot;x3&quot; NAME=&quot;x3&quot;&gt;
 &lt;OPTION selected&gt;&lt;/OPTION&gt;
  &lt;/SELECT&gt;
  &lt;SELECT ID=&quot;x4&quot; NAME=&quot;x4&quot;&gt;
 &lt;OPTION selected&gt;&lt;/OPTION&gt;
  &lt;/SELECT&gt;
  &lt;SELECT ID=&quot;x5&quot; NAME=&quot;x5&quot;&gt;
 &lt;OPTION selected&gt;&lt;/OPTION&gt;
  &lt;/SELECT&gt;
 &lt;/form&gt;
 &lt;/body&gt;
&lt;script language=&quot;javascript&quot;&gt;
//例子1-------------------------------------------------------------
//数据源
var array=new Array();
 array[0]=new Array(&quot;华南地区&quot;,&quot;根目录&quot;,&quot;华南地区&quot;); //数据格式 ID，父级ID，名称
 array[1]=new Array(&quot;华北地区&quot;,&quot;根目录&quot;,&quot;华北地区&quot;);
 array[2]=new Array(&quot;上海&quot;,&quot;华南地区&quot;,&quot;上海&quot;);
 array[3]=new Array(&quot;广东&quot;,&quot;华南地区&quot;,&quot;广东&quot;);
 array[4]=new Array(&quot;徐家汇&quot;,&quot;上海&quot;,&quot;徐家汇&quot;);
 array[5]=new Array(&quot;普托&quot;,&quot;上海&quot;,&quot;普托&quot;); 
 array[6]=new Array(&quot;广州&quot;,&quot;广东&quot;,&quot;广州&quot;);
 array[7]=new Array(&quot;湛江&quot;,&quot;广东&quot;,&quot;湛江&quot;);
 //--------------------------------------------
 //这是调用代码
 var liandong=new CLASS_LIANDONG_YAO(array) //设置数据源
 liandong.firstSelectChange(&quot;根目录&quot;,&quot;s1&quot;); //设置第一个选择框
 liandong.subSelectChange(&quot;s1&quot;,&quot;s2&quot;); //设置子级选择框
 liandong.subSelectChange(&quot;s2&quot;,&quot;s3&quot;);
 //例子2-------------------------------------------------------------
 //数据源 
 var array2=new Array();//数据格式 ID，父级ID，名称
 array2[0]=new Array(&quot;测试测试&quot;,&quot;根目录&quot;,&quot;测试测试&quot;); 
 array2[1]=new Array(&quot;华北地区&quot;,&quot;根目录&quot;,&quot;华北地区&quot;);
 array2[2]=new Array(&quot;上海&quot;,&quot;测试测试&quot;,&quot;上海&quot;);
 array2[3]=new Array(&quot;广东&quot;,&quot;测试测试&quot;,&quot;广东&quot;);
 array2[4]=new Array(&quot;徐家汇&quot;,&quot;上海&quot;,&quot;徐家汇&quot;);
 array2[5]=new Array(&quot;普托&quot;,&quot;上海&quot;,&quot;普托&quot;); 
 array2[6]=new Array(&quot;广州&quot;,&quot;广东&quot;,&quot;广州&quot;);
 array2[7]=new Array(&quot;湛江&quot;,&quot;广东&quot;,&quot;湛江&quot;);
 array2[8]=new Array(&quot;不知道&quot;,&quot;湛江&quot;,&quot;不知道&quot;);
 array2[9]=new Array(&quot;5555&quot;,&quot;湛江&quot;,&quot;555&quot;);
 array2[10]=new Array(&quot;++++&quot;,&quot;不知道&quot;,&quot;++++&quot;);
 array2[11]=new Array(&quot;111&quot;,&quot;徐家汇&quot;,&quot;111&quot;);
 array2[12]=new Array(&quot;222&quot;,&quot;111&quot;,&quot;222&quot;);
 array2[13]=new Array(&quot;333&quot;,&quot;222&quot;,&quot;333&quot;);
 //--------------------------------------------
 //这是调用代码
 //设置数据源
 var liandong2=new CLASS_LIANDONG_YAO(array2);
 //设置第一个选择框
 liandong2.firstSelectChange(&quot;根目录&quot;,&quot;x1&quot;);
 //设置子选择框
 liandong2.subSelectChange(&quot;x1&quot;,&quot;x2&quot;)
 liandong2.subSelectChange(&quot;x2&quot;,&quot;x3&quot;)
 liandong2.subSelectChange(&quot;x3&quot;,&quot;x4&quot;)
 liandong2.subSelectChange(&quot;x4&quot;,&quot;x5&quot;)
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>希望本文所述对大家的JavaScript程序设计有所帮助。</p>
<p><strong>您可能感兴趣的文章:</strong></p>
<ul>
<li><a href="https://www.jb51.net/article/9790.htm">JS实多级联动下拉菜单类，简单实现省市区联动菜单！</a></li>
<li><a href="https://www.jb51.net/article/73852.htm">jsp从数据库获取数据填充下拉框实现二级联动菜单的方法</a></li>
<li><a href="https://www.jb51.net/article/71250.htm">js实现简单的联动菜单效果</a></li>
<li><a href="https://www.jb51.net/article/78126.htm">实例详解AngularJS实现无限级联动菜单</a></li>
<li><a href="https://www.jb51.net/article/44836.htm">从QQ网站中提取的纯JS省市区三级联动菜单</a></li>
<li><a href="https://www.jb51.net/article/80421.htm">基于Javascript实现二级联动菜单效果</a></li>
<li><a href="https://www.jb51.net/article/106525.htm">JS实现的五级联动菜单效果完整实例</a></li>
<li><a href="https://www.jb51.net/article/121289.htm">JavaScript实现三级联动菜单效果</a></li>
<li><a href="https://www.jb51.net/article/79954.htm">PHP+JS三级菜单联动菜单实现方法</a></li>
<li><a href="https://www.jb51.net/article/177941.htm">JavaScript实现联动菜单特效</a></li>
</ul>
<h1 id="2"><a class="header" href="#2">2.</a></h1>
<p>html写的三个下拉框，如下：</p>
<pre><code> &lt;select name=&quot;ddlQYWZYJ&quot; id=&quot;ddl_QYWZYJ&quot; class=&quot;fieldsel&quot; style=&quot;width: 200px;font-size:12px&quot;  &gt;&lt;/select&gt;
 &lt;select name=&quot;ddlQYWZEJ&quot; id=&quot;ddl_QYWZEJ&quot; class=&quot;fieldsel&quot; style=&quot;width: 200px;font-size:12px&quot;&gt;&lt;/select&gt;
 &lt;select name=&quot;ddlQYWZSJ&quot; id=&quot;ddl_QYWZSJ&quot; class=&quot;fieldsel&quot; style=&quot;width: 200px;font-size:12px&quot;&gt;&lt;/select&gt;
</code></pre>
<p><strong>要求1：加载页面时初始化一级下拉框，当一级下拉框点击取值后加载二级下拉框，点击二级下拉框后加载三级下拉框；</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></p>
<pre><code>$(document).ready(function () {
            //一级单位的下拉显示框
        $.getJSON(rootPath + 'Dictionary/GetDicDataForSelect?idfield=ID&amp;textfield=VALUE&amp;' + &quot;where=&quot; + JSON2.stringify({
                op: 'and',
                rules: [{ field: 'PARENTID', value: 1, op: 'equal' }]
            }), function (json) {
                var lst = eval(json);
                for (i = 0; i &lt; lst.length; i++) {
                    var tname = lst[i].text;
                    var tid = lst[i].id;
                    $(&quot;#ddl_QYWZYJ&quot;).append(&quot;&lt;option value='&quot; + tid + &quot;'&gt;&quot; + tname + &quot;&lt;/option&gt;&quot;);
                }
            });
            $(&quot;#ddl_QYWZYJ&quot;).click(function () {
                GetQYWZYJData();
            });
            $(&quot;#ddl_QYWZEJ&quot;).click(function () {
                GetQYMSData();
            })
        })
          

         @* 一级下拉框值改变时触发加载二级下拉框*@
        function GetQYWZYJData() {
            var QYWZYJvalue = $('#ddl_QYWZYJ option:selected').val();//选中的文本
            $.getJSON(rootPath + 'Dictionary/GetDicDataForSelect?idfield=ID&amp;textfield=VALUE&amp;' + &quot;where=&quot; + JSON2.stringify({
                op: 'and',
                rules: [{ field: 'PARENTID', value: QYWZYJvalue, op: 'equal' }]
             }), function (json) {
                 $(&quot;#ddl_QYWZEJ&quot;).html(&quot;&quot;);//清空下拉框  
                 $(&quot;#txt_QYMS&quot;).html(&quot;&quot;);//清空区域描述
                var lst = eval(json);
                 for (var i = 0; i &lt; lst.length; i++) {
                     $(&quot;#ddl_QYWZEJ&quot;).append(&quot;&lt;option value='&quot; + lst[i].id + &quot;'&gt;&quot; + lst[i].name + &quot;&lt;/option&gt;&quot;);
                 }
            })
        }


        @* 二级下拉框值改变时触发加载三级下拉框*@
        function GetQYMSData() {
            var QYWZEJvalue = $('#ddl_QYWZEJ option:selected').val();//选中的文本
            if (QYWZEJvalue == null) return;
            $.getJSON(rootPath + 'Dictionary/GetDicDataForSelect?idfield=ID&amp;textfield=VALUE&amp;' + &quot;where=&quot; + JSON2.stringify({
                op: 'and',
                rules: [{ field: 'ID', value: QYWZEJvalue, op: 'equal' }]
            }), function (json) {
                $(&quot;#ddl_QYWZSJ&quot;).html(&quot;&quot;);
                var lst = eval(json);             
                for (var i = 0; i &lt; lst.length; i++) {
                    $(&quot;#ddl_QYWZSJ&quot;).append(&quot;&lt;option value='&quot; + lst[i].id + &quot;'&gt;&quot; + lst[i].name + &quot;&lt;/option&gt;&quot;);
                }
            }) 
        }
</code></pre>
<h1 id="3"><a class="header" href="#3">3.</a></h1>
<h2 id="1使用标签"><a class="header" href="#1使用标签">1.使用<select>标签</a></h2>
<p>优点：可以初始化选中项</p>
<p>缺点：不能自定义option的样式，自带的样式很丑</p>
<p>效果图：</p>
<p><img src="https://img2020.cnblogs.com/blog/1399488/202003/1399488-20200306124715599-1254331518.gif" alt="img" /></p>
<p>代码如下：</p>
<pre><code>&lt;select id=&quot;group&quot; value=&quot;1&quot;&gt;
    &lt;option value=&quot;1&quot;&gt;Dimond&lt;/option&gt;
    &lt;option value=&quot;2&quot;&gt;vertical&lt;/option&gt;
&lt;/select&gt;
</code></pre>
<h2 id="2使用标签"><a class="header" href="#2使用标签">2.使用<input>标签</a></h2>
<p>为input标签添加list属性，下拉选项包含在<datalist>标签中，list的值为<datalist>的id</p>
<p>优点：选项框可以手动输入</p>
<p>缺点：没有value，不适合键值对应关系的输入。且当input中有值时选项框只显示对应选项。</p>
<p>效果图：</p>
<p><img src="https://img2020.cnblogs.com/blog/1399488/202003/1399488-20200306123726564-462919893.gif" alt="img" /></p>
<p>代码如下：</p>
<pre><code>&lt;input id=&quot;type&quot; type=&quot;text&quot; list=&quot;typelist&quot; placeholder=&quot;请选择&quot;&gt;
&lt;datalist id=&quot;typelist&quot;&gt;
　　&lt;option&gt;Dimond&lt;/option&gt;
　　&lt;option&gt;vertical&lt;/option&gt;
&lt;/datalist&gt;
</code></pre>
<h2 id="3使用模拟select功能"><a class="header" href="#3使用模拟select功能">3.使用<div>模拟select功能</a></h2>
<p>优点：和select实现的功能完全相同，且可以自定义option样式。</p>
<p>缺点：制作方式麻烦。</p>
<h1 id="4"><a class="header" href="#4">4.</a></h1>
<h1 id="html实现下拉框switch开关复选框效果"><a class="header" href="#html实现下拉框switch开关复选框效果"><a href="https://www.cnblogs.com/cyfeng/p/13074162.html">html实现下拉框、switch开关、复选框效果</a></a></h1>
<p>1、下拉框，效果如下图所示：</p>
<p><img src="https://img2020.cnblogs.com/blog/1726954/202006/1726954-20200609170811224-1107265496.gif" alt="img" /></p>
<p>代码：</p>
<pre><code class="language-php+HTML">&lt;style&gt;
    .selectBox {
      width: 90px;
      margin: 50px;
    }
 
    .select {
      width: 90px;
      background-color: #17a6b5;
      height: 40px;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
      border-radius: 3px;
    }
 
    .select img {
      width: 20px;
      cursor: pointer;
      transition: all 0.5s;
    }
 
    .selectOption {
      background-color: #666666;
      width: 90px;
      list-style: none;
      padding-left: 0;
      margin-top: 0;
      display: none;
    }
 
    .selectOption li {
      width: 100%;
      color: #ffffff;
      text-align: center;
      cursor: pointer;
    }
 
    .selectOption li:hover {
      background-color: #17a6b5;
    }
  &lt;/style&gt;
</code></pre>
<pre><code class="language-html">&lt;body&gt;
  &lt;div class=&quot;selectBox&quot;&gt;
    &lt;div class=&quot;select&quot;&gt;
      &lt;span class=&quot;selectText&quot;&gt;北京&lt;/span&gt;
    &lt;/div&gt;
    &lt;ul class=&quot;selectOption&quot;&gt;
      &lt;li class=&quot;selectOption1&quot;&gt;北京&lt;/li&gt;
      &lt;li class=&quot;selectOption2&quot;&gt;上海&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
  &lt;script&gt;
    var selectBox = document.getElementsByClassName('selectBox')[0]
    var Select = document.getElementsByClassName('select')[0]
    var selectText = document.getElementsByClassName('selectText')[0]
    var option = document.getElementsByClassName('selectOption')[0]
    var option1 = document.getElementsByClassName('selectOption1')[0]
    var option2 = document.getElementsByClassName('selectOption2')[0]
    // 点击select
    Select.onclick = function () {
      option.style.display = 'block'
    }
    // 鼠标移除
    selectBox.onmouseleave = function () {
      option.style.display = 'none'
    }
    option1.onclick = function () {
      option.style.display = 'none'
      selectText.innerHTML = '北京'
    }
    option2.onclick = function () {
      option.style.display = 'none'
      selectText.innerHTML = '上海'
    }
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>2、switch开关，效果如下图所示：</p>
<p><img src="https://img2020.cnblogs.com/blog/1726954/202006/1726954-20200609173108658-83769277.gif" alt="img" /></p>
<p>代码：</p>
<pre><code class="language-html">&lt;style&gt;
    .switch-container {
      height: 25px;
      width: 48px;
      margin: 50px;
      display: inline-block;
      overflow: hidden;
    }
 
    .switch-container input {
      display: none;
    }
 
    .switch-container label {
      display: block;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.25);
      cursor: pointer;
      border-radius: 25px;
      transition: all 0.4s ease;
    }
 
    .switch-container label:before {
      content: '';
      display: block;
      border-radius: 25px;
      height: 21px;
      width: 21px;
      box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.08);
      transition: all 0.4s ease;
      background-color: #fff;
      position: relative;
      right: -2px;
      top: 2px;
    }
 
    .switch-container input:checked~label:before {
      right: -25px;
      background-color: rgba(31, 255, 255, 1);
    }
 
    /* .switch-container input:checked~label {
      background-color: #1890ff;
    } */
  &lt;/style&gt;
</code></pre>
<pre><code class="language-html">&lt;body&gt;
  &lt;div class=&quot;switch-container&quot;&gt;
    &lt;input type=&quot;checkbox&quot; id=&quot;user-switch&quot; /&gt;
    &lt;label for=&quot;user-switch&quot;&gt;&lt;/label&gt;
  &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>2、复选框，效果如下图所示：</p>
<p><img src="https://img2020.cnblogs.com/blog/1726954/202006/1726954-20200609173633686-689418429.gif" alt="img" /></p>
<p>代码：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
 
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot; /&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;style&gt;
    .check {
      display: inline-block;
      cursor: pointer;
      margin: 50px;
    }
 
    .check input {
      display: inline-block;
      width: 14px;
      height: 14px;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      outline: none;
      background: url(./images_select_bgs.png) no-repeat center center;
      background-size: 100% 100%;
      cursor: pointer;
      vertical-align: middle;
      margin-top: -3px;
    }
 
    .check input:checked {
      position: relative;
      background: url(./images_select_duihaos.png) no-repeat center center;
      background-size: 100% 100%;
    }
  &lt;/style&gt;
&lt;/head&gt;
 
&lt;body&gt;
  &lt;label class=&quot;check&quot;&gt; &lt;input type=&quot;checkbox&quot; /&gt;复选框 &lt;/label&gt;
&lt;/body&gt;
 
&lt;/html&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jxl常用解析详解"><a class="header" href="#jxl常用解析详解"><a href="https://www.cnblogs.com/dgwblog/p/9368700.html">JXl常用解析详解</a></a></h1>
<h2 id="目的"><a class="header" href="#目的">目的：<a href="https://www.cnblogs.com/dgwblog/p/9368700.html#497802188">#</a></a></h2>
<p>java解析 excel 无非就是apache poi 或者 jxl 两者在使用上其实都差不多，关键还是看你自己熟悉那个，用那个！我也是初次接触jxl 看很多博客说 jxl只适用于处理小数据量 excel，或者说是功能比较单一的，实际上我看了jxl的包，发现其实用</p>
<p>好了，功能还是很强大的。</p>
<p>需要了解：支持 Reads data from Excel 95, 97, 2000, XP, and 2003 workbooks</p>
<p>jxl.read.biff.BiffException: Unable to recognize OLE stream 出现这个错误就是excel 2007格式不符合引起的</p>
<p>官网：http://jexcelapi.sourceforge.net/</p>
<h3 id="java-doc-httpjxlsourceforgenetjavadocindexhtml"><a class="header" href="#java-doc-httpjxlsourceforgenetjavadocindexhtml">java doc： http://jxl.sourceforge.net/javadoc/index.html<a href="https://www.cnblogs.com/dgwblog/p/9368700.html#3520480942">#</a></a></h3>
<h3 id="依赖管理"><a class="header" href="#依赖管理">依赖管理：<a href="https://www.cnblogs.com/dgwblog/p/9368700.html#790923869">#</a></a></h3>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;net.sourceforge.jexcelapi&lt;/groupId&gt;
    &lt;artifactId&gt;jxl&lt;/artifactId&gt;
    &lt;version&gt;2.6.12&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>UML大纲：</p>
<p><a href="https://images2018.cnblogs.com/blog/1160484/201807/1160484-20180725212957777-1356266150.png"><img src="https://images2018.cnblogs.com/blog/1160484/201807/1160484-20180725212957777-1356266150.png" alt="img" /></a></p>
<h2 id="创建简单的excel"><a class="header" href="#创建简单的excel">创建简单的excel：<a href="https://www.cnblogs.com/dgwblog/p/9368700.html#1763040436">#</a></a></h2>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></p>
<pre><code> 1 @Test
 2     public void testCreateExcel() {
 3         try {
 4             // 创建xls文件
 5             file.createNewFile();
 6             // 2:创建工作簿
 7             WritableWorkbook workbook = Workbook.createWorkbook(file);
 8 
 9             // 3:创建sheet,设置第二三四..个sheet，依次类推即可
10             WritableSheet sheet = workbook.createSheet(&quot;测试&quot;, 0);
11             // 4：设置titles
12             String[] titles = { &quot;编号&quot;, &quot;账号&quot;};
13             // 5:给第一行设置列名
14             for (int i = 0; i &lt; titles.length; i++) {
15                 sheet.addCell(new Label(i, 0, titles[i]));
16             }
17             sheet.setHeader(&quot;aa&quot;, &quot;cc&quot;, &quot;cc&quot;);
18             // 6：模拟数据库导入数据 注意起始行为1
19             for (int i = 1; i &lt; 100; i++) {
20                 //添加编号
21                 sheet.addCell(new Label(0, i, new String(&quot;编号&quot;+i)));
22                 //添加密码
23                 sheet.addCell(new Label(1, i, new String(&quot;编号&quot;+i)));
24             }
25             workbook.write();
26             workbook.close();
27         } catch (IOException e) {
28             e.printStackTrace();
29         } catch (RowsExceededException e) {
30             e.printStackTrace();
31         } catch (WriteException e) {
32             e.printStackTrace();
33         }
34     }
</code></pre>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></p>
<p>效果：</p>
<p><a href="https://images2018.cnblogs.com/blog/1160484/201807/1160484-20180725214909558-409499633.gif"><img src="https://images2018.cnblogs.com/blog/1160484/201807/1160484-20180725214909558-409499633.gif" alt="img" /></a></p>
<h3 id="-1"><a class="header" href="#-1"><a href="https://www.cnblogs.com/dgwblog/p/9368700.html#1046849356">#</a></a></h3>
<h2 id="简单读取excel"><a class="header" href="#简单读取excel">简单读取Excel：<a href="https://www.cnblogs.com/dgwblog/p/9368700.html#2098522692">#</a></a></h2>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></p>
<pre><code> 1 @Test
 2     public void testCreateExcel() {
 3         try {
 4             //1:创建workbook
 5             Workbook workbook = Workbook.getWorkbook(file);
 6             //2:获取第一个工作表sheet
 7             Sheet sheet = workbook.getSheet(0);
 8              //3:读取数据
 9             System.out.println(sheet.getColumns());
10             System.out.println(sheet.getRows());
11             //4.自己注意行列关系
12             for (int i = 0; i &lt; sheet.getRows(); i++) {
13                 for (int j = 0; j &lt; sheet.getColumns(); j++) {
14                     Cell cell = sheet.getCell(j, i);
15                     System.out.println(cell.getContents());
16                 }
17             }
18         } catch (BiffException | IOException e) {
19             e.printStackTrace();
20         }
21     }
</code></pre>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></p>
<p><a href="https://images2018.cnblogs.com/blog/1160484/201807/1160484-20180725220429111-1280536109.gif"><img src="https://images2018.cnblogs.com/blog/1160484/201807/1160484-20180725220429111-1280536109.gif" alt="img" /></a></p>
<hr />
<pre><code>感谢您的阅读，如果您觉得阅读本文对您有帮助，请点一下“推荐”按钮。本文欢迎各位转载，但是转载文章之后必须在文章页面中给出作者和原文连接。
</code></pre>
<p>作者： ---dgw博客</p>
<p>出处：https://www.cnblogs.com/dgwblog/p/9368700.html</p>
<p>版权：本文采用「<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a>」知识共享许可协议进行许可。</p>
<p>分类: <a href="https://www.cnblogs.com/dgwblog/category/1194464.html">Java</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java8获取参数名称"><a class="header" href="#java8获取参数名称">Java8获取参数名称</a></h1>
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p>在mybatis的源码学习中，知道了mybatis可以开始在Java8将参数名称作为映射名称，Java8一项新的特性——在class文件中保留参数名。</p>
<blockquote>
<ol>
<li>
<p>File-&gt;Settings-&gt;Build,Execution,Deployment-&gt;Compiler-&gt;Java Compiler</p>
</li>
<li>
<p>在 Additional command line parameters: 后面填上 -parameters，</p>
</li>
</ol>
</blockquote>
<h2 id="通过反射获取参数名称"><a class="header" href="#通过反射获取参数名称">通过反射获取参数名称</a></h2>
<p>Java8中反射包出现了新的方法，Method.getParameters()，可以获取Parameter数组。而以前只能使用Method.getParameterTypes()获取Class数组。</p>
<pre><code class="language-java">package org.example.proxy.dynamic;

import java.lang.reflect.Method;
import java.lang.reflect.Parameter;

public class TestMethodParams {
  public String test(String name, int age) {
    return name;
  }
  public static void main(String[] args) throws NoSuchMethodException, SecurityException {
    Method method = TestMethodParams.class.getMethod(&quot;test&quot;,String.class,int.class);
    for (Parameter p : method.getParameters()) {
      System.out.println(&quot;parameter: &quot; + p.getType().getName() + &quot;, &quot; + p.getName());
    }
  }
}
</code></pre>
<p>如果我们不做其他设置，我们可以得到以下结果</p>
<p>parameter: java.lang.String, arg0
parameter: int, arg1
1
2
这是因为Java8必须得打开编译开关才能使用，打开之后结果如下：</p>
<h2 id="parameter-javalangstring-name-parameter-int-age-javac编译器"><a class="header" href="#parameter-javalangstring-name-parameter-int-age-javac编译器">parameter: java.lang.String, name parameter: int, age javac编译器</a></h2>
<p>使用原生编译器javac，直接使用javac <code>-parameters</code> ***.java,得到的class文件将保留参数名称。</p>
<h2 id="eclipse"><a class="header" href="#eclipse">Eclipse</a></h2>
<p>Window-&gt;Preferencces-&gt;Java-&gt;Compiler 然后勾选红框选中值</p>
<p><img src="https://img-blog.csdn.net/20180719225600503?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RpZWh1YW5nMzQyNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" /></p>
<h2 id="idea"><a class="header" href="#idea">Idea</a></h2>
<p>File-&gt;Setting</p>
<p><img src="https://img-blog.csdn.net/20180719225700485?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RpZWh1YW5nMzQyNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" /></p>
<p>Build,Execution,Deployment-&gt;Java Compiler 在框内填写-parameters参数</p>
<p><img src="https://img-blog.csdn.net/20180719225827433?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RpZWh1YW5nMzQyNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" /></p>
<h2 id="maven-在pomxml的中添加编译插件"><a class="header" href="#maven-在pomxml的中添加编译插件">Maven 在pom.xml的中添加编译插件</a></h2>
<pre><code class="language-xml">&lt;!--        &lt;plugin&gt;--&gt;
&lt;!--          &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;--&gt;
&lt;!--          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;--&gt;
&lt;!--          &lt;version&gt;3.3&lt;/version&gt;--&gt;
&lt;!--          &lt;configuration&gt;--&gt;
&lt;!--            &lt;source&gt;1.8&lt;/source&gt;--&gt;
&lt;!--            &lt;target&gt;1.8&lt;/target&gt;--&gt;
&lt;!--            &lt;compilerArgs&gt;--&gt;
&lt;!--              &lt;arg&gt;-parameters&lt;/arg&gt;--&gt;
&lt;!--            &lt;/compilerArgs&gt;--&gt;
&lt;!--          &lt;/configuration&gt;--&gt;
&lt;!--        &lt;/plugin&gt;--&gt;

        &lt;plugin&gt;
          &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
          &lt;configuration&gt;
            &lt;source&gt;1.8&lt;/source&gt;
            &lt;target&gt;1.8&lt;/target&gt;
            &lt;compilerArgs&gt;
              &lt;arg&gt;-parameters&lt;/arg&gt;
            &lt;/compilerArgs&gt;
          &lt;/configuration&gt;
        &lt;/plugin&gt;
</code></pre>
<h2 id="填好后再将项目重新build一下如下图rebuild-project"><a class="header" href="#填好后再将项目重新build一下如下图rebuild-project">填好后，再将项目重新build一下，如下图（rebuild project）</a></h2>
<p><img src="https://www.freesion.com/images/740/06beec0c809a222afb2d93c5406e9b7c.png" alt="img" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java线程池分析"><a class="header" href="#java线程池分析">Java线程池分析</a></h1>
<h2 id="一概述"><a class="header" href="#一概述">一、概述</a></h2>
<p>在执行一个异步任务或并发任务时，往往是通过直接<code>new Thread()</code>方法来创建新的线程，这样做弊端较多，更好的解决方案是合理地利用线程池，线程池的优势很明显，如下：</p>
<ol>
<li>降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；</li>
<li>提高系统响应速度，当有任务到达时，无需等待新线程的创建便能立即执行；</li>
<li>方便线程并发数的管控，线程若是无限制的创建，不仅会额外消耗大量系统资源，更是占用过多资源而阻塞系统或oom等状况，从而降低系统的稳定性。线程池能有效管控线程，统一分配、调优，提供资源使用率；</li>
<li>更强大的功能，线程池提供了定时、定期以及可控线程数等功能的线程池，使用方便简单。</li>
</ol>
<h2 id="二线程池用法"><a class="header" href="#二线程池用法">二、线程池用法</a></h2>
<p>Java API针对不同需求，利用<code>Executors</code>类提供了4种不同的线程池：<code>newCachedThreadPool</code>,<code> newFixedThreadPool</code>, <code>newScheduledThreadPool</code>, <code>newSingleThreadExecutor</code>，接下来讲讲线程池的用法。</p>
<h3 id="21-newcachedthreadpool"><a class="header" href="#21-newcachedthreadpool">2.1 newCachedThreadPool</a></h3>
<p>创建一个可缓存的无界线程池，该方法无参数。当线程池中的线程空闲时间超过60s则会自动回收该线程，当任务超过线程池的线程数则创建新线程。线程池的大小上限为Integer.MAX_VALUE，可看做是无限大。</p>
<pre><code>public void cachedThreadPoolDemo(){
    ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
    for (int i = 0; i &lt; 5; i++) {
        final int index = i;

        cachedThreadPool.execute(new Runnable() {

            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName()+&quot;, index=&quot;+index);
            }
        });

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>pool-1-thread-1, index=0
pool-1-thread-1, index=1
pool-1-thread-1, index=2
pool-1-thread-1, index=3
pool-1-thread-1, index=4
</code></pre>
<p>从运行结果可以看出，整个过程都在同一个线程<code>pool-1-thread-1</code>中运行，后面线程复用前面的线程。</p>
<h3 id="22-newfixedthreadpool"><a class="header" href="#22-newfixedthreadpool">2.2 newFixedThreadPool</a></h3>
<p>创建一个固定大小的线程池，该方法可指定线程池的固定大小，对于超出的线程会在<code>LinkedBlockingQueue</code>队列中等待。</p>
<pre><code>public void fixedThreadPoolDemo(){
    ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
    for (int i = 0; i &lt; 6; i++) {
        final int index = i;

        fixedThreadPool.execute(new Runnable() {

            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName()+&quot;, index=&quot;+index);
            }
        });

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>pool-1-thread-1, index=0
pool-1-thread-2, index=1
pool-1-thread-3, index=2
pool-1-thread-1, index=3
pool-1-thread-2, index=4
pool-1-thread-3, index=5
</code></pre>
<p>从运行结果可以看出，线程池大小为3，每休眠1s后将任务提交给线程池的各个线程轮番交错地执行。线程池的大小设置，可参数Runtime.getRuntime().availableProcessors()。</p>
<h3 id="23-newsinglethreadexecutor"><a class="header" href="#23-newsinglethreadexecutor">2.3 newSingleThreadExecutor</a></h3>
<p>创建一个只有线程的线程池，该方法无参数，所有任务都保存队列LinkedBlockingQueue中，等待唯一的单线程来执行任务，并保证所有任务按照指定顺序(FIFO或优先级)执行。</p>
<pre><code>public void singleThreadExecutorDemo(){
    ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
    for (int i = 0; i &lt; 3; i++) {
        final int index = i;

        singleThreadExecutor.execute(new Runnable() {

            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName()+&quot;, index=&quot;+index);
            }
        });

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>pool-1-thread-1, index=0
pool-1-thread-1, index=1
pool-1-thread-1, index=2
</code></pre>
<p>从运行结果可以看出，所有任务都是在单一线程运行的。</p>
<h3 id="24-newscheduledthreadpool"><a class="header" href="#24-newscheduledthreadpool">2.4 newScheduledThreadPool</a></h3>
<p>创建一个可定时执行或周期执行任务的线程池，该方法可指定线程池的核心线程个数。</p>
<pre><code>public void scheduledThreadPoolDemo(){
    ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3);
    //定时执行一次的任务，延迟1s后执行
    scheduledThreadPool.schedule(new Runnable() {

        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName()+&quot;, delay 1s&quot;);
        }
    }, 1, TimeUnit.SECONDS);

    //周期性地执行任务，延迟2s后，每3s一次地周期性执行任务
    scheduledThreadPool.scheduleAtFixedRate(new Runnable() {

        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName()+&quot;, every 3s&quot;);
        }
    }, 2, 3, TimeUnit.SECONDS);
}
</code></pre>
<p>运行结果：</p>
<pre><code>pool-1-thread-1, delay 1s
pool-1-thread-1, every 3s
pool-1-thread-2, every 3s
pool-1-thread-2, every 3s
...
</code></pre>
<ul>
<li>schedule(Runnable command, long delay, TimeUnit unit)，延迟一定时间后执行Runnable任务；</li>
<li>schedule(Callable callable, long delay, TimeUnit unit)，延迟一定时间后执行Callable任务；</li>
<li>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)，延迟一定时间后，以间隔period时间的频率周期性地执行任务；</li>
<li>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay,TimeUnit unit)，与scheduleAtFixedRate()方法很类似，但是不同的是scheduleWithFixedDelay()方法的周期时间间隔是以上一个任务执行结束到下一个任务开始执行的间隔，而scheduleAtFixedRate()方法的周期时间间隔是以上一个任务开始执行到下一个任务开始执行的间隔，也就是这一些任务系列的触发时间都是可预知的。</li>
</ul>
<p>ScheduledExecutorService功能强大，对于定时执行的任务，建议多采用该方法。</p>
<h3 id="25-方法对比"><a class="header" href="#25-方法对比">2.5 方法对比</a></h3>
<p>上述4个方法的参数对比，如下：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">工厂方法</th><th style="text-align: left">corePoolSize</th><th style="text-align: left">maximumPoolSize</th><th style="text-align: left">keepAliveTime</th><th style="text-align: left">workQueue</th></tr></thead><tbody>
<tr><td style="text-align: left">newCachedThreadPool</td><td style="text-align: left">0</td><td style="text-align: left">Integer.MAX_VALUE</td><td style="text-align: left">60s</td><td style="text-align: left">SynchronousQueue</td></tr>
<tr><td style="text-align: left">newFixedThreadPool</td><td style="text-align: left">nThreads</td><td style="text-align: left">nThreads</td><td style="text-align: left">0</td><td style="text-align: left">LinkedBlockingQueue</td></tr>
<tr><td style="text-align: left">newSingleThreadExecutor</td><td style="text-align: left">1</td><td style="text-align: left">1</td><td style="text-align: left">0</td><td style="text-align: left">LinkedBlockingQueue</td></tr>
<tr><td style="text-align: left">newScheduledThreadPool</td><td style="text-align: left">corePoolSize</td><td style="text-align: left">Integer.MAX_VALUE</td><td style="text-align: left">0</td><td style="text-align: left">DelayedWorkQueue</td></tr>
</tbody></table>
</div>
<p>其他参数都相同，其中线程工厂的默认类为DefaultThreadFactory，线程饱和的默认策略为ThreadPoolExecutor.AbortPolicy。</p>
<h2 id="三线程池原理"><a class="header" href="#三线程池原理">三、线程池原理</a></h2>
<p>Executors类提供4个静态工厂方法：newCachedThreadPool()、newFixedThreadPool(int)、newSingleThreadExecutor和newScheduledThreadPool(int)。这些方法最终都是通过ThreadPoolExecutor类来完成的，这里强烈建议大家直接使用Executors类提供的便捷的工厂方法，能完成绝大多数的用户场景，当需要更细节地调整配置，需要先了解每一项参数的意义。</p>
<h3 id="31-threadpoolexecutor"><a class="header" href="#31-threadpoolexecutor">3.1 ThreadPoolExecutor</a></h3>
<pre><code>public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), defaultHandler);
}
</code></pre>
<p>创建线程池，在构造一个新的线程池时，必须满足下面的条件：</p>
<ol>
<li>corePoolSize（线程池基本大小）必须大于或等于0；</li>
<li>maximumPoolSize（线程池最大大小）必须大于或等于1；</li>
<li>maximumPoolSize必须大于或等于corePoolSize；</li>
<li>keepAliveTime（线程存活保持时间）必须大于或等于0；</li>
<li>workQueue（任务队列）不能为空；</li>
<li>threadFactory（线程工厂）不能为空，默认为DefaultThreadFactory类</li>
<li>handler（线程饱和策略）不能为空，默认策略为ThreadPoolExecutor.AbortPolicy。</li>
</ol>
<h3 id="32-参数详解"><a class="header" href="#32-参数详解">3.2 参数详解</a></h3>
<pre><code>public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {
    if (corePoolSize &lt; 0 ||
        maximumPoolSize &lt;= 0 ||
        maximumPoolSize &lt; corePoolSize ||
        keepAliveTime &lt; 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
</code></pre>
<p><strong>参数说明：</strong></p>
<ol>
<li>corePoolSize（线程池基本大小）：当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize时，才会根据是否存在空闲线程，来决定是否需要创建新的线程。除了利用提交新任务来创建和启动线程（按需构造），也可以通过 prestartCoreThread() 或 prestartAllCoreThreads() 方法来提前启动线程池中的基本线程。</li>
<li>maximumPoolSize（线程池最大大小）：线程池所允许的最大线程个数。当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。另外，对于无界队列，可忽略该参数。</li>
<li>keepAliveTime（线程存活保持时间）：默认情况下，当线程池的线程个数多于corePoolSize时，线程的空闲时间超过keepAliveTime则会终止。但只要keepAliveTime大于0，allowCoreThreadTimeOut(boolean) 方法也可将此超时策略应用于核心线程。另外，也可以使用setKeepAliveTime()动态地更改参数。</li>
<li>unit（存活时间的单位）：时间单位，分为7类，从细到粗顺序：NANOSECONDS（纳秒），MICROSECONDS（微妙），MILLISECONDS（毫秒），SECONDS（秒），MINUTES（分），HOURS（小时），DAYS（天）；</li>
<li>workQueue（任务队列）：用于传输和保存等待执行任务的阻塞队列。可以使用此队列与线程池进行交互：
<ul>
<li>如果运行的线程数少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队。</li>
<li>如果运行的线程数等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程。</li>
<li>如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。</li>
</ul>
</li>
<li>threadFactory（线程工厂）：用于创建新线程。由同一个threadFactory创建的线程，属于同一个ThreadGroup，创建的线程优先级都为Thread.NORM_PRIORITY，以及是非守护进程状态。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：<code>pool-m-thread-n</code>（m为线程池的编号，n为线程池内的线程编号）;</li>
<li>handler（线程饱和策略）：当线程池和队列都满了，则表明该线程池已达饱和状态。
<ul>
<li>ThreadPoolExecutor.AbortPolicy：处理程序遭到拒绝，则直接抛出运行时异常 RejectedExecutionException。(默认策略)</li>
<li>ThreadPoolExecutor.CallerRunsPolicy：调用者所在线程来运行该任务，此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。</li>
<li>ThreadPoolExecutor.DiscardPolicy：无法执行的任务将被删除。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy：如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重新尝试执行任务（如果再次失败，则重复此过程）。</li>
</ul>
</li>
</ol>
<p><strong>排队有三种通用策略：</strong></p>
<ul>
<li>直接提交。工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</li>
<li>无界队列。使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize 的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</li>
<li>有界队列。当使用有限的 maximumPoolSizes 时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O 边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU 使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。</li>
</ul>
<h3 id="33-工作队列blockingqueue"><a class="header" href="#33-工作队列blockingqueue">3.3 工作队列BlockingQueue</a></h3>
<p>BlockingQueue的插入/移除/检查这些方法，对于不能立即满足但可能在将来某一时刻可以满足的操作，共有4种不同的处理方式：第一种是抛出一个异常，第二种是返回一个特殊值（null 或 false，具体取决于操作），第三种是在操作可以成功前，无限期地阻塞当前线程，第四种是在放弃前只在给定的最大时间限制内阻塞。如下表格：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">操作</th><th style="text-align: left">抛出异常</th><th style="text-align: left">特殊值</th><th style="text-align: left">阻塞</th><th style="text-align: left">超时</th></tr></thead><tbody>
<tr><td style="text-align: left">插入</td><td style="text-align: left">add(e)</td><td style="text-align: left">offer(e)</td><td style="text-align: left">put(e)</td><td style="text-align: left">offer(e, time, unit)</td></tr>
<tr><td style="text-align: left">移除</td><td style="text-align: left">remove()</td><td style="text-align: left">poll()</td><td style="text-align: left">take()</td><td style="text-align: left">poll(time, unit)</td></tr>
<tr><td style="text-align: left">检查</td><td style="text-align: left">element()</td><td style="text-align: left">peek()</td><td style="text-align: left">不可用</td><td style="text-align: left">不可用</td></tr>
</tbody></table>
</div>
<p><strong>实现BlockingQueue接口的常见类如下：</strong></p>
<ul>
<li>ArrayBlockingQueue：基于数组的有界阻塞队列。队列按FIFO原则对元素进行排序，队列头部是在队列中存活时间最长的元素，队尾则是存在时间最短的元素。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。 这是一个典型的“有界缓存区”，固定大小的数组在其中保持生产者插入的元素和使用者提取的元素。一旦创建了这样的缓存区，就不能再增加其容量。试图向已满队列中放入元素会导致操作受阻塞；试图从空队列中提取元素将导致类似阻塞。ArrayBlockingQueue构造方法可通过设置fairness参数来选择是否采用公平策略，公平性通常会降低吞吐量，但也减少了可变性和避免了“不平衡性”，可根据情况来决策。</li>
<li>LinkedBlockingQueue：基于链表的无界阻塞队列。与ArrayBlockingQueue一样采用FIFO原则对元素进行排序。基于链表的队列吞吐量通常要高于基于数组的队列。</li>
<li>SynchronousQueue：同步的阻塞队列。其中每个插入操作必须等待另一个线程的对应移除操作，等待过程一直处于阻塞状态，同理，每一个移除操作必须等到另一个线程的对应插入操作。SynchronousQueue没有任何容量。不能在同步队列上进行 peek，因为仅在试图要移除元素时，该元素才存在；除非另一个线程试图移除某个元素，否则也不能（使用任何方法）插入元素；也不能迭代队列，因为其中没有元素可用于迭代。Executors.newCachedThreadPool使用了该队列。</li>
<li>PriorityBlockingQueue：基于优先级的无界阻塞队列。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator 进行排序，具体取决于所使用的构造方法。优先级队列不允许使用 null 元素。依靠自然顺序的优先级队列还不允许插入不可比较的对象（这样做可能导致 ClassCastException）。虽然此队列逻辑上是无界的，但是资源被耗尽时试图执行 add 操作也将失败（导致 OutOfMemoryError）。</li>
</ul>
<h3 id="34-线程池关闭"><a class="header" href="#34-线程池关闭">3.4 线程池关闭</a></h3>
<p>调用线程池的shutdown()或shutdownNow()方法来关闭线程池</p>
<ul>
<li>shutdown原理：将线程池状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</li>
<li>shutdownNow原理：将线程池的状态设置成STOP状态，然后中断所有任务(包括正在执行的)的线程，并返回等待执行任务的列表。</li>
</ul>
<p>中断采用interrupt方法，所以无法响应中断的任务可能永远无法终止。但调用上述的两个关闭之一，isShutdown()方法返回值为true，当所有任务都已关闭，表示线程池关闭完成，则isTerminated()方法返回值为true。当需要立刻中断所有的线程，不一定需要执行完任务，可直接调用shutdownNow()方法。</p>
<h3 id="35-线程池流程"><a class="header" href="#35-线程池流程">3.5 线程池流程</a></h3>
<p><img src="http://gityuan.com/images/android-process/thread-pool.jpg" alt="thread-pool" /></p>
<ol>
<li>判断核心线程池是否已满，即已创建线程数是否小于corePoolSize？没满则创建一个新的工作线程来执行任务。已满则进入下个流程。</li>
<li>判断工作队列是否已满？没满则将新提交的任务添加在工作队列，等待执行。已满则进入下个流程。</li>
<li>判断整个线程池是否已满，即已创建线程数是否小于maximumPoolSize？没满则创建一个新的工作线程来执行任务，已满则交给饱和策略来处理这个任务。</li>
</ol>
<h2 id="四优化"><a class="header" href="#四优化">四、优化</a></h2>
<h3 id="41-合理地配置线程池"><a class="header" href="#41-合理地配置线程池">4.1 合理地配置线程池</a></h3>
<p>需要针对具体情况而具体处理，不同的任务类别应采用不同规模的线程池，任务类别可划分为CPU密集型任务、IO密集型任务和混合型任务。</p>
<ul>
<li>对于CPU密集型任务：线程池中线程个数应尽量少，不应大于CPU核心数；</li>
<li>对于IO密集型任务：由于IO操作速度远低于CPU速度，那么在运行这类任务时，CPU绝大多数时间处于空闲状态，那么线程池可以配置尽量多些的线程，以提高CPU利用率；</li>
<li>对于混合型任务：可以拆分为CPU密集型任务和IO密集型任务，当这两类任务执行时间相差无几时，通过拆分再执行的吞吐率高于串行执行的吞吐率，但若这两类任务执行时间有数据级的差距，那么没有拆分的意义。</li>
</ul>
<h3 id="42-线程池监控"><a class="header" href="#42-线程池监控">4.2 线程池监控</a></h3>
<p>利用线程池提供的参数进行监控，参数如下：</p>
<ul>
<li>taskCount：线程池需要执行的任务数量。</li>
<li>completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。</li>
<li>largestPoolSize：线程池曾经创建过的最大线程数量，通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。</li>
<li>getPoolSize：线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不减。</li>
<li>getActiveCount：获取活动的线程数。</li>
</ul>
<p>通过扩展线程池进行监控：继承线程池并重写线程池的beforeExecute()，afterExecute()和terminated()方法，可以在任务执行前、后和线程池关闭前自定义行为。如监控任务的平均执行时间，最大执行时间和最小执行时间等。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lombok的基本使用"><a class="header" href="#lombok的基本使用">Lombok的基本使用</a></h1>
<p><strong>以前的Java项目中，充斥着太多不友好的代码：POJO的getter/setter/toString；异常处理；I/O流的关闭操作等等，这些样板代码既没有技术含量，又影响着代码的美观，Lombok应运而生。</strong></p>
<h1 id="为什么推荐使用lombok"><a class="header" href="#为什么推荐使用lombok"><strong>为什么推荐使用Lombok:</strong></a></h1>
<p>**<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FYs6ksYasfUj7TSCGICHM8w">@Lombok有啥牛皮的？SpringBoot和IDEA官方都要支持它！</a>
**</p>
<blockquote>
<p><strong>最近<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU1Nzg4NjgyMw%3D%3D%26mid%3D2247488358%26idx%3D1%26sn%3D6eee5162428ff64d6c5a2b72552c58db%26scene%3D21%23wechat_redirect">IDEA 2020最后一个版本发布了</a>，已经内置了Lombok插件，SpringBoot 2.1.x之后的版本也在Starter中内置了Lombok依赖。为什么他们都要支持Lombok呢？今天我来讲讲Lombok的使用，看看它有何神奇之处！</strong></p>
</blockquote>
<p>任何技术的出现都是为了解决某一类问题，如果在此基础上再建立奇技淫巧，不如回归Java本身，应该保持合理使用而不滥用。</p>
<p>*<strong>Lombok的使用非常简单：*</strong></p>
<h3 id="1引入相应的maven包"><a class="header" href="#1引入相应的maven包">1）引入相应的maven包</a></h3>
<blockquote>
<dependency>
<p>​     <groupId>org.projectlombok</groupId></p>
<p>​     <artifactId>lombok</artifactId></p>
<p>​     <version>1.16.18</version></p>
<p>​     <scope>provided</scope></p>
</dependency>
</blockquote>
<p>Lombok的scope=provided，说明它只在编译阶段生效，不需要打入包中。事实正是如此，Lombok在编译期将带Lombok注解的Java文件正确编译为完整的Class文件。</p>
<h2 id="2添加ide工具对lombok的支持"><a class="header" href="#2添加ide工具对lombok的支持">2）添加IDE工具对Lombok的支持</a></h2>
<p>IDEA中引入Lombok支持如下：</p>
<p>点击File-- Settings设置界面，安装Lombok插件:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15718833-1afe50458f8d1450.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/864" alt="img" /></p>
<p>点击File-- Settings设置界面，开启 AnnocationProcessors：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15718833-9c160cda34dd360b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1072" alt="img" /></p>
<p>开启该项是为了让Lombok注解在编译阶段起到作用。</p>
<blockquote>
<p>Eclipse的Lombok插件安装可以自行百度，也比较简单，值得一提的是，由于Eclipse内置的编译器不是Oracle  javac，而是eclipse自己实现的Eclipse Compiler for Java  (ECJ).要让ECJ支持Lombok，需要在eclipse.ini配置文件中添加如下两项内容：</p>
<p>-Xbootclasspath/a:[lombok.jar所在路径</p>
</blockquote>
<h2 id="3lombok实现原理"><a class="header" href="#3lombok实现原理">3）Lombok实现原理</a></h2>
<p>自从Java 6起，javac就支持“JSR 269 Pluggable Annotation Processing API”规范，只要程序实现了该API，就能在javac运行的时候得到调用。</p>
<p>Lombok就是一个实现了&quot;JSR 269 API&quot;的程序。在使用javac的过程中，它产生作用的具体流程如下：</p>
<hr />
<p>\1. javac对源代码进行分析，生成一棵抽象语法树(AST)</p>
<p>\2. javac编译过程中调用实现了JSR 269的Lombok程序</p>
<p>\3. 此时Lombok就对第一步骤得到的AST进行处理，找到Lombok注解所在类对应的语法树    (AST)，然后修改该语法树(AST)，增加Lombok注解定义的相应树节点</p>
<p>\4. javac使用修改后的抽象语法树(AST)生成字节码文件</p>
<hr />
<h2 id="4-lombok注解的使用"><a class="header" href="#4-lombok注解的使用">4) Lombok注解的使用</a></h2>
<h4 id="pojo类常用注解"><a class="header" href="#pojo类常用注解">POJO类常用注解:</a></h4>
<p><strong>@Getter/@Setter: 作用类上，生成所有成员变量的getter/setter方法；作用于成员变量上，生成该成员变量的getter/setter方法。可以设定访问权限及是否懒加载等。</strong></p>
<blockquote>
<p>package com.kaplan.pojo;</p>
<p>import lombok.*;</p>
<p>import lombok.extern.log4j.Log4j;</p>
<p>@Getter</p>
<p>@Setter</p>
<p>public class TestDemo {</p>
<p>private String name;</p>
<p>​    private int age ;    private String email;</p>
<p>private String address;    private String password;</p>
<p>​    @Getter @Setter private boolean funny;</p>
<p>}</p>
</blockquote>
<p><strong>@ToString：作用于类，覆盖默认的toString()方法，可以通过of属性限定显示某些字段，通过exclude属性排除某些字段。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/15718833-3a5bcb5ef8c44919.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/480" alt="img" /></p>
<p>**
@EqualsAndHashCode：作用于类，覆盖默认的equals和hashCode**</p>
<p><strong>@NonNull：主要作用于成员变量和参数中，标识不能为空，否则抛出空指针异常。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/15718833-a8b3130e33b0fd46.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/532" alt="img" /></p>
<p>@NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor：作用于类上，用于生成构造函数。有staticName、access等属性。</p>
<p><strong>staticName属性一旦设定，将采用静态方法的方式生成实例，access属性可以限定访问权限。</strong></p>
<p><strong>@NoArgsConstructor：生成无参构造器；</strong></p>
<p><strong>@RequiredArgsConstructor：生成包含final和@NonNull注解的成员变量的构造器；</strong></p>
<p><strong>@AllArgsConstructor：生成全参构造器</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/15718833-174549c9dd605992.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/584" alt="img" /></p>
<p>**@Data：作用于类上，是以下注解的集合：@ToString @EqualsAndHashCode @Getter @Setter @RequiredArgsConstructor
**</p>
<p><strong>@Builder：作用于类上，将类转变为建造者模式</strong></p>
<p><strong>@Log：作用于类上，生成日志变量。针对不同的日志实现产品，有不同的注解：</strong></p>
<h4 id="其他重要注解"><a class="header" href="#其他重要注解">其他重要注解：</a></h4>
<p><strong>@Cleanup：自动关闭资源，针对实现了java.io.Closeable接口的对象有效，如：典型的IO流对象</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/15718833-b12e7d13e5ca73b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/544" alt="img" /></p>
<p><strong>编译后结果如下：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/15718833-95f0e9bed44ae1d6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/572" alt="img" /></p>
<p><strong>@SneakyThrows：可以对受检异常进行捕捉并抛出，可以改写上述的main方法如下：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/15718833-fcf6d6886fc8117a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/536" alt="img" /></p>
<p>@Synchronized：作用于方法级别，可以替换synchronize关键字或lock锁，用处不大.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="一"><a class="header" href="#一">一、</a></h1>
<pre><code class="language-java">import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.StandardOpenOption;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;


public class CalcMD5 {

  private static final char[] hexCode = &quot;0123456789ABCDEF&quot;.toCharArray();

  public static void main(String[] args) {

    File file = new File(&quot;C:\\Users\\Administrator\\Desktop\\input.txt&quot;);
    String md5 = calcMD5(file);
    System.out.println(&quot;MD5:&quot; + md5);
  }

  /**
   * 计算文件 MD5
   * @param file
   * @return 返回文件的md5字符串，如果计算过程中任务的状态变为取消或暂停，返回null， 如果有其他异常，返回空字符串
   */
  protected static String calcMD5(File file) {
    try (InputStream stream = Files.newInputStream(file.toPath(), StandardOpenOption.READ)) {
      MessageDigest digest = MessageDigest.getInstance(&quot;MD5&quot;);
      byte[] buf = new byte[8192];
      int len;
      while ((len = stream.read(buf)) &gt; 0) {
        digest.update(buf, 0, len);
      }
      return toHexString(digest.digest());
    } catch (IOException e) {
      e.printStackTrace();
      return &quot;&quot;;
    } catch (NoSuchAlgorithmException e) {
      e.printStackTrace();
      return &quot;&quot;;
    }
  }

  public static String toHexString(byte[] data) {
    StringBuilder r = new StringBuilder(data.length * 2);
    for (byte b : data) {
      r.append(hexCode[(b &gt;&gt; 4) &amp; 0xF]);
      r.append(hexCode[(b &amp; 0xF)]);
    }
    return r.toString();
  }

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="onenote-笔记"><a class="header" href="#onenote-笔记">onenote 笔记</a></h1>
<p><a href="https://i.imgur.com/UfLilRG.png">Imgur</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redis"><a class="header" href="#redis">Redis</a></h1>
<h2 id="一string-string-存储"><a class="header" href="#一string-string-存储"><strong>一、&lt;String, String&gt; 存储</strong></a></h2>
<p><strong>pom.xml</strong></p>
<blockquote>
<pre><code class="language-xml">&lt;!-- 引入依赖 --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</blockquote>
<ul>
<li><strong>application.properties</strong></li>
</ul>
<blockquote>
<pre><code class="language-properties">#编写配置文件(redis)
spring.redis.host=127.0.0.1
spring.redis.port=6379
spring.redis.password=
spring.redis.database=0
spring.redis.pool.max-active=8
spring.redis.pool.max-wait=-1
spring.redis.pool.max-idle=500
spring.redis.pool.min-idle=0
spring.redis.timeout=0
</code></pre>
</blockquote>
<h3 id="连接redis做相应的数据操作"><a class="header" href="#连接redis做相应的数据操作"><strong>连接redis做相应的数据操作</strong></a></h3>
<p>查看源码可知 <code>redisTemplate</code> 和 <code>StringRedisTemplate</code>已被自动配置，所以我们直接用就可以</p>
<ul>
<li><strong>RedisRepository.java</strong></li>
</ul>
<pre><code class="language-java">@Repository
public class RedisRepository {

  @Autowired 
  private StringRedisTemplate template;

  public void setKey(String key, String value) {
    ValueOperations&lt;String, String&gt; ops = template.opsForValue();
    ops.set(key, value);
  }

  public String getValue(String key) {
    ValueOperations&lt;String, String&gt; ops = this.template.opsForValue();
    return ops.get(key);
  }
}
</code></pre>
<ul>
<li><strong>RedisController.java</strong></li>
</ul>
<pre><code class="language-java">@RestController
public class RedisController {
  
  @Autowired
  private RedisRepository redisRepository;

  @RequestMapping(&quot;/set&quot;)
  public String set(String key,String value){
    redisRepository.setKey(key, value);
    return &quot;success&quot;;
  }
  
  @RequestMapping(&quot;/get&quot;)
  public String get(String key){
    return redisRepository.getValue(key);
  }
}
</code></pre>
<h3 id="访问测试"><a class="header" href="#访问测试"><strong>访问测试</strong></a></h3>
<p>=&gt; <code>http://127.0.0.1:8087/set?key=name&amp;value=hqqich</code></p>
<p>&lt;= <code>success</code></p>
<p>=&gt; <code>127.0.0.1:8087/set?key=name&amp;value=hqqich</code></p>
<p>&lt;= <code>hqqich</code></p>
<h2 id="二string-object-存储"><a class="header" href="#二string-object-存储">二、&lt;String, Object&gt; 存储</a></h2>
<h3 id="默认情况下redistemplate只支持string"><a class="header" href="#默认情况下redistemplate只支持string"><strong>默认情况下RedisTemplate只支持String</strong></a></h3>
<ul>
<li><strong>RedisConfig.java</strong> <code>redis</code>配置类</li>
</ul>
<pre><code class="language-java">import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
public class RedisConfig {

  @Bean
  @SuppressWarnings(&quot;all&quot;)
  public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory factory){
    RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;();
    template.setConnectionFactory(factory);
    Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
    ObjectMapper om = new ObjectMapper();
    om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
    om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
    jackson2JsonRedisSerializer.setObjectMapper(om);
    StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();
    // key采用String的序列化方式
    template.setKeySerializer(stringRedisSerializer);
    // hash的key也采用String的序列化方式
    template.setHashKeySerializer(stringRedisSerializer);
    // value序列化方式采用jackson
    template.setValueSerializer(jackson2JsonRedisSerializer);
    // hash的value序列化方式采用jackson
    template.setHashValueSerializer(jackson2JsonRedisSerializer);
    template.afterPropertiesSet();
    return template;
  }
}
</code></pre>
<ul>
<li><strong>RedisUtil.java</strong> <code>redis</code>工具类</li>
</ul>
<pre><code class="language-java">import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;

@Component
public class RedisUtil {

    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;

    // =============================common============================
    /**
     * 指定缓存失效时间
     *
     * @param key  键
     * @param time 时间(秒)
     * @return
     */
    public boolean expire(String key, long time) {
        try {
            if (time &gt; 0) {
                redisTemplate.expire(key, time, TimeUnit.SECONDS);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 根据key 获取过期时间
     *
     * @param key 键 不能为null
     * @return 时间(秒) 返回0代表为永久有效
     */
    public long getExpire(String key) {
        return redisTemplate.getExpire(key, TimeUnit.SECONDS);
    }

    /**
     * 判断key是否存在
     *
     * @param key 键
     * @return true 存在 false不存在
     */
    public boolean hasKey(String key) {
        try {
            return redisTemplate.hasKey(key);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 删除缓存
     *
     * @param key 可以传一个值 或多个
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public void del(String... key) {
        if (key != null &amp;&amp; key.length &gt; 0) {
            if (key.length == 1) {
                redisTemplate.delete(key[0]);
            } else {
                redisTemplate.delete((Collection&lt;String&gt;) CollectionUtils.arrayToList(key));
            }
        }
    }

    // ============================String=============================

    /**
     * 普通缓存获取
     *
     * @param key 键
     * @return 值
     */
    public Object get(String key) {
        return key == null ? null : redisTemplate.opsForValue().get(key);
    }

    /**
     * 普通缓存放入
     *
     * @param key   键
     * @param value 值
     * @return true成功 false失败
     */
    public boolean set(String key, Object value) {
        try {
            redisTemplate.opsForValue().set(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }

    }

    /**
     * 普通缓存放入并设置时间
     *
     * @param key   键
     * @param value 值
     * @param time  时间(秒) time要大于0 如果time小于等于0 将设置无限期
     * @return true成功 false 失败
     */
    public boolean set(String key, Object value, long time) {
        try {
            if (time &gt; 0) {
                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);
            } else {
                set(key, value);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 递增
     *
     * @param key   键
     * @param delta 要增加几(大于0)
     * @return
     */
    public long incr(String key, long delta) {
        if (delta &lt; 0) {
            throw new RuntimeException(&quot;递增因子必须大于0&quot;);
        }
        return redisTemplate.opsForValue().increment(key, delta);
    }

    /**
     * 递减
     *
     * @param key   键
     * @param delta 要减少几(小于0)
     * @return
     */
    public long decr(String key, long delta) {
        if (delta &lt; 0) {
            throw new RuntimeException(&quot;递减因子必须大于0&quot;);
        }
        return redisTemplate.opsForValue().increment(key, -delta);
    }

    // ================================Map=================================

    /**
     * HashGet
     *
     * @param key  键 不能为null
     * @param item 项 不能为null
     * @return 值
     */
    public Object hget(String key, String item) {
        return redisTemplate.opsForHash().get(key, item);
    }

    /**
     * 获取hashKey对应的所有键值
     *
     * @param key 键
     * @return 对应的多个键值
     */
    public Map&lt;Object, Object&gt; hmget(String key) {
        return redisTemplate.opsForHash().entries(key);
    }

    /**
     * HashSet
     *
     * @param key 键
     * @param map 对应多个键值
     * @return true 成功 false 失败
     */
    public boolean hmset(String key, Map&lt;String, Object&gt; map) {
        try {
            redisTemplate.opsForHash().putAll(key, map);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * HashSet 并设置时间
     *
     * @param key  键
     * @param map  对应多个键值
     * @param time 时间(秒)
     * @return true成功 false失败
     */
    public boolean hmset(String key, Map&lt;String, Object&gt; map, long time) {
        try {
            redisTemplate.opsForHash().putAll(key, map);
            if (time &gt; 0) {
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 向一张hash表中放入数据,如果不存在将创建
     *
     * @param key   键
     * @param item  项
     * @param value 值
     * @return true 成功 false失败
     */
    public boolean hset(String key, String item, Object value) {
        try {
            redisTemplate.opsForHash().put(key, item, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 向一张hash表中放入数据,如果不存在将创建
     *
     * @param key   键
     * @param item  项
     * @param value 值
     * @param time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间
     * @return true 成功 false失败
     */
    public boolean hset(String key, String item, Object value, long time) {
        try {
            redisTemplate.opsForHash().put(key, item, value);
            if (time &gt; 0) {
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 删除hash表中的值
     *
     * @param key  键 不能为null
     * @param item 项 可以使多个 不能为null
     */
    public void hdel(String key, Object... item) {
        redisTemplate.opsForHash().delete(key, item);
    }

    /**
     * 判断hash表中是否有该项的值
     *
     * @param key  键 不能为null
     * @param item 项 不能为null
     * @return true 存在 false不存在
     */
    public boolean hHasKey(String key, String item) {
        return redisTemplate.opsForHash().hasKey(key, item);
    }

    /**
     * hash递增 如果不存在,就会创建一个 并把新增后的值返回
     *
     * @param key  键
     * @param item 项
     * @param by   要增加几(大于0)
     * @return
     */
    public double hincr(String key, String item, double by) {
        return redisTemplate.opsForHash().increment(key, item, by);
    }

    /**
     * hash递减
     *
     * @param key  键
     * @param item 项
     * @param by   要减少记(小于0)
     * @return
     */
    public double hdecr(String key, String item, double by) {
        return redisTemplate.opsForHash().increment(key, item, -by);
    }

    // ============================set=============================

    /**
     * 根据key获取Set中的所有值
     *
     * @param key 键
     * @return
     */
    public Set&lt;Object&gt; sGet(String key) {
        try {
            return redisTemplate.opsForSet().members(key);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 根据value从一个set中查询,是否存在
     *
     * @param key   键
     * @param value 值
     * @return true 存在 false不存在
     */
    public boolean sHasKey(String key, Object value) {
        try {
            return redisTemplate.opsForSet().isMember(key, value);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将数据放入set缓存
     *
     * @param key    键
     * @param values 值 可以是多个
     * @return 成功个数
     */
    public long sSet(String key, Object... values) {
        try {
            return redisTemplate.opsForSet().add(key, values);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 将set数据放入缓存
     *
     * @param key    键
     * @param time   时间(秒)
     * @param values 值 可以是多个
     * @return 成功个数
     */
    public long sSetAndTime(String key, long time, Object... values) {
        try {
            Long count = redisTemplate.opsForSet().add(key, values);
            if (time &gt; 0)
                expire(key, time);
            return count;
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 获取set缓存的长度
     *
     * @param key 键
     * @return
     */
    public long sGetSetSize(String key) {
        try {
            return redisTemplate.opsForSet().size(key);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 移除值为value的
     *
     * @param key    键
     * @param values 值 可以是多个
     * @return 移除的个数
     */
    public long setRemove(String key, Object... values) {
        try {
            Long count = redisTemplate.opsForSet().remove(key, values);
            return count;
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }
    // ===============================list=================================

    /**
     * 获取list缓存的内容
     *
     * @param key   键
     * @param start 开始
     * @param end   结束 0 到 -1代表所有值
     * @return
     */
    public List&lt;Object&gt; lGet(String key, long start, long end) {
        try {
            return redisTemplate.opsForList().range(key, start, end);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 获取list缓存的长度
     *
     * @param key 键
     * @return
     */
    public long lGetListSize(String key) {
        try {
            return redisTemplate.opsForList().size(key);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 通过索引 获取list中的值
     *
     * @param key   键
     * @param index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推
     * @return
     */
    public Object lGetIndex(String key, long index) {
        try {
            return redisTemplate.opsForList().index(key, index);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 将list放入缓存
     *
     * @param key   键
     * @param value 值
     * @return
     */
    public boolean lSet(String key, Object value) {
        try {
            redisTemplate.opsForList().rightPush(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将list放入缓存
     *
     * @param key   键
     * @param value 值
     * @param time  时间(秒)
     * @return
     */
    public boolean lSet(String key, Object value, long time) {
        try {
            redisTemplate.opsForList().rightPush(key, value);
            if (time &gt; 0)
                expire(key, time);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将list放入缓存
     *
     * @param key   键
     * @param value 值
     * @return
     */
    public boolean lSet(String key, List&lt;Object&gt; value) {
        try {
            redisTemplate.opsForList().rightPushAll(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将list放入缓存
     *
     * @param key   键
     * @param value 值
     * @param time  时间(秒)
     * @return
     */
    public boolean lSet(String key, List&lt;Object&gt; value, long time) {
        try {
            redisTemplate.opsForList().rightPushAll(key, value);
            if (time &gt; 0)
                expire(key, time);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 根据索引修改list中的某条数据
     *
     * @param key   键
     * @param index 索引
     * @param value 值
     * @return
     */
    public boolean lUpdateIndex(String key, long index, Object value) {
        try {
            redisTemplate.opsForList().set(key, index, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 移除N个值为value
     *
     * @param key   键
     * @param count 移除多少个
     * @param value 值
     * @return 移除的个数
     */
    public long lRemove(String key, long count, Object value) {
        try {
            Long remove = redisTemplate.opsForList().remove(key, count, value);
            return remove;
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }
}
</code></pre>
<ul>
<li><strong>RedisController.java</strong></li>
</ul>
<pre><code class="language-java">@RestController
public class RedisController {

  @Autowired
  private RedisUtil redisUtil;

  @RequestMapping(value = &quot;/setUser&quot;, method = RequestMethod.POST)
  public boolean setUser(@RequestBody User user, @RequestParam(value = &quot;user&quot;) String username){
    boolean set = redisUtil.set(username, user);
    return set;
  }
    
  @RequestMapping(&quot;/getUser&quot;)
  public Object getUser(@RequestParam(value = &quot;user&quot;) String user){
    Object object = redisUtil.get(user);
    return object;
  }
}
</code></pre>
<h3 id="访问测试-1"><a class="header" href="#访问测试-1"><strong>访问测试</strong></a></h3>
<p>=&gt;POST <code>127.0.0.1:8087/setUser?user=user0008</code> 传入JSON数据<code>{&quot;id&quot;:&quot;7&quot;, &quot;name&quot;:&quot;hqqich&quot;, &quot;age&quot;:&quot;10&quot;}</code></p>
<p>&lt;= <code>true</code></p>
<p>=&gt; GET <code>127.0.0.1:8087/getUser?user=user0008</code></p>
<p>&lt;= <code>{&quot;id&quot;:&quot;7&quot;, &quot;name&quot;:&quot;hqqich&quot;, &quot;age&quot;:&quot;10&quot;}</code></p>
<h2 id="三利用redis做cache缓存-"><a class="header" href="#三利用redis做cache缓存-">**三、利用redis做cache缓存 **</a></h2>
<ol>
<li>
<h4 id="pomxml添加依赖"><a class="header" href="#pomxml添加依赖"><strong><code>pom.xml</code>添加依赖</strong></a></h4>
<pre><code class="language-xml">&lt;!-- 最好使用连接池 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!-- 下面的用不用无所谓 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<h4 id="3个重要注解"><a class="header" href="#3个重要注解"><strong>3个重要注解</strong></a></h4>
<blockquote>
<p><code>@CachePut</code> 表示将方法结果返回存放到缓存中。（<strong>cache中查询到结果后继续执行后续</strong>）
<code>@Cacheable</code> 表示先从缓存中通过定义的键查询，如果可以查询到数据，则返回，否则执行该方法，返回数据，并且将返回结果保存到缓存中。（<strong>cache中查询到结果过不再执行后续</strong>）
<code>@CacheEvict</code> 通过定义的键移除缓存，它有一个 Boolean 类型的配置项 beforeInvocation，表示在方法之前或者之后移除缓存。因为其默认值为false ，所以默认为方法之后将缓存移除 。</p>
</blockquote>
</li>
<li>
<h4 id="applicationproperties添加配置"><a class="header" href="#applicationproperties添加配置"><code>application.properties</code>添加配置</a></h4>
<blockquote>
<pre><code class="language-properties"># cache
spring.cache.type=redis
spring.cache.cache-names=redisCache
# 缓存超时时间，0为永不超时
spring.cache.redis.time-to-live=0ms
</code></pre>
</blockquote>
</li>
<li>
<h4 id="在dao层添加注解命名一定要注意不要写错"><a class="header" href="#在dao层添加注解命名一定要注意不要写错">在DAO层添加注解（<strong>命名一定要注意，不要写错</strong>）</a></h4>
<blockquote>
<pre><code class="language-java">@Service
public class UserService {
    
  //
  @CachePut(value = &quot;redisCache&quot; , key = &quot;'redis_user_'+#result.id&quot;)
  public User insertUser(User user){
    //模拟数据库操作
    try {
      Thread.sleep(1000*1);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    return user;
  }

  @Cacheable(value = &quot;redisCache&quot; , key = &quot;'redis_user_'+#id&quot;)
  public User getUser(int id){
    //模拟数据库操作
    try {
      Thread.sleep(1000*1);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    return new User(1, &quot;name&quot;, &quot;age&quot;);
  }
  
  //命中率低，所以不采用缓存机制
  public List&lt;User&gt; findUsers(String age){
    return new ArrayList&lt;User&gt;();
  }

  @CachePut(value = &quot;redisCache&quot; ,condition = &quot;#result != 'null'&quot;, key = &quot;'redis_user_'+#id&quot;)
  public User UpdateUser(int id, String name){
    //此处调用 getUser 方法，该方法缓存注解失效
    //所以这里还是会执行SQL，将查询到数据库中的最新数据
    User user = this.getUser(id);
    if (user == null){
      return null;
    }
    //模拟数据库操作
    try {
      Thread.sleep(1000*1);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    return user;
  }

  @CacheEvict(value = &quot;redisCache&quot; , key = &quot;'redis_user_'+#id&quot;, beforeInvocation = false)
  public int deleteUser(int id){
    //模拟数据库操作
    try {
      Thread.sleep(1000*1);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    return 1;
  }
}
</code></pre>
</blockquote>
</li>
<li>
<h4 id="在springboot启动类中添加启动cache缓存的注解"><a class="header" href="#在springboot启动类中添加启动cache缓存的注解"><strong>在<code>springboot</code>启动类中添加启动cache缓存的注解</strong></a></h4>
<pre><code class="language-java">@SpringBootApplication
@EnableCaching
public class DemoRedisApplication {
  public static void main(String[] args) {
    SpringApplication.run(DemoRedisApplication.class, args);
  }
}
</code></pre>
<p>此时在controller中调用时间会缩短</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="字符串string"><a class="header" href="#字符串string"><strong>字符串string</strong>：</a></h2>
<p>字符串类型是Redis中最为基础的数据存储类型，是一个由字节组成的序列，他在Redis中是二进制安全的，这便意味着该类型可以接受任何格式的数据，如JPEG图像数据货Json对象描述信息等，是标准的key-value，一般来存字符串，整数和浮点数。Value最多可以容纳的数据长度为512MB
应用场景：很常见的场景用于统计网站访问数量，当前在线人数等。incr命令(++操作)</p>
<p><img src="https://images2017.cnblogs.com/blog/1267939/201712/1267939-20171218173355068-1009075048.png" alt="img" /></p>
<h2 id="列表list"><a class="header" href="#列表list"><strong>列表list</strong>：</a></h2>
<p>Redis的列表允许用户从序列的两端推入或者弹出元素，列表由多个字符串值组成的有序可重复的序列，是链表结构，所以向列表两端添加元素的时间复杂度为0(1)，获取越接近两端的元素速度就越快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的。List中可以包含的最大元素数量是4294967295。
应用场景：1.最新消息排行榜。2.消息队列，以完成多程序之间的消息交换。可以用push操作将任务存在list中（生产者），然后线程在用pop操作将任务取出进行执行。（消费者）</p>
<p><img src="https://images2017.cnblogs.com/blog/1267939/201712/1267939-20171218173319896-1986145136.png" alt="img" /></p>
<h2 id="散列hash"><a class="header" href="#散列hash"><strong>散列hash</strong>：</a></h2>
<p>Redis中的散列可以看成具有String key和String value的map容器，可以将多个key-value存储到一个key中。每一个Hash可以存储4294967295个键值对。
应用场景：例如存储、读取、修改用户属性（name，age，pwd等）</p>
<p><img src="https://images2017.cnblogs.com/blog/1267939/201712/1267939-20171218173425803-1568128972.png" alt="img" /></p>
<h2 id="集合set"><a class="header" href="#集合set"><strong>集合set</strong>：</a></h2>
<p>Redis的集合是无序不可重复的，和列表一样，在执行插入和删除和判断是否存在某元素时，效率是很高的。集合最大的优势在于可以进行交集并集差集操作。Set可包含的最大元素数量是4294967295。
应用场景：1.利用交集求共同好友。2.利用唯一性，可以统计访问网站的所有独立IP。3.好友推荐的时候根据tag求交集，大于某个threshold（临界值的）就可以推荐。</p>
<p><img src="https://images2017.cnblogs.com/blog/1267939/201712/1267939-20171218173450459-219862735.png" alt="img" /></p>
<h2 id="有序集合sorted-set"><a class="header" href="#有序集合sorted-set"><strong>有序集合sorted set</strong>：</a></h2>
<p>和set很像，都是字符串的集合，都不允许重复的成员出现在一个set中。他们之间差别在于有序集合中每一个成员都会有一个分数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。尽管有序集合中的成员必须是卫衣的，但是分数(score)却可以重复。
应用场景：可以用于一个大型在线游戏的积分排行榜，每当玩家的分数发生变化时，可以执行zadd更新玩家分数(score)，此后在通过zrange获取几分top ten的用户信息。</p>
<p><img src="https://images2017.cnblogs.com/blog/1267939/201712/1267939-20171218173530318-1825724249.png" alt="img" /></p>
<h2 id="-2"><a class="header" href="#-2"></a></h2>
<h2 id="最后还有个对key的通用操作所有的数据类型都可以使用的"><a class="header" href="#最后还有个对key的通用操作所有的数据类型都可以使用的">最后，还有个对key的通用操作，所有的数据类型都可以使用的</a></h2>
<p><img src="https://images2017.cnblogs.com/blog/1267939/201712/1267939-20171218173804350-2060665680.png" alt="img" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="responseentity实现rest风格的返回值"><a class="header" href="#responseentity实现rest风格的返回值">ResponseEntity实现Rest风格的返回值</a></h1>
<h3 id="简介"><a class="header" href="#简介">简介</a></h3>
<p>在前面，我们使用了@ResponseBody注解和@RestController注解，其作用就不多说了，但是问题就来了，如果想向前段返回一个状态码该怎么实现呢？</p>
<p>我们知道响应头并不属于响应体，所以即使使用自己封装的Bean加入状态码属性，也只能在前段获取一个所谓的状态码而已，在RESTful风格中，我们要明确的返回正确的状态码。那么单单使用@ResponseBody就不够用了。</p>
<h3 id="responsestatus"><a class="header" href="#responsestatus">@ResponseStatus</a></h3>
<p>前面我们说到@ResponseBody不能正确的返回响应状态码，于是出现了@ResponseStatus注解，带有@ResponseStatus注解的异常类会被ResponseStatusExceptionResolver 解析。可以实现自定义的一些异常,同时在页面上进行显示。具体的使用方法如下:</p>
<p>1.首先定义一个异常类：</p>
<pre><code class="language-java">@ResponseStatus(value = HttpStatus.FORBIDDEN,reason = &quot;用户名和密码不匹配!&quot;)
public class UserNameNotMatchPasswordException extends RuntimeException{
        
}
</code></pre>
<p>2.人为抛出一个异常:</p>
<pre><code class="language-java">  @RequestMapping(&quot;/testResponseStatusExceptionResolver&quot;)
    public String testResponseStatusExceptionResolver(@RequestParam(&quot;i&quot;) int i){
        if (i==13){
            throw new UserNameNotMatchPasswordException();
        }
        System.out.println(&quot;testResponseStatusExceptionResolver....&quot;);
        return &quot;success&quot;;
    }
</code></pre>
<p>3.输入如下额路径:</p>
<p>http://localhost:8090/testResponseStatusExceptionResolver?i=13</p>
<p>此时浏览器会显示403，以及用户名密码不匹配。</p>
<p>当然，也可以在方法上进行修饰:</p>
<pre><code class="language-java">@ResponseStatus(reason = &quot;测试&quot;,value = HttpStatus.NOT_FOUND)
    @RequestMapping(&quot;/testResponseStatusExceptionResolver&quot;)
    public String testResponseStatusExceptionResolver(@RequestParam(&quot;i&quot;) int i){
        if (i==13){
            throw new UserNameNotMatchPasswordException();
        }
        System.out.println(&quot;testResponseStatusExceptionResolver....&quot;);
        return &quot;success&quot;;
    }
</code></pre>
<p>这时所有的请求都会报错。</p>
<p>不过我们也不会使用这个注解，会使用全局的异常处理。详见上篇。</p>
<h3 id="responseentity"><a class="header" href="#responseentity">ResponseEntity</a></h3>
<p>它是Spring提供的一个类，它内部封装了状态码，请求头，请求体等信息，用户可以根据自己的需要修改状态码、请求体的信息。ResponseEntity中的泛型用于指定请求体的类型，它的请求体和@ResponseBody的作用完全一致，并且ResponseEntity的优先级要高于@ResponseBody，即：<strong>如果返回值是ResponseEntity，即使存在ResponseBody或者@RestController注解，也默认不会生效，而是使用ResponseEntity。</strong></p>
<h3 id="httpstatus"><a class="header" href="#httpstatus">HttpStatus</a></h3>
<p>这是Spring提供的一个枚举类，其遵循RESTful风格封装了大量了响应状态码。详见<code>org.springframework.http.HttpStatus;</code></p>
<h3 id="如何使用responseentity"><a class="header" href="#如何使用responseentity">如何使用ResponseEntity</a></h3>
<p>使用构造返回，其中第一个参数为响应体，第二个为响应码</p>
<pre><code class="language-java">//使用构造参数构建
new ResponseEntity&lt;String&gt;(&quot;return info&quot;,HttpStatus.BAD_REQUEST);
//使用构造参数构建
new ResponseEntity&lt;JavaBean&gt;(javaBean,HttpStatus.BAD_REQUEST);
</code></pre>
<p>使用status设置响应码，body指定响应头</p>
<pre><code class="language-java">//使用status方法和body方法
ResponseEntity.status(HttpStatus.CREATED).body(javaBean);
//使用status方法和body方法
ResponseEntity.status(HttpStatus.BAD_REQUEST).body(null);
</code></pre>
<p>另外还可以设置响应头：</p>
<pre><code class="language-java">@GetMapping(&quot;/customHeader&quot;)
ResponseEntity&lt;String&gt; customHeader() {
    HttpHeaders headers = new HttpHeaders();
    headers.add(&quot;Custom-Header&quot;, &quot;foo&quot;);

    return new ResponseEntity&lt;&gt;(
      &quot;Custom header set&quot;, headers, HttpStatus.OK);
}
</code></pre>
<p>如果只是返回一个状态码为200的内容，可以简写为：</p>
<pre><code class="language-java">@GetMapping(&quot;/hello&quot;)
ResponseEntity&lt;String&gt; hello() {
    return ResponseEntity.ok(&quot;Hello World!&quot;);
}
</code></pre>
<p>最后强调一下：BodyBuilder.body()返回ResponseEntity ,所以需要最后调用。</p>
<h3 id="使用httpservletresponse-response"><a class="header" href="#使用httpservletresponse-response">使用HttpServletResponse response</a></h3>
<p>Spring同样支持我们使用HttpServletResponse对象来操作请求头和请求体，用法如下：</p>
<pre><code class="language-java">@GetMapping(&quot;/manual&quot;)
void manual(HttpServletResponse response) throws IOException {
    response.setHeader(&quot;Custom-Header&quot;, &quot;foo&quot;);
    response.setStatus(200);
    response.getWriter().println(&quot;Hello World!&quot;);
}
</code></pre>
<p>既然spring已经提供底层实现的抽象和附件功能，我们不建议直接操作response。</p>
<pre><code>ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
ResponseEntity.ok(list);
ResponseEntity.badRequest().build();
ResponseEntity.notFound().build();
</code></pre>
<p>上述是比较简单的两种用法，分别是500和200、400、404</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="时间戳和localdatetime和date互转和格式化"><a class="header" href="#时间戳和localdatetime和date互转和格式化">时间戳和LocalDateTime和Date互转和格式化</a></h1>
<h2 id="时间戳与localdatetime互转"><a class="header" href="#时间戳与localdatetime互转">时间戳与LocalDateTime互转</a></h2>
<h3 id="21-localdatetime-转-时间戳"><a class="header" href="#21-localdatetime-转-时间戳">2.1 LocalDateTime 转 时间戳</a></h3>
<blockquote>
</blockquote>
<p>这边值得一提的是在中国的时区偏移是8小时，本次示例转的时间戳是秒级别，得到的值是一个long值；知识追寻者这边是当前时间，故读者得到的结果与知识追寻者得到的结果不一致；读者可以使用站长工具进行测试校验 https://unixtime.51240.com/</p>
<pre><code class="language-java">class Test{
	// 方式一
	@Test
	public void localTimeTest1(){
		// 获得当前时间
		LocalDateTime localDateTime = LocalDateTime.now();
		// 将当前时间转为时间戳
		long second = localDateTime.toEpochSecond(ZoneOffset.ofHours(8));
		// 1580706475
		System.out.println(second);
	}

	// 方式二，此方法执行的结果与之前一致，也是秒级别
	@Test
	public void localTimeTest2(){
		// 获得当前时间
		LocalDateTime localDateTime = LocalDateTime.now();
		// 将当前时间转为时间戳
		long second = localDateTime.toInstant(ZoneOffset.ofHours(8)).getEpochSecond();
		// 1580707001
		System.out.println(second);
	}


	// 方式三：此方式转的将是毫秒级别，直接用于站长工具是测试不出来，读者应该将其除1000取商获得正确的秒级时间戳；
	@Test
	public void localTimeTest3(){
		// 获得当前时间
		LocalDateTime localDateTime = LocalDateTime.now();
		// 将当前时间转为时间戳
		long milliseconds = localDateTime.toInstant(ZoneOffset.ofHours(8)).toEpochMilli();
		// 1580707268
		System.out.println(milliseconds/1000);
	}
}
</code></pre>
<h3 id="22-时间戳-转localdatetime"><a class="header" href="#22-时间戳-转localdatetime">2.2 时间戳 转LocalDateTime</a></h3>
<blockquote>
<p>以下几种获取的LocalDateTime方式按读者需求进行获取，不同的精确值，将获取不同的结果；</p>
</blockquote>
<pre><code class="language-java">class Test{

    // 方式一,先获取时间戳为秒级别，然后通过转换为LocalDateTime
    @Test
    public void localTimeTest4(){
        //获得时间戳
        long second = LocalDateTime.now().toInstant(ZoneOffset.of(&quot;+8&quot;)).getEpochSecond();
        // 将时间戳转为当前时间
        LocalDateTime localDateTime = LocalDateTime.ofEpochSecond(second, 0, ZoneOffset.ofHours(8));
        // 2020-02-03T13:30:44
        System.out.println(localDateTime);

    }

    // 方式二,本次获取的时间搓将是毫秒级别故要除以1000
    @Test
    public void localTimeTest5(){
        //获得时间戳
        long milliseconds = LocalDateTime.now().toInstant(ZoneOffset.of(&quot;+8&quot;)).toEpochMilli();
        // 将时间戳转为当前时间
        LocalDateTime localDateTime = LocalDateTime.ofEpochSecond(milliseconds/1000, 0, ZoneOffset.ofHours(8));
        // 2020-02-03T13:35:53
        System.out.println(localDateTime);

    }


    // 方式三, 本方式精确值是毫秒级别，故得到的结果会存在三位小数点；
    @Test
    public void localTimeTest6(){
        //获得时间戳
        long milliseconds = LocalDateTime.now().toInstant(ZoneOffset.of(&quot;+8&quot;)).toEpochMilli();
        // 将时间戳转为当前时间
        LocalDateTime localDateTime = Instant.ofEpochMilli(milliseconds).atZone(ZoneOffset.ofHours(8)).toLocalDateTime();
        // 2020-02-03T13:38:35.799
        System.out.println(localDateTime);
    }
}
</code></pre>
<h2 id="三时间戳与localdate互转"><a class="header" href="#三时间戳与localdate互转">三、时间戳与LocalDate互转</a></h2>
<p>学会时间戳与LocalDate互转，同理就可以推出时间戳与LocalTime 互转，不过知识追寻者相信几乎没人会用到这个，故这边就不做示例；</p>
<h3 id="31-时间戳转localdate"><a class="header" href="#31-时间戳转localdate">3.1 时间戳转LocalDate</a></h3>
<pre><code class="language-java">class Test{
	// 方式一：注意这边是毫秒级的时间戳；
	@Test
	public void localDateTest1(){
        //获得时间戳
		long milliseconds = LocalDateTime.now().toInstant(ZoneOffset.of(&quot;+8&quot;)).toEpochMilli();
        // 将时间戳转为当前时间
		LocalDate localDate = Instant.ofEpochMilli(milliseconds).atZone(ZoneOffset.ofHours(8))
				.toLocalDate();
        // 2020-02-03
		System.out.println(localDate);
	}

    // 方式二：注意这边是秒级时间戳
	@Test
	public void localDateTest2(){
		//获得时间戳
		long seconds = LocalDateTime.now().toInstant(ZoneOffset.of(&quot;+8&quot;)).getEpochSecond();
		// 将时间戳转为当前时间
		LocalDate localDate = Instant.ofEpochSecond(seconds).atZone(ZoneOffset.ofHours(8)).toLocalDate();
		// 2020-02-03
		System.out.println(localDate);
	}
}
</code></pre>
<h3 id="32-localdate-转-时间戳"><a class="header" href="#32-localdate-转-时间戳">3.2 LocalDate 转 时间戳</a></h3>
<pre><code class="language-java">class Test{
	
	// 方式一:注意妙计时间戳
	@Test
	public void localDateTest3(){
		LocalDate localDate = LocalDate.now();
		//获得时间戳
		long seconds = localDate.atStartOfDay(ZoneOffset.ofHours(8)).toInstant().getEpochSecond();
		// 1580659200
		System.out.println(seconds);

	}

    // 方式二:注意毫秒级时间戳
	@Test
	public void localDateTest4(){
		LocalDate localDate = LocalDate.now();
		//获得时间戳
		long seconds = localDate.atStartOfDay(ZoneOffset.ofHours(8)).toInstant().toEpochMilli();
		// 1580659200000
		System.out.println(seconds);
	}
}
</code></pre>
<h2 id="四-localdatetime与date互转"><a class="header" href="#四-localdatetime与date互转">四 LocalDateTime与Date互转</a></h2>
<h3 id="41-date转localdatetime"><a class="header" href="#41-date转localdatetime">4.1 Date转LocalDateTime</a></h3>
<blockquote>
<p>注意避坑，如下代码，执行完毕，可以看出会有时间误差8小时的区别</p>
</blockquote>
<pre><code class="language-java">class Test {
	
	public static void main(String[] args) throws ParseException {
		DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
		String zhi=&quot;2022-11-02 00:00:00&quot;;
		Date date=dateFormat.parse(zhi);
		System.out.println(date);
		LocalDateTime dateTime=LocalDateTime.ofInstant(date.toInstant(), ZoneOffset.UTC);
		System.out.println(&quot;一个&quot;+dateTime);
		LocalDateTime dateTime1=Instant.ofEpochMilli(date.getTime()).atZone(ZoneId.of(&quot;UTC&quot;)).toLocalDateTime();
		System.out.println(&quot;这个&quot;+dateTime1);
		LocalDateTime dateTime2=date.toInstant().atOffset(ZoneOffset.ofHours(8)).toLocalDateTime();
		System.out.println(&quot;又是&quot;+dateTime2);
	}
}
</code></pre>
<p>输出结果:
Wed Nov 02 00:00:00 CST 2022
一个2022-11-01T16:00
这个2022-11-01T16:00
又是2022-11-02T00:00</p>
<pre><code class="language-java">class Test {
	// 方式一:得出结果是有小数点，毫秒级精确
	@Test
	public void DateTest1(){
		// 创建时间
		Date date = new Date();
		// 将时间转为 LocalDateTime
		LocalDateTime localDateTime = date.toInstant().atOffset(ZoneOffset.ofHours(8)).toLocalDateTime();
		// 2020-02-03T14:07:49.833
		System.out.println(localDateTime);
	}

	// 方式二:秒级精确；
	@Test
	public void DateTest2(){
		// 创建时间
		Date date = new Date();
		// 将时间转为 秒级时间戳
		long second = date.toInstant().atOffset(ZoneOffset.ofHours(8)).toEpochSecond();
		LocalDateTime localDateTime = LocalDateTime.ofEpochSecond(second, 0, ZoneOffset.ofHours(8));
		// 2020-02-03T14:11:39
		System.out.println(localDateTime);

	}
}
</code></pre>
<h3 id="42-localdatetime-转-date"><a class="header" href="#42-localdatetime-转-date">4.2 LocalDateTime 转 Date</a></h3>
<pre><code class="language-java">class Test {
	// 方式一:秒级
	@Test
	public void DateTest3(){
		//当前时间
		LocalDateTime localDateTime = LocalDateTime.now();
		// 获得 Instant
		Instant instant = Instant.ofEpochSecond(localDateTime.toEpochSecond(ZoneOffset.ofHours(8)));
		// 获得 Date
		Date date = Date.from(instant);
		// Mon Feb 03 14:16:27 CST 2020
		System.out.println(date);

	}

	// 方式二
	@Test
	public void DateTest4(){
		//当前时间
		LocalDateTime localDateTime = LocalDateTime.now();
		// 获得 Instant
		Instant instant = localDateTime.atZone(ZoneOffset.ofHours(8)).toInstant();
		// 获得 Date
		Date date = Date.from(instant);
		// Mon Feb 03 14:20:32 CST 2020
		System.out.println(date);

	}
}
</code></pre>
<h2 id="五-localdate与date互转"><a class="header" href="#五-localdate与date互转">五 LocalDate与Date互转</a></h2>
<h3 id="51-localdate-转-date"><a class="header" href="#51-localdate-转-date">5.1 LocalDate 转 Date</a></h3>
<pre><code class="language-java">class Test{
	@Test
	public void DateTest5(){
        //当前时间
		LocalDate localDate = LocalDate.now();
        // 获得 Instant
		Instant instant = localDate.atStartOfDay(ZoneOffset.ofHours(8)).toInstant();
		// 获得 Date
		Date date = Date.from(instant);
        // Mon Feb 03 00:00:00 CST 2020
		System.out.println(date);

	}
}
</code></pre>
<h3 id="52-date-转localdate"><a class="header" href="#52-date-转localdate">5.2 Date 转LocalDate</a></h3>
<pre><code class="language-java">class Test {
	@Test
	public void DateTest6(){
        // 获得 date
		Date date = new Date();
        // 获得 LocalDate
		LocalDate localDate = date.toInstant().atOffset(ZoneOffset.ofHours(8)).toLocalDate();
        // 2020-02-03
		System.out.println(localDate);
	}
}
</code></pre>
<h2 id="六-localdatetime格式化"><a class="header" href="#六-localdatetime格式化">六 LocalDateTime格式化</a></h2>
<blockquote>
<p>最后再说下格式化；知识追寻者这边就不提 LocalDateTime， LocalDate , LocalTime 互转问题，原因是前言那篇文章已经提到过；</p>
</blockquote>
<h3 id="61-localdatetime-转字符串"><a class="header" href="#61-localdatetime-转字符串">6.1 LocalDateTime 转字符串</a></h3>
<pre><code class="language-java">class Test{
	@Test
	public void format1(){
		// 获得 localDateTime
		LocalDateTime localDateTime = LocalDateTime.now();
		// 指定模式
		DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd HH/mm/ss&quot;);
		// 将 LocalDateTime 格式化为字符串
		String format = localDateTime.format(dateTimeFormatter);
		// 2020/02/03 14/38/54
		System.out.println(format);
	}
}
</code></pre>
<h3 id="62-字符串-转localdatetime"><a class="header" href="#62-字符串-转localdatetime">6.2 字符串 转LocalDateTime</a></h3>
<pre><code class="language-java">class Test{
	@Test
	public void format2(){
		String time = &quot;2020/02/03 14/38/54&quot;;
		// 指定模式
		DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd HH/mm/ss&quot;);
		// 将字符串格式化为 LocalDateTime
		LocalDateTime localDateTime = LocalDateTime.parse(time, dateTimeFormatter);
		// 2020-02-03T14:38:54
		System.out.println(localDateTime);
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ffmpeg知识"><a class="header" href="#ffmpeg知识">ffmpeg知识</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ffmpeg工具使用"><a class="header" href="#ffmpeg工具使用">ffmpeg工具使用</a></h1>
<h2 id="ffmpeg指令"><a class="header" href="#ffmpeg指令">ffmpeg指令</a></h2>
<h4 id="ffmpeg--formats"><a class="header" href="#ffmpeg--formats">ffmpeg -formats</a></h4>
<p>查看支持的视频文件格式</p>
<h4 id="ffmpeg--help"><a class="header" href="#ffmpeg--help">ffmpeg -help</a></h4>
<p>查看帮助信息</p>
<h4 id="ffmpeg--codecs"><a class="header" href="#ffmpeg--codecs">ffmpeg -codecs</a></h4>
<p>查看支持的所有编解码器</p>
<h4 id="ffmpeg--encoders"><a class="header" href="#ffmpeg--encoders">ffmpeg -encoders</a></h4>
<p>查看支持的编码器</p>
<h4 id="ffmpeg--decoders"><a class="header" href="#ffmpeg--decoders">ffmpeg -decoders</a></h4>
<p>查看支持的解码器</p>
<h4 id="ffmpeg--h-muxerflv"><a class="header" href="#ffmpeg--h-muxerflv">ffmpeg -h muxer=flv</a></h4>
<p>查看 flv 格式封装器的参数支持</p>
<h4 id="ffmpeg--h-demuxerflv"><a class="header" href="#ffmpeg--h-demuxerflv">ffmpeg -h demuxer=flv</a></h4>
<p>查看 flv 格式解封装器的参数支持</p>
<h4 id="ffmpeg--h-encoderh264"><a class="header" href="#ffmpeg--h-encoderh264">ffmpeg -h encoder=h264</a></h4>
<p>查看H.264(AVC)编码参数支持</p>
<h4 id="ffmpeg--h-decoderh264"><a class="header" href="#ffmpeg--h-decoderh264">ffmpeg -h decoder=h264</a></h4>
<p>查看H.264(AVC)解码参数支持</p>
<h4 id="ffmpeg--h-filtercolorkey"><a class="header" href="#ffmpeg--h-filtercolorkey">ffmpeg -h filter=colorkey</a></h4>
<p>查看colorkey滤镜的参数支持</p>
<h2 id="封装编码"><a class="header" href="#封装编码">封装，编码</a></h2>
<ul>
<li>通过 libavformat 库进行封装和解封装</li>
<li>通过 libavcodec 库进行编码和解码</li>
</ul>
<h2 id="例子"><a class="header" href="#例子">例子</a></h2>
<h3 id="ffmpeg--i-inputrmvb--vcodec-mpeg4--bv-200k--r-15--an-outputmp4"><a class="header" href="#ffmpeg--i-inputrmvb--vcodec-mpeg4--bv-200k--r-15--an-outputmp4"><code>ffmpeg -i input.rmvb -vcodec mpeg4 -b:v 200k -r 15 -an output.mp4</code></a></h3>
<ul>
<li>转封装格式从RMVB格式转换为MP4格式</li>
<li>视频编码从RV40转换为MPEG4格式</li>
<li>视频码率从原来的 377kbit/s转换为200kbit/s</li>
<li>视频帧率从原来的 23.98fps转换为15fps</li>
<li>转码后的文件中不包括音频(-an参数）</li>
</ul>
<h2 id="ffprobe-使用"><a class="header" href="#ffprobe-使用">ffprobe 使用</a></h2>
<h3 id="ffprobe--show_packets-1gmp4"><a class="header" href="#ffprobe--show_packets-1gmp4"><code>ffprobe -show_packets 1G.mp4</code></a></h3>
<p>查看多媒体数据包信息</p>
<h3 id="ffprobe--show_data--show_packets-1gmp4"><a class="header" href="#ffprobe--show_data--show_packets-1gmp4"><code>ffprobe -show_data -show_packets 1G.mp4</code></a></h3>
<p>组合参数查看包具体数据</p>
<h3 id="ffprobe--show_format-1gmp4"><a class="header" href="#ffprobe--show_format-1gmp4"><code>ffprobe -show_format 1G.mp4</code></a></h3>
<p>显示视频封装格式</p>
<h3 id="ffprobe--show_frames-1gmp4"><a class="header" href="#ffprobe--show_frames-1gmp4"><code>ffprobe -show_frames 1G.mp4</code></a></h3>
<p>显示视频封装的帧信息</p>
<h3 id="ffprobe--show_streams-1gmp4"><a class="header" href="#ffprobe--show_streams-1gmp4"><code>ffprobe -show_streams 1G.mp4</code></a></h3>
<p>查看多媒体文件中的流信息</p>
<ul>
<li>
<p><code>ffprobe -of xml -show_streams 1G.mp4 &gt; a.xml</code>  将格式的xml数据覆盖到a.xml中</p>
</li>
<li>
<p><code>ffprobe -of xml -show_streams 1G.mp4 &gt;&gt; b.xml</code> 将格式的xml数据追加到b.xml中</p>
</li>
<li>
<p><code>ffprobe -of ini -show_streams 1G.mp4 &gt; c.ini</code>  将格式的ini数据覆盖到c.ini中</p>
</li>
<li>
<p><code>ffprobe -of flat -show_streams 1G.mp4 &gt; d.flat</code> 将格式的flat数据覆盖到d.flat中</p>
</li>
<li>
<p><code>ffprobe -of json -show_streams 1G.mp4 &gt; e.json</code> 将格式的json数据覆盖到e.json中</p>
</li>
<li>
<p><code>ffprobe -of csv -show_streams 1G.mp4 &gt; f.csv</code> 将格式的csv数据覆盖到f.csv中</p>
</li>
</ul>
<h3 id="ffprobe--show_frames--select_streams-v--of-xml-1gmp4"><a class="header" href="#ffprobe--show_frames--select_streams-v--of-xml-1gmp4"><code>ffprobe -show_frames -select_streams v -of xml 1G.mp4</code></a></h3>
<p>使用select_streams可以只查看音频(a)、视频 (v)、 字幕（ s）的信息， 例如配合show_ frames查看视频的frames信息</p>
<ul>
<li><code>ffprobe -show_frames -select_streams v -of xml 1G.mp4 &gt; a.xml</code>  将格式的xml数据覆盖到a.xml中</li>
</ul>
<h2 id="ffplay-命令"><a class="header" href="#ffplay-命令">ffplay 命令</a></h2>
<blockquote>
<p>fplay不仅仅是播放器，同时也是测试ffmpeg的codec引擎、format引擎，以及filter引擎的工具， 并且还可以进行可视化的媒体参数分析， 其可以通过ffplay --help进行查看：</p>
</blockquote>
<p>常用参数：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">选项</th><th>说明</th><th>原文</th></tr></thead><tbody>
<tr><td style="text-align: left">-x width</td><td>强制显示宽度</td><td>.D....... Initial x coordinate. (from 0 to INT_MAX) (default 0)</td></tr>
<tr><td style="text-align: left">-y height</td><td>强制显示高度</td><td>.D....... Initial y coordinate. (from 0 to INT_MAX) (default 0)</td></tr>
<tr><td style="text-align: left">-video_size size</td><td>帧尺寸 设置显示帧存储(WxH格式)，仅适用于类似原始YUV等没有包含帧大小(WxH)的视频</td><td>.D....... A string describing frame size, such as 640x480 or hd720. (default &quot;vga&quot;)</td></tr>
<tr><td style="text-align: left">-pixel_format format</td><td>设置像素格式</td><td>.D....... set video pixel format</td></tr>
<tr><td style="text-align: left">-fs</td><td>以全屏模式启动</td><td>force full screen</td></tr>
<tr><td style="text-align: left">-an</td><td>禁用音频</td><td>disable audio</td></tr>
<tr><td style="text-align: left">-vn</td><td>禁用视频</td><td>disable video</td></tr>
<tr><td style="text-align: left">-sn</td><td>禁用字幕</td><td>diable subtitling</td></tr>
<tr><td style="text-align: left">-ss pos</td><td>根据设置的位置进行定位播放</td><td>seek to a given position in seconds</td></tr>
<tr><td style="text-align: left">-t duration</td><td>设置播放视频/音频时长</td><td>play &quot;duration&quot; seconds of audio/video</td></tr>
<tr><td style="text-align: left">-bytes val</td><td>以字节为单位进行定位播放</td><td>seek by bytes 0=off 1=on -1=auto</td></tr>
<tr><td style="text-align: left">-seek_interval interval</td><td>自定义左/右键定位拖动间隔</td><td>set seek interval for left/right keys, in seconds</td></tr>
<tr><td style="text-align: left">-nodisp</td><td>关闭图形显示，不显示视频。。。</td><td>disable graphical display</td></tr>
<tr><td style="text-align: left">-volume volume</td><td>设置起始音量</td><td>set startup volume 0=min 100=max</td></tr>
<tr><td style="text-align: left">-f fmt</td><td>强制使用指定格式解码</td><td>force format</td></tr>
<tr><td style="text-align: left">-window_title title</td><td>设置窗口标题（默认为文件名）</td><td>set window title</td></tr>
<tr><td style="text-align: left">-loop number</td><td>设置播放循环次数</td><td>set number of times the playback shall be looped</td></tr>
<tr><td style="text-align: left">-showmode mode</td><td>设置显示模式,可用的模式值: 0 显示视频,1 显示音频波形,2 显示音频频谱。缺省为0,如果视频不存在则自动选择2</td><td>select show mode (0 = video, 1 = waves, 2 = RDFT)</td></tr>
<tr><td style="text-align: left">-vf filter_graph</td><td>设置视频滤镜</td><td>set video filters</td></tr>
<tr><td style="text-align: left">-af filter_graph</td><td>设置音频滤镜</td><td>set audio filters</td></tr>
</tbody></table>
</div>
<p>高级选项 Advanced Options：</p>
<div class="table-wrapper"><table><thead><tr><th>参数</th><th>说明</th><th>原文</th></tr></thead><tbody>
<tr><td>-stats</td><td>打印回放统计信息</td><td>show status</td></tr>
<tr><td>-fast</td><td>非标准规范的多媒体兼容优化</td><td>non spec compliant optimizations</td></tr>
<tr><td>-genpts</td><td>生成pts</td><td>generate pts</td></tr>
<tr><td><strong>-sync type</strong></td><td>同步类型，默认audio为主时钟</td><td>set audio-video sync. type (type=audio/video/ext)</td></tr>
<tr><td>-ast audio_stream_specifier</td><td>指定音频流索引</td><td>select desired audio stream</td></tr>
<tr><td>-vst video_stream_specifier</td><td>指定视频流索引</td><td>select desired video stream</td></tr>
<tr><td>-sst substitle_stream_specifier</td><td>指定字幕流索引</td><td>select desired substitle stream</td></tr>
<tr><td>-autoexit</td><td>视频播放完成后自动退出</td><td>exit at the end</td></tr>
<tr><td>-exitonkeydown</td><td>键盘按下任何键退出播放</td><td>exit on key down</td></tr>
<tr><td>-exitonmousedown</td><td>鼠标按下任何键退出播放</td><td>exit on mouse down</td></tr>
<tr><td><strong>-codec:media_specifier codec_name</strong></td><td>强制使用设置的多媒体解码器, media_specifier可选值为a(audio), v(video), s(substitle)，如codec:v h264 , <em>同名</em>表示：-vcodec h264 == -c:v h264 == -codec:v h264</td><td></td></tr>
<tr><td>-acodec codec_name</td><td>强制使用设置的音频解码器进行音频解码</td><td>force audio decoder</td></tr>
<tr><td>-vcodec codec_name</td><td>强制使用设置的视频解码器进行视频解码</td><td>force video decoder</td></tr>
<tr><td>-scodec codec_name</td><td>强制使用设置的字幕解码器进行字幕解码</td><td>force subtitle decoder</td></tr>
<tr><td>-autorotate</td><td>根据文件元数据进行自动旋转</td><td>automatically rotate video</td></tr>
<tr><td>-framedrop</td><td>如果视频不同步则丢弃视频帧。当主时钟非视频时钟时默认开启。若需禁用则使用 -noframedrop</td><td>drop frames when cpu is too slow</td></tr>
<tr><td>-infbuf</td><td>不限制输入缓冲区大小。此选项将不限制缓冲区的大小。若需禁用则使用-noinfbuf</td><td>don't limit the input buffer size (useful with realtime streams)</td></tr>
</tbody></table>
</div>
<p>播放控制：</p>
<div class="table-wrapper"><table><thead><tr><th>快捷键</th><th>作用</th><th>原文</th></tr></thead><tbody>
<tr><td>q, ESC</td><td>退出</td><td>Quit.</td></tr>
<tr><td>f</td><td>全屏切换</td><td>Toggle full screen.</td></tr>
<tr><td>p, space</td><td>暂停/播放切换</td><td>Pause.</td></tr>
<tr><td>m(mute)</td><td>静音切换</td><td>Toggle mute.</td></tr>
<tr><td>9, 0</td><td>9减小音量，0增大音量</td><td>Decrease and increase volume respectively.</td></tr>
<tr><td>/, *</td><td>/减小音量，*增大音量</td><td>Decrease and increase volume respectively.</td></tr>
<tr><td>a</td><td>循环切换音频流</td><td>Cycle audio channel in the current program.</td></tr>
<tr><td>v</td><td>循环切换视频流</td><td>Cycle video channel.</td></tr>
<tr><td><em>t</em></td><td>循环切换字幕流</td><td>Cycle subtitle channel in the current program.</td></tr>
<tr><td>s</td><td>逐帧播放</td><td>Step to the next frame. Pause if the stream is not already paused, step to the next video frame, and pause.Cycle program.</td></tr>
<tr><td>c</td><td>循环切换节目</td><td>Cycle program.</td></tr>
<tr><td>w</td><td>循环切换过滤器或显示模式</td><td>Cycle video filters or show modes.</td></tr>
<tr><td>left/right</td><td>向后/向前拖动10s</td><td>Seek backward/forward 10 seconds.</td></tr>
<tr><td>down/up</td><td>向后/向前拖动1min</td><td>Seek backward/forward 1 minute.</td></tr>
<tr><td>鼠标右键单击</td><td>拖动与显示宽度对应百分比的文件进行播放</td><td>Seek to percentage in file corresponding to fraction of width.</td></tr>
<tr><td>鼠标左键双击</td><td>全屏切换</td><td>Toggle full screen.</td></tr>
<tr><td>page down/up</td><td>查找前一章/下一章。或者如果没有章节，请向后/向前寻求 10 分钟。</td><td>Seek to the previous/next chapter. or if there are no chapters Seek backward/forward 10 minutes.</td></tr>
</tbody></table>
</div>
<h3 id="ffplay---help"><a class="header" href="#ffplay---help"><code>ffplay --help</code></a></h3>
<p>获取帮助文档</p>
<h3 id="ffplay--ss-30--t-10-1gmp4"><a class="header" href="#ffplay--ss-30--t-10-1gmp4"><code>ffplay -ss 30 -t 10 1G.mp4</code></a></h3>
<p>视频的第30 秒开始播放， 播放10 秒钟的文件</p>
<h3 id="ffplayexe--window_title-8ktest--x-500--y-500--vcodec-hevc--an--vn-8kmkv"><a class="header" href="#ffplayexe--window_title-8ktest--x-500--y-500--vcodec-hevc--an--vn-8kmkv"><code>ffplay.exe -window_title &quot;8KTest&quot; -x 500 -y 500 -vcodec hevc -an -vn 8K.mkv</code></a></h3>
<p>指定宽度高度，指定编码格式，指定不播放音频不播放视频</p>
<ol>
<li>播放本地文件</li>
</ol>
<ul>
<li><code>ffplay test.flv</code></li>
<li><code>ffpaly -window_title &quot;test window&quot; test.flv</code> # 指定播放窗口名称</li>
</ul>
<ol start="2">
<li>播放网络流</li>
</ol>
<ul>
<li><code>ffplay rtmp://58.200.131.2:1935/livetv/cctv6</code></li>
</ul>
<ol start="3">
<li>禁用音频或者视频</li>
</ol>
<ul>
<li><code>ffplay -an test.flv</code> # 禁用音频</li>
<li><code>ffplay -vn test.flv</code> # 禁用视频</li>
</ul>
<ol start="4">
<li>指定解码器</li>
</ol>
<ul>
<li><code>ffplay -vcodec h264 test.flv</code> # 指定h264解码器</li>
</ul>
<ol start="5">
<li>播放YUV数据</li>
</ol>
<ul>
<li><code>ffplay -pixel_format yuv420p -video_size 1280x720 -framerate 5 1280x720_yuv420p.yuv</code></li>
</ul>
<ol start="6">
<li>播放RGB数据</li>
</ol>
<ul>
<li><code>ffplay -pixel_format rgb24 -video_size 1280x720 -framerate 5 1280x720_rgb24.rgb</code></li>
</ul>
<ol start="7">
<li>播放pcm数据</li>
</ol>
<ul>
<li><code>ffplay -ar 44100 -ac 2 -f s16le 44100_2_s16le.pcm</code></li>
</ul>
<h4 id="简单过滤器"><a class="header" href="#简单过滤器">简单过滤器</a></h4>
<ol>
<li>视频旋转</li>
</ol>
<ul>
<li><code>ffplay -i test.flv -vf transpose =1</code> # 顺时针旋转90度</li>
</ul>
<ol start="2">
<li>视频反转</li>
</ol>
<ul>
<li><code>ffplay -i test.flv -vf hflip # 以垂直中线互换左右</code></li>
<li><code>ffplay -i test.flv -vf vflip # 以水平中线互换上下</code></li>
</ul>
<ol start="3">
<li>视频旋转同时反转</li>
</ol>
<ul>
<li><code>ffplay -i test.flv -vf hflip，transpose=2</code> # 多个滤镜，相同参数，逗号间隔</li>
</ul>
<ol start="4">
<li>音频倍数播放</li>
</ol>
<ul>
<li><code>ffplay -i test.flv -af atempo=3</code></li>
</ul>
<ol start="5">
<li>视频倍数播放</li>
</ol>
<ul>
<li><code>ffplay -i test.flv -vf setpts=PTS/3</code></li>
</ul>
<ol start="6">
<li>音频与视频同时倍数</li>
</ol>
<ul>
<li><code>ffplay -i test.flv -vf setpts=PTS/3 -af atempo=3</code> # 多个滤镜，不同种类参数，空格追加</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ffmpeg示例"><a class="header" href="#ffmpeg示例">ffmpeg示例</a></h1>
<h2 id="ffmpeg--i-1gmp4-1gavi"><a class="header" href="#ffmpeg--i-1gmp4-1gavi"><code>ffmpeg -i 1G.mp4 1G.avi</code></a></h2>
<blockquote>
<p>转换视频容器</p>
</blockquote>
<ul>
<li>获得输入源 1G.mp4</li>
<li>转码</li>
<li>输出文件 1G.avi</li>
</ul>
<p>也可以使用以下命令 <code>ffmpeg -i 1G.mp4 -f avi 1G.dat</code></p>
<p><code>-f</code> 指定了输出文件的格式</p>
<p>解封装(Demuxing) =&gt; 解码(Decoding) =&gt; 编码(Encoding) =&gt; 封装📦(Muxing)</p>
<p>![test](./images/2023-07-11 20.58.20.png)</p>

                        <div id="giscus-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript" charset="utf-8">
        var pagePath = "print.md"
        </script>


        <!-- Custom JS scripts -->
        <script type="text/javascript" src="assets/custom3.js"></script>
        <script type="text/javascript" src="assets/lang.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
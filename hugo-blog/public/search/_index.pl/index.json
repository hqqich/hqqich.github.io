
            
        
        
            
        
        
            
        
        
            
        
        
            
        
        
            
        
        
            
        
        
            
        
            
        
        
            
        
            
        
        
            
        
        
        
            
        
        
        
        
        
        
        
        
        
        
        
        
            
        
        
            
        
            
        
        
            
        
        
            
        
        
        
        [{"categories":[],"content":"在 Windows 系统中，你可以通过配置路由表来实现将特定子网的流量转发到指定的网关。以下是具体步骤：\n查看当前路由表 在配置之前，你可以先查看当前的路由表，确保没有冲突的路由规则。\nroute print 添加特定子网的路由规则\n你需要添加两条路由规则：\n将 172.22.168.x 的流量转发到 172.12.169.124\n其他流量转发到 192.168.1.1\n添加 172.22.168.x 的路由规则 假设 172.22.168.x 是 172.12.168.0/24 子网，你可以使用以下命令：\nroute add 172.12.168.0 mask 255.255.255.0 172.12.169.1 metric 1 添加默认路由规则 默认情况下，所有其他流量都会通过默认网关转发。你可以将默认网关设置为 192.168.1.1：\nroute add 0.0.0.0 mask 0.0.0.0 192.168.1.1 metric 1 注意：如果默认网关已经设置为 172.22.169.124 或其他地址，你需要先删除现有的默认路由，然后再添加新的默认路由。\n删除默认路由的命令： route delete 0.0.0.0 然后再添加新的默认路由： route add 0.0.0.0 mask 0.0.0.0 192.168.1.1 metric 1 验证路由表 再次查看路由表，确保新添加的路由规则已经生效：\nroute print 持久化路由规则（可选） 上述命令添加的路由规则在系统重启后会丢失。如果你希望这些规则在重启后仍然有效，可以使用 -p 参数来持久化路由规则。\n例如：\nroute -p add 172.22.168.0 mask 255.255.255.0 172.12.169.124 metric 1 route -p add 0.0.0.0 mask 0.0.0.0 192.168.1.1 metric 1 测试网络连接 最后，测试你的网络连接，确保 172.22.168.x 的流量通过 172.12.169.124 转发，而其他流量通过 192.168.1.1 转发。\n你可以使用 tracert 命令来跟踪路由路径：\ntracert 172.12.168.1 tracert 8.8.8.8 注意事项 确保 172.22.169.124 和 192.168.1.1 是可达的，并且它们分别能够正确处理相应的流量。\n如果你有多个网卡，确保路由规则中的网关与正确的网卡关联。\n通过以上步骤，你应该能够成功配置 Windows 的路由表，实现特定子网的流量转发。\n","permalink":"https://gohugo.io/hugo-blog/public/post/dev-log/windows%E5%A4%9A%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C/","tags":[{"LinkTitle":"网络","RelPermalink":"/hugo-blog/public/tags/%E7%BD%91%E7%BB%9C/"}],"title":"windows多网络操作"},{"categories":[],"content":"在 GitHub Actions 的 workflow 文件中，你可以在 steps 中使用 curl 命令调用 API 接口。以下是一个完整的示例，展示如何在 GitHub Actions 的 workflow 中使用 curl：\n示例：使用 curl 调用 API name: Call API with curl on: push: branches: [ main ] workflow_dispatch: jobs: call-api: runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v4 - name: Call API using curl run: | # 示例：调用一个公开的API（如JSONPlaceholder） response=$(curl -s -X GET \u0026#34;https://jsonplaceholder.typicode.com/posts/1\u0026#34;) echo \u0026#34;API Response: $response\u0026#34; # 如果需要传递请求头（如Content-Type或Authorization） # response_with_header=$(curl -s -X GET \\ # -H \u0026#34;Content-Type: application/json\u0026#34; \\ # -H \u0026#34;Authorization: Bearer ${{ secrets.API_TOKEN }}\u0026#34; \\ # \u0026#34;https://api.example.com/data\u0026#34;) # echo \u0026#34;Response with headers: $response_with_header\u0026#34; # 如果需要发送POST请求 # post_response=$(curl -s -X POST \\ # -H \u0026#34;Content-Type: application/json\u0026#34; \\ # -d \u0026#39;{\u0026#34;key\u0026#34;: \u0026#34;value\u0026#34;}\u0026#39; \\ # \u0026#34;https://api.example.com/create\u0026#34;) # echo \u0026#34;POST Response: $post_response\u0026#34; 关键点说明： run 指令：在 steps 中使用 run 执行 shell 命令（如 curl）。 请求方法： -X GET：GET 请求（默认可以省略）。 -X POST：POST 请求。 请求头： -H \u0026quot;Content-Type: application/json\u0026quot;：设置请求头。 -H \u0026quot;Authorization: Bearer ${{ secrets.API_TOKEN }}\u0026quot;：使用 GitHub Secrets 传递敏感信息（如 API Token）。 请求体： -d '{\u0026quot;key\u0026quot;: \u0026quot;value\u0026quot;}'：发送 JSON 格式的请求体。 静默模式： -s：禁止 curl 输出进度或错误信息（适合日志干净的场景）。 输出响应： 将响应保存到变量（如 response=$(curl ...)）或直接打印。 高级用法： 处理响应状态码：\n- name: Check API status run: | status_code=$(curl -s -o /dev/null -w \u0026#34;%{http_code}\u0026#34; \u0026#34;https://api.example.com/health\u0026#34;) echo \u0026#34;Status Code: $status_code\u0026#34; if [ \u0026#34;$status_code\u0026#34; -ne 200 ]; then echo \u0026#34;API call failed!\u0026#34; exit 1 fi 使用 jq 解析 JSON 响应（需先安装）：\n- name: Parse JSON response run: | sudo apt-get install -y jq # 安装jq response=$(curl -s \u0026#34;https://jsonplaceholder.typicode.com/posts/1\u0026#34;) title=$(echo \u0026#34;$response\u0026#34; | jq -r \u0026#39;.title\u0026#39;) echo \u0026#34;Title: $title\u0026#34; 注意事项： 网络权限：GitHub Actions 默认允许出站流量，但某些 API 可能需要配置 IP 白名单。 超时处理：默认情况下，GitHub Actions 的 run 命令超时为 6 小时，但建议显式设置 curl 超时： curl --max-time 10 ... # 10秒超时 错误处理：如果 curl 失败（非 2xx 状态码），默认会返回非零退出码，导致步骤失败。 完整示例（带错误处理）： - name: Call API with error handling run: | if ! response=$(curl -s -f -X GET \u0026#34;https://api.example.com/data\u0026#34;); then echo \u0026#34;API call failed with status: $?\u0026#34; exit 1 fi echo \u0026#34;Success: $response\u0026#34; 通过以上方式，你可以在 GitHub Actions 中灵活调用 API 并处理响应。\n","permalink":"https://gohugo.io/hugo-blog/public/post/dev-log/github-action/","tags":[{"LinkTitle":"Sql","RelPermalink":"/hugo-blog/public/tags/sql/"}],"title":"在 github-workflows   steps 中，使用curl调用接口"},{"categories":[],"content":"遇到的问题 数据库乱码问题\n测试模块 RPC 远程调用返回的结果为:\n测试结果：{\u0026#34;activity\u0026#34;:{\u0026#34;activityDesc\u0026#34;:\u0026#34;?????????\u0026#34;,\u0026#34;activityId\u0026#34;:100002,\u0026#34;activityName\u0026#34;:\u0026#34;????\u0026#34;,\u0026#34;beginDateTime\u0026#34;:1705215282000,\u0026#34;endDateTime\u0026#34;:1705215282000,\u0026#34;stockCount\u0026#34;:100,\u0026#34;takeCount\u0026#34;:10},\u0026#34;result\u0026#34;:{\u0026#34;code\u0026#34;:\u0026#34;0000\u0026#34;,\u0026#34;info\u0026#34;:\u0026#34;成功\u0026#34;}} 明显的乱码问题，查看数据库，发现插入的时候就以及乱码了，看了一下配置文件中的数据库连接 url，发现使用了 useUnicode=true，并没有指定字符集，所以添加一下 utf-8 字符集即可，完整 url: jdbc:mysql://127.0.0.1:3306/lottery?useUnicode=true\u0026amp;characterEncoding=UTF-8\n再进行一轮测试，测试结果：\n测试结果：{\u0026#34;activity\u0026#34;:{\u0026#34;activityDesc\u0026#34;:\u0026#34;仅用于插入数据测试\u0026#34;,\u0026#34;activityId\u0026#34;:100003,\u0026#34;activityName\u0026#34;:\u0026#34;测试活动\u0026#34;,\u0026#34;beginDateTime\u0026#34;:1705218054000,\u0026#34;endDateTime\u0026#34;:1705218054000,\u0026#34;stockCount\u0026#34;:100,\u0026#34;takeCount\u0026#34;:10},\u0026#34;result\u0026#34;:{\u0026#34;code\u0026#34;:\u0026#34;0000\u0026#34;,\u0026#34;info\u0026#34;:\u0026#34;成功\u0026#34;}} ","permalink":"https://gohugo.io/hugo-blog/public/post/dev-log/day01/","tags":[{"LinkTitle":"Sql","RelPermalink":"/hugo-blog/public/tags/sql/"}],"title":"day01"},{"categories":[],"content":"3.1、MYSQL 存储过程中的关键语法 # 将语句的结束符号从分号;临时改为两个$$(可以是自定义)，其中，使用命令delimiter ; 将语句的结束符号恢复为分号。 # 1、声明语句结束符，可以自定义: DELIMITER $$ 或 DELIMITER // # 2、声明存储过程: CREATE PROCEDURE demo_in_parameter(IN p_in int) # 3、存储过程开始和结束符号: BEGIN .... END # 4、变量赋值: SET @p_in=1 # 5、变量定义: DECLARE l_int int unsigned default 0; # 6、创建mysql存储过程、存储函数: create procedure 存储过程名(参数) # 7、存储过程体: create function 存储函数名(参数) 3.2、存储过程的案例 解析：默认情况下，存储过程和默认数据库相关联，如果想指定存储过程创建在某个特定的数据库下，那么在过程名前面加数据库名做前缀。 在定义过程时，使用 DELIMITER 命令将语句的结束符号从分号;临时改为两个 ，使得过程体中使用的分号被直接传递到服务器，而不会被客户端（如mysql）解释。\n1 mysql\u0026gt; delimiter $$　# 将语句的结束符号从分号;临时改为两个$$(可以是自定义)。 2 mysql\u0026gt; CREATE PROCEDURE delete_matches(IN p_playerno INTEGER) 3 -\u0026gt; BEGIN 4 -\u0026gt; DELETE FROM MATCHES 5 -\u0026gt; WHERE playerno = p_playerno; 6 -\u0026gt; END$$ 7 Query OK, 0 rows affected (0.01 sec) 8 9 mysql\u0026gt; delimiter;　# 将语句的结束符号恢复为分号。 3.3、调用存储过程： 解析：在存储过程中设置了需要传参的变量p_playerno，调用存储过程的时候，通过传参将57赋值给p_playerno，然后进行存储过程里的SQL操作。\n1 call sp_name[(传参)]; 调用存储过程的案例，如下所示： 1 mysql\u0026gt; select * from MATCHES; 2 +---------+--------+----------+-----+------+ 3 | MATCHNO | TEAMNO | PLAYERNO | WON | LOST | 4 +---------+--------+----------+-----+------+ 5 | 1 | 1 | 6 | 3 | 1 | 6 | 7 | 1 | 57 | 3 | 0 | 7 | 8 | 1 | 8 | 0 | 3 | 8 | 9 | 2 | 27 | 3 | 2 | 9 | 11 | 2 | 112 | 2 | 3 | 10 +---------+--------+----------+-----+------+ 11 5 rows in set (0.00 sec) 12 13 mysql\u0026gt; call delete_matches(57); 14 Query OK, 1 row affected (0.03 sec) 15 16 mysql\u0026gt; select * from MATCHES; 17 +---------+--------+----------+-----+------+ 18 | MATCHNO | TEAMNO | PLAYERNO | WON | LOST | 19 +---------+--------+----------+-----+------+ 20 | 1 | 1 | 6 | 3 | 1 | 21 | 8 | 1 | 8 | 0 | 3 | 22 | 9 | 2 | 27 | 3 | 2 | 23 | 11 | 2 | 112 | 2 | 3 | 24 +---------+--------+----------+-----+------+ 25 4 rows in set (0.00 sec) 3.4、存储过程体 存储过程体包含了在过程调用时必须执行的语句，例如：dml、ddl语句，if-then-else和while-do语句、声明变量的declare语句等。　过程体格式：以begin开始，以end结束(可嵌套)。\nBEGIN BEGIN BEGIN statements; END END END 注意：每个嵌套块及其中的每条语句，必须以分号结束，表示过程体结束的begin-end块(又叫做复合语句compound statement)，则不需要分号。\n3.5、为语句块贴标签： 标签有两个作用：\n1）、增强代码的可读性。\n2）、在某些语句(例如:leave和iterate语句)，需要用到标签。\n[begin_label:] BEGIN [statement_list] END [end_label] 例如：\nlabel1: BEGIN label2: BEGIN label3: BEGIN statements; END label3 ; END label2; END label1 4、存储过程的参数 MySQL存储过程的参数用在存储过程的定义，共有三种参数类型，IN、OUT、INOUT，形式如：\nCREATE PROCEDURE 存储过程名([[IN |OUT |INOUT ] 参数名 数据类形...]) 如果过程没有参数，也必须在过程名后面写上小括号例：\nCREATE PROCEDURE sp_name ([proc_parameter[,...]]) …… 确保参数的名字不等于列的名字，否则在过程体中，参数名被当做列名来处理。\n4.1、IN输入参数 IN 输入参数：表示调用者向过程传入值（传入值可以是字面量或变量），默认是IN输入参数，如果不填写，就是默认的IN输入参数。\n# 以下可以看出，p_in 在存储过程中被修改，但并不影响 @p_in 的值，因为前者为局部变量、后者为全局变量。 mysql\u0026gt; delimiter $$ mysql\u0026gt; create procedure in_param(in p_in int) -\u0026gt; begin -\u0026gt; select p_in; -\u0026gt; set p_in=2; -\u0026gt; select P_in; -\u0026gt; end$$ mysql\u0026gt; delimiter ; mysql\u0026gt; set @p_in=1; mysql\u0026gt; call in_param(@p_in); +------+ | p_in | +------+ | 1 | +------+ +------+ | P_in | +------+ | 2 | +------+ mysql\u0026gt; select @p_in; +-------+ | @p_in | +-------+ | 1 | +-------+ 4.2、OUT输出参数 OUT 输出参数：表示过程向调用者传出值(可以返回多个值)（传出值只能是变量）。\nmysql\u0026gt; delimiter // mysql\u0026gt; create procedure out_param(out p_out int) -\u0026gt; begin -\u0026gt; select p_out; -\u0026gt; set p_out=2; -\u0026gt; select p_out; -\u0026gt; end -\u0026gt; // mysql\u0026gt; delimiter ; mysql\u0026gt; set @p_out=1; mysql\u0026gt; call out_param(@p_out); +-------+ | p_out | +-------+ | NULL | +-------+ #因为out是向调用者输出参数，不接收输入的参数，所以存储过程里的p_out为null +-------+ | p_out | +-------+ | 2 | +-------+ mysql\u0026gt; select @p_out; +--------+ | @p_out | +--------+ | 2 | +--------+ #调用了out_param存储过程，输出参数，改变了p_out变量的值 4.3、INOUT 输入输出参数 INOUT 输入输出参数：既表示调用者向过程传入值，又表示过程向调用者传出值（值只能是变量）。\nmysql\u0026gt; delimiter $$ mysql\u0026gt; create procedure inout_param(inout p_inout int) -\u0026gt; begin -\u0026gt; select p_inout; -\u0026gt; set p_inout=2; -\u0026gt; select p_inout; -\u0026gt; end -\u0026gt; $$ mysql\u0026gt; delimiter ; mysql\u0026gt; set @p_inout=1; mysql\u0026gt; call inout_param(@p_inout); +---------+ | p_inout | +---------+ | 1 | +---------+ +---------+ | p_inout | +---------+ | 2 | +---------+ mysql\u0026gt; select @p_inout; +----------+ | @p_inout | +----------+ | 2 | +----------+ #调用了inout_param存储过程，接受了输入的参数，也输出参数，改变了变量 5、存储过程声明变量 1）、用户变量名一般以@开头。\n2）、滥用用户变量会导致程序难以理解及管理。\n5.1、变量定义 局部变量声明一定要放在存储过程体的开始：\nDECLARE variable_name [,variable_name...] datatype [DEFAULT value]; 其中，datatype 为 MySQL 的数据类型，如: int, float, date,varchar(length)，例如：\nDECLARE l_int int unsigned default 4000000; DECLARE l_numeric number(8,2) DEFAULT 9.95; DECLARE l_date date DEFAULT \u0026#39;1999-12-31\u0026#39;; DECLARE l_datetime datetime DEFAULT \u0026#39;1999-12-31 23:59:59\u0026#39;; DECLARE l_varchar varchar(255) DEFAULT \u0026#39;This will not be padded\u0026#39;; 5.2、变量赋值 SET 变量名 = 表达式值 [,variable_name = expression ...] 5.3、用户变量 在MySQL客户端使用用户变量：\nmysql \u0026gt; SELECT \u0026#39;Hello World\u0026#39; into @x; mysql \u0026gt; SELECT @x; +-------------+ | @x | +-------------+ | Hello World | +-------------+ mysql \u0026gt; SET @y=\u0026#39;Goodbye Cruel World\u0026#39;; mysql \u0026gt; SELECT @y; +---------------------+ | @y | +---------------------+ | Goodbye Cruel World | +---------------------+ mysql \u0026gt; SET @z=1+2+3; mysql \u0026gt; SELECT @z; +------+ | @z | +------+ | 6 | +------+ 在存储过程中使用用户变量：\nmysql \u0026gt; CREATE PROCEDURE GreetWorld( ) SELECT CONCAT(@greeting,\u0026#39; World\u0026#39;); mysql \u0026gt; SET @greeting=\u0026#39;Hello\u0026#39;; mysql \u0026gt; CALL GreetWorld( ); +----------------------------+ | CONCAT(@greeting,\u0026#39; World\u0026#39;) | +----------------------------+ | Hello World | +----------------------------+ 在存储过程间传递全局范围的用户变量：\nmysql\u0026gt; CREATE PROCEDURE p1() SET @last_procedure=\u0026#39;p1\u0026#39;; mysql\u0026gt; CREATE PROCEDURE p2() SELECT CONCAT(\u0026#39;Last procedure was \u0026#39;,@last_procedure); mysql\u0026gt; CALL p1( ); mysql\u0026gt; CALL p2( ); +-----------------------------------------------+ | CONCAT(\u0026#39;Last procedure was \u0026#39;,@last_proc | +-----------------------------------------------+ | Last procedure was p1 | +-----------------------------------------------+ 6、存储过程的注释 MySQL 存储过程可使用两种风格的注释。　两个横杆\u0026ndash;：该风格一般用于单行注释。\nc 风格： 一般用于多行注释。\nmysql \u0026gt; DELIMITER // mysql \u0026gt; CREATE PROCEDURE proc1 -- name存储过程名 -\u0026gt; (IN parameter1 INTEGER) -\u0026gt; BEGIN -\u0026gt; DECLARE variable1 CHAR(10); -\u0026gt; IF parameter1 = 17 THEN -\u0026gt; SET variable1 = \u0026#39;birds\u0026#39;; -- 使用SET进行变量赋值，知识点很重要。 -\u0026gt; ELSE -\u0026gt; SET variable1 = \u0026#39;beasts\u0026#39;; -\u0026gt; END IF; -\u0026gt; INSERT INTO table1 VALUES (variable1); -\u0026gt; END -\u0026gt; // mysql \u0026gt; DELIMITER ; 7、存储过程的查询、修改、删除、调用控制 7.1、MySQL存储过程的调用 用call和你过程名以及一个括号，括号里面根据需要，加入参数，参数包括输入参数、输出参数、输入输出参数。具体的调用方法可以参看上面的例子。\n7.2、MySQL存储过程的查询 我们像知道一个数据库下面有那些表，我们一般采用 show tables; 进行查看。那么我们要查看某个数据库下面的存储过程，是否也可以采用呢？答案是，我们可以查看某个数据库下面的存储过程，但是是另一钟方式。\n我们可以用以下语句进行查询：\nselect name from mysql.proc where db=\u0026#39;数据库名\u0026#39;; 或者 select routine_name from information_schema.routines where routine_schema=\u0026#39;数据库名\u0026#39;; 或者 show procedure status where db=\u0026#39;数据库名\u0026#39;; 如果我们想知道，某个存储过程的详细，那我们又该怎么做呢？是不是也可以像操作表一样用describe 表名进行查看呢？\n答案是：我们可以查看存储过程的详细，但是需要用另一种方法：SHOW CREATE PROCEDURE 数据库.存储过程名;就可以查看当前存储过程的详细。\n7.3、MySQL存储过程的调用 ALTER PROCEDURE 更改用 CREATE PROCEDURE 建立的预先指定的存储过程，其不会影响相关存储过程或存储功能。\n7.4、MySQL存储过程的调用 删除一个存储过程比较简单，和删除表一样：\nDROP PROCEDURE 从 MySQL 的表格中删除一个或多个存储过程。\n8、MySQL存储过程的控制语句 8.1、变量作用域 内部的变量在其作用域范围内享有更高的优先权，当执行到 end。变量时，内部变量消失，此时已经在其作用域外，变量不再可见了，应为在存储过程外再也不能找到这个申明的变量，但是你可以通过 out 参数或者将其值指派给会话变量来保存其值。\nmysql \u0026gt; DELIMITER // mysql \u0026gt; CREATE PROCEDURE proc3() -\u0026gt; begin -\u0026gt; declare x1 varchar(5) default \u0026#39;outer\u0026#39;; -\u0026gt; begin -\u0026gt; declare x1 varchar(5) default \u0026#39;inner\u0026#39;; -\u0026gt; select x1; -\u0026gt; end; -\u0026gt; select x1; -\u0026gt; end; -\u0026gt; // mysql \u0026gt; DELIMITER ; 8.2、条件语句，if-then-else 语句 mysql \u0026gt; DELIMITER // mysql \u0026gt; CREATE PROCEDURE proc2(IN parameter int) -\u0026gt; begin -\u0026gt; declare var int; -\u0026gt; set var=parameter+1; -\u0026gt; if var=0 then -\u0026gt; insert into t values(17); -\u0026gt; end if; -\u0026gt; if parameter=0 then -\u0026gt; update t set s1=s1+1; -\u0026gt; else -\u0026gt; update t set s1=s1+2; -\u0026gt; end if; -\u0026gt; end; -\u0026gt; // mysql \u0026gt; DELIMITER ; 8.3、条件语句，case语句： 使用的语法，如下所示：\ncase when var=0 then insert into t values(30); when var\u0026gt;0 then when var\u0026lt;0 then else end case 使用的案例，如下所示：\nmysql \u0026gt; DELIMITER // mysql \u0026gt; CREATE PROCEDURE proc3 (in parameter int) -\u0026gt; begin -\u0026gt; declare var int; -\u0026gt; set var=parameter+1; -\u0026gt; case var -\u0026gt; when 0 then -\u0026gt; insert into t values(17); -\u0026gt; when 1 then -\u0026gt; insert into t values(18); -\u0026gt; else -\u0026gt; insert into t values(19); -\u0026gt; end case; -\u0026gt; end; -\u0026gt; // mysql \u0026gt; DELIMITER ; 8.4、循环语句while ···· end while 使用的语法，如下所示：\nwhile 条件 do --循环体 end while 使用的案例，如下所示：\nmysql \u0026gt; DELIMITER // mysql \u0026gt; CREATE PROCEDURE proc4() -\u0026gt; begin -\u0026gt; declare var int; -\u0026gt; set var=0; -\u0026gt; while var\u0026lt;6 do -\u0026gt; insert into t values(var); -\u0026gt; set var=var+1; -\u0026gt; end while; -\u0026gt; end; -\u0026gt; // mysql \u0026gt; DELIMITER ; 8.5、循环语句repeat···· end repeat 它在执行操作后检查结果，而 while 则是执行前进行检查。\n使用的语法，如下所示：\nrepeat --循环体 until 循环条件 end repeat; 使用的案例，如下所示：\nmysql \u0026gt; DELIMITER // mysql \u0026gt; CREATE PROCEDURE proc5 () -\u0026gt; begin -\u0026gt; declare v int; -\u0026gt; set v=0; -\u0026gt; repeat -\u0026gt; insert into t values(v); -\u0026gt; set v=v+1; -\u0026gt; until v\u0026gt;=5 -\u0026gt; end repeat; -\u0026gt; end; -\u0026gt; // mysql \u0026gt; DELIMITER ; 8.6、循环语句loop ·····endloop loop 循环不需要初始条件，这点和 while 循环相似，同时和 repeat 循环一样不需要结束条件, leave 语句的意义是离开循环。\nmysql \u0026gt; DELIMITER // mysql \u0026gt; CREATE PROCEDURE proc6 () -\u0026gt; begin -\u0026gt; declare v int; -\u0026gt; set v=0; -\u0026gt; LOOP_LABLE:loop -\u0026gt; insert into t values(v); -\u0026gt; set v=v+1; -\u0026gt; if v \u0026gt;=5 then -\u0026gt; leave LOOP_LABLE; -\u0026gt; end if; -\u0026gt; end loop; -\u0026gt; end; -\u0026gt; // mysql \u0026gt; DELIMITER ; 8.7、循环语句LABLES 标号： 标号可以用在 begin repeat while 或者 loop 语句前，语句标号只能在合法的语句前面使用。可以跳出循环，使运行指令达到复合语句的最后一步。\nITERATE 通过引用复合语句的标号,来从新开始复合语句:\nmysql \u0026gt; DELIMITER // mysql \u0026gt; CREATE PROCEDURE proc10 () -\u0026gt; begin -\u0026gt; declare v int; -\u0026gt; set v=0; -\u0026gt; LOOP_LABLE:loop -\u0026gt; if v=3 then -\u0026gt; set v=v+1; -\u0026gt; ITERATE LOOP_LABLE; -\u0026gt; end if; -\u0026gt; insert into t values(v); -\u0026gt; set v=v+1; -\u0026gt; if v\u0026gt;=5 then -\u0026gt; leave LOOP_LABLE; -\u0026gt; end if; -\u0026gt; end loop; -\u0026gt; end; -\u0026gt; // mysql \u0026gt; DELIMITER ; ","permalink":"https://gohugo.io/hugo-blog/public/post/mysql/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/","tags":[{"LinkTitle":"Sql","RelPermalink":"/hugo-blog/public/tags/sql/"}],"title":"mysql存储过程"},{"categories":[],"content":"我们用three.js可以绘制出各种酷炫的画面，但是当我们想要一个更加真实的物理效果的话，这个时候我们就需要一个物理的库，接下来我们就讲解一下今天要学习的canon，它可以给我们提供一个更加真实的物理效果，像物体的张力、摩擦力、拉伸、反弹等等各种真实的物理效果。该库都能够有一个非常好的模拟。\nPS：目前博主在一家互联网公司工作，该公司的编码风格是vue+tsx ，所以接下来的项目以该编码风格进行举例，详细了解参考我之前的文章：地址 。\ncanon基本使用 Cannon 是一种轻量级 的 JavaScript 3D 物理引擎，用于实现虚拟世界中的物理模拟和交互。它提供了一套强大的功能，能够处理刚体碰撞、力学模拟、约束系统等物理效果，使开发者能够在 Web 应用程序和游戏中实现逼真的物理行为。\nCannon的官网：地址 ，提供了一系列关于物理运动在three世界的实现，实现案例 的效果非常直观，展示了物理运动的魅力，如下：\nTest for external image 接下来我们在three.js的vue项目 中使用Cannon，终端执行如下命令安装，具体参考：官网 `npm i cannon-es` 接下来我们通过tsx风格语法撰写three基础项目实现：\nimport { defineComponent } from \u0026#34;vue\u0026#34;; import * as THREE from \u0026#39;three\u0026#39; import { OrbitControls } from \u0026#39;three/examples/jsm/controls/OrbitControls.js\u0026#39; import * as CANNON from \u0026#39;cannon-es\u0026#39; import \u0026#39;./index.scss\u0026#39; import { div } from \u0026#34;three/examples/jsm/nodes/Nodes.js\u0026#34;; export default defineComponent({ setup() { // 初始化物理世界 const world = new CANNON.World() // 初始化物理世界的重力 world.gravity.set(0, -9.82, 0) // 初始化3D世界 const scene = new THREE.Scene() // 初始化相机 const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000) camera.position.z = 3 // 初始化渲染器 const renderer = new THREE.WebGLRenderer({ antialias: true }) renderer.setSize(window.innerWidth, window.innerHeight) document.body.appendChild(renderer.domElement) // 初始化控制器 const controls = new OrbitControls(camera, renderer.domElement) controls.enableDamping = true // 渲染 let clock = new THREE.Clock() const animate = () =\u0026gt; { let delta = clock.getDelta() controls.update() renderer.render(scene, camera) requestAnimationFrame(animate) } animate() return () =\u0026gt; { \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; } } }) 接下来我们需要给场景添加一些物体，如下：\n// 创建一个物理球体，半径为0.5 const sphereShape = new CANNON.Sphere(0.5) // 创建一个刚体 const sphereBody = new CANNON.Body({ mass: 1, shape: sphereShape, position: new CANNON.Vec3(0, 5, 0) }) // 将刚体添加到物理世界中 world.addBody(sphereBody) // 物理世界创建的东西不显示，所以我们要再通过three.js再创建一个球 const sphereGeometry = new THREE.SphereGeometry(0.5, 32, 32) // 创建一个几何体 const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 }) // 创建一个球体材质 const shpereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial) // 创建一个球体网格 // 将网格添加到3D场景中 scene.add(shpereMesh) 打开控制台，可以看到我们的球体已经显示出来了：\n接下来我们要把物理世界的球体给到我们three渲染出来的球体，让两者开始关联起来。在每一帧中，根据物理引擎模拟的结果来更新 Three.js 场景中球体网格的位置和旋转状态，从而实现了基于物理引擎的球体模拟效果，如下：\n得到的结果如下：\n基础碰撞使用 上面我们实现了一个物体的自由下落，接下来我们实现物体与平面的碰撞效果。如下添加平面：\n// 创建一个物理世界的平面 const planeShape = new CANNON.Plane() // 创建一个刚体 const planeBody = new CANNON.Body({ mass: 0, // 设置质量为0，不受碰撞的影响 shape: planeShape, position: new CANNON.Vec3(0, 0, 0) }) // 设置刚体旋转（设置旋转X轴） planeBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2) // 将刚体添加到物理世界当中 world.addBody(planeBody) // 物理世界创建的东西不显示，所以我们要再通过three.js再创建一个平面 const planeGeometry = new THREE.PlaneGeometry(10, 10) // 因为渲染的东西不是无限衍生，这里给10x10 // 创建一个平面材质 const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 }) // 创建一个平面网格 const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial) // 旋转平面90度让其平铺 planeMesh.rotation.x = -Math.PI / 2 // 将网格添加到3D场景当中 scene.add(planeMesh) 当然除了我们设置平面质量为0之外，我们也可以设置平面为静态效果，也不受碰撞影响：\n最终得到的效果如下:\n那我们让物理世界和渲染世界的平面倾斜度加上0.1，小球是否会滑落而掉下去呢？测试一下：\n得到的效果如下，可见小球是不会掉落下去的，因为物理世界的平面是无限衍生的，即使渲染世界的平面有限，小球仍然会走物理世界的规律，如下：\n如果我们想在物理世界有一个有限大的平面的话， 我们可以通过构建一个立方体，然后把立方体压扁形成一个平面来使用，因为立方体已经有高度了，所以我们也不需要在旋转90度了，稍微给点倾斜度0.1即可，代码如下：\n得到的效果如下，可见到我们的小球已经实现了掉落的效果：\n上面两标题的案例代码如下：\nimport { defineComponent } from \u0026#34;vue\u0026#34;; import * as THREE from \u0026#39;three\u0026#39; import { OrbitControls } from \u0026#39;three/examples/jsm/controls/OrbitControls.js\u0026#39; import * as CANNON from \u0026#39;cannon-es\u0026#39; import \u0026#39;./index.scss\u0026#39; export default defineComponent({ setup() { // 初始化物理世界 const world = new CANNON.World() // 初始化物理世界的重力 world.gravity.set(0, -9.82, 0) // 初始化3D世界 const scene = new THREE.Scene() // 初始化相机 const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000) camera.position.z = 3 // 初始化渲染器 const renderer = new THREE.WebGLRenderer({ antialias: true }) renderer.setSize(window.innerWidth, window.innerHeight) document.body.appendChild(renderer.domElement) // 初始化控制器 const controls = new OrbitControls(camera, renderer.domElement) controls.enableDamping = true // 创建一个物理球体，半径为0.5 const sphereShape = new CANNON.Sphere(0.5) // 创建一个刚体 const sphereBody = new CANNON.Body({ mass: 1, shape: sphereShape, position: new CANNON.Vec3(0, 5, 0) }) // 将刚体添加到物理世界中 world.addBody(sphereBody) // 物理世界创建的东西不显示，所以我们要再通过three.js再创建一个球 const sphereGeometry = new THREE.SphereGeometry(0.5, 32, 32) // 创建一个几何体 const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 }) // 创建一个球体材质 const shpereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial) // 创建一个球体网格 // 将网格添加到3D场景中 scene.add(shpereMesh) // 创建一个物理世界的平面 // const planeShape = new CANNON.Plane() const planeShape = new CANNON.Box(new CANNON.Vec3(5, 0.1, 5)) // 创建一个刚体 const planeBody = new CANNON.Body({ // mass: 0, // 设置质量为0，不受碰撞的影响 shape: planeShape, position: new CANNON.Vec3(0, 0, 0), type: CANNON.Body.STATIC // 设置物体为静态，不受碰撞的影响 }) // 设置刚体旋转（设置旋转X轴） planeBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), 0.1) // 将刚体添加到物理世界当中 world.addBody(planeBody) // 物理世界创建的东西不显示，所以我们要再通过three.js再创建一个平面 // const planeGeometry = new THREE.PlaneGeometry(10, 10) // 因为渲染的东西不是无限衍生，这里给10x10 const planeGeometry = new THREE.BoxGeometry(10, 0.2, 10) // 创建一个平面材质 const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 }) // 创建一个平面网格 const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial) // 旋转平面90度让其平铺 planeMesh.rotation.x = 0.1 // 将网格添加到3D场景当中 scene.add(planeMesh) // 渲染 let clock = new THREE.Clock() const animate = () =\u0026gt; { // 获取了两次渲染之间的时间差，通常用于控制动画和物理模拟。 let delta = clock.getDelta() // 使用时间差来推进物理世界的模拟 world.step(delta) // 更新球体网格的位置和旋转 // 将物理引擎中球体的位置赋值给 Three.js 中球体网格（shpereMesh）的位置，从而将物理模拟的结果更新到可视化场景中。 shpereMesh.position.copy(sphereBody.position) // 将物理引擎中球体的旋转状态赋值给 Three.js 中球体网格（shpereMesh）的旋转状态，确保网格的旋转与物理模拟一致。 shpereMesh.quaternion.copy(sphereBody.quaternion) controls.update() renderer.render(scene, camera) requestAnimationFrame(animate) } animate() return () =\u0026gt; { \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; } } }) 材质与摩擦系数设置 cannon的材质可以模拟我们现实生活当中的物理的效果，比如说我们可以设置它的摩擦系数，弹性系数来实现我们这个物体的滑动的有摩擦的效果。借助上面的案例，我们将球体换成立方体，因为要创建多个立方体，这里我们设置一个变量用于存储\n// 创建网格数组 let phyMeshes: any[] = [] // 物理世界 let meshes: any[] = [] // 渲染世界 // 创建物理立方体 const boxShape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)) // 设置立方体的材质 const boxMaterialCon = new CANNON.Material(\u0026#34;boxMaterial\u0026#34;) // 创建一个刚体 const boxBody = new CANNON.Body({ shape: boxShape, position: new CANNON.Vec3(0, 15, 0), mass: 1, material: boxMaterialCon }) // 将刚体添加到物理世界当中 world.addBody(boxBody) phyMeshes.push(boxBody) // 创建立方体几何体 const boxGeometry = new THREE.BoxGeometry(1, 1, 1) // 创建立方体材质 const boxMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 }) // 创建立方体网格 const boxMesh = new THREE.Mesh(boxGeometry, boxMaterial) // 将网格添加到3D场景当中 scene.add(boxMesh) meshes.push(boxMesh) 在渲染函数处，我们变量数组来推进物理世界模拟：\n最终得到是效果如下：\n接下来我们添加第二个物体，将第二个物体的摩擦系数设置为0，第一个物体和平面的摩擦系数设置为0.7，代码如下：\n// 创建网格数组 let phyMeshes: any[] = [] // 物理世界 let meshes: any[] = [] // 渲染世界 // 创建物理立方体 const boxShape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)) // 设置立方体的材质 const boxMaterialCon = new CANNON.Material(\u0026#34;boxMaterial\u0026#34;) boxMaterialCon.friction = 0.7 // 创建一个刚体 const boxBody = new CANNON.Body({ shape: boxShape, position: new CANNON.Vec3(0, 15, 0), mass: 1, material: boxMaterialCon }) // 将刚体添加到物理世界当中 world.addBody(boxBody) phyMeshes.push(boxBody) // 创建立方体几何体 const boxGeometry = new THREE.BoxGeometry(1, 1, 1) // 创建立方体材质 const boxMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 }) // 创建立方体网格 const boxMesh = new THREE.Mesh(boxGeometry, boxMaterial) // 将网格添加到3D场景当中 scene.add(boxMesh) meshes.push(boxMesh) // 创建第二个物理立方体（使用第一个物理立方体的内容，材质不同） const boxSlipperyMaterial = new CANNON.Material(\u0026#34;boxSlipperyMaterial\u0026#34;) boxSlipperyMaterial.friction = 0 // 摩擦系数为0 // 创建刚体 const boxBody2 = new CANNON.Body({ shape: boxShape, position: new CANNON.Vec3(1, 5, 0), // 区别于第一个物体，位置改变一下 mass: 1, material: boxSlipperyMaterial }) // 将刚体添加到物理世界当中 world.addBody(boxBody2) phyMeshes.push(boxBody2) // 创建立方体几何体（使用第一个物体的内容） const boxMesh2 = new THREE.Mesh(boxGeometry, boxMaterial) // 将网格添加到3D场景当中 scene.add(boxMesh2) meshes.push(boxMesh2) // 创建一个物理世界的平面 // const planeShape = new CANNON.Plane() const planeShape = new CANNON.Box(new CANNON.Vec3(5, 0.1, 5)) // 创建一个刚体 const planeBody = new CANNON.Body({ // mass: 0, // 设置质量为0，不受碰撞的影响 shape: planeShape, position: new CANNON.Vec3(0, 0, 0), type: CANNON.Body.STATIC, // 设置物体为静态，不受碰撞的影响 material: boxMaterialCon }) // 设置刚体旋转（设置旋转X轴） planeBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), 0.1) // 将刚体添加到物理世界当中 world.addBody(planeBody) // 物理世界创建的东西不显示，所以我们要再通过three.js再创建一个平面 // const planeGeometry = new THREE.PlaneGeometry(10, 10) // 因为渲染的东西不是无限衍生，这里给10x10 const planeGeometry = new THREE.BoxGeometry(10, 0.2, 10) // 创建一个平面材质 const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 }) // 创建一个平面网格 const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial) // 旋转平面90度让其平铺 planeMesh.rotation.x = 0.1 // 将网格添加到3D场景当中 scene.add(planeMesh) 最终得到的效果如下，可以看到我们设置的第二个物体因为很光滑，所以很容易就滑落下去：\n弹性与接触材质设置 上文我们介绍了摩擦效果的操作，接下来我们继续开始讲解物体的弹性操作，我们根据上文的代码，再创建第三个立方体，然后给该立方体添加弹性系数\n// 创建第三个物理立方体（使用第一个物理立方体的内容，材质不同） const boxBouncyMaterial = new CANNON.Material(\u0026#34;boxBouncyMaterial\u0026#34;) boxBouncyMaterial.friction = 0.1 boxBouncyMaterial.restitution = 1 // 设置弹性系数为1 // 创建刚体 const boxBody3 = new CANNON.Body({ shape: boxShape, mass: 1, position: new CANNON.Vec3(2, 5, 3), material: boxBouncyMaterial }) // 将刚体添加到物理世界当中 world.addBody(boxBody3) phyMeshes.push(boxBody3) // 创建几何体（使用第一个立方体的内容以及材质） const boxMesh3 = new THREE.Mesh(boxGeometry, boxMaterial) // 添加网格 // 将网格添加到3D场景当中 scene.add(boxMesh3) meshes.push(boxMesh3) 给立方体设置弹性系数之后，如果我们想让弹性效果奏效的话，我们也需要给平面网格设置相同的弹性系数，因为平面网格使用的材质是第一个立方体的材质，所以我们只要给第一个立方体设置弹性系数即可，如下：\n最终得到的效果如下，可以看到设置高度高的物体，从高处下落反弹的效果是很直观的：\n当然我们也没有必要单独设置一下立方体和平面的弹性和摩擦系数，我们也可以通过接触材质的系数设置两个材质之间的一个弹性和摩擦系数，来实现相应的效果，如下：\n// 创建第三个物理立方体（使用第一个物理立方体的内容，材质不同） const boxBouncyMaterial = new CANNON.Material(\u0026#34;boxBouncyMaterial\u0026#34;) // boxBouncyMaterial.friction = 0.1 // boxBouncyMaterial.restitution = 1 // 设置弹性系数为1 // 创建刚体 const boxBody3 = new CANNON.Body({ shape: boxShape, mass: 1, position: new CANNON.Vec3(2, 5, 3), material: boxBouncyMaterial }) // 将刚体添加到物理世界当中 world.addBody(boxBody3) phyMeshes.push(boxBody3) // 创建几何体（使用第一个立方体的内容以及材质） const boxMesh3 = new THREE.Mesh(boxGeometry, boxMaterial) // 添加网格 // 将网格添加到3D场景当中 scene.add(boxMesh3) meshes.push(boxMesh3) // 定义接触材质 const material3toplane = new CANNON.ContactMaterial( boxMaterialCon, boxBouncyMaterial, { friction: 0, restitution: 1 } ) // 将接触材质添加到物理世界当中 world.addContactMaterial(material3toplane) 最终呈现的效果依然很明显：\n碰撞与碰撞组 Cannon中的碰撞指的是游戏开发中物体之间的相互作用，通常包括物体之间的碰撞检测和碰撞响应两个部分。碰撞检测用于判断物体是否发生了碰撞，而碰撞响应则是在发生碰撞时对物体进行相应的处理，比如改变物体的速度、方向等。如下我们设置代码来实现：\n依次创建立方体、球体、圆柱体到场景当中，举例代码如下：\n接下来我们给创建到场景的立方体添加一个初速度使其运动来碰撞另外两个物体，如下：\n这里给出完整的代码来给大家进行学习：\nimport { defineComponent } from \u0026#34;vue\u0026#34;; import * as THREE from \u0026#39;three\u0026#39; import { OrbitControls } from \u0026#39;three/examples/jsm/controls/OrbitControls.js\u0026#39; import * as CANNON from \u0026#39;cannon-es\u0026#39; import \u0026#39;./index.scss\u0026#39; export default defineComponent({ setup() { // 初始化物理世界 const world = new CANNON.World() // 初始化物理世界的重力 world.gravity.set(0, -9.82, 0) // 初始化3D世界 const scene = new THREE.Scene() // 初始化相机 const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000) camera.position.z = 8 camera.position.y = 5 camera.position.x = 2 // 初始化渲染器 const renderer = new THREE.WebGLRenderer({ antialias: true }) renderer.setSize(window.innerWidth, window.innerHeight) document.body.appendChild(renderer.domElement) // 初始化控制器 const controls = new OrbitControls(camera, renderer.domElement) controls.enableDamping = true // 创建网格数组 let phyMeshes: any[] = [] // 物理世界 let meshes: any[] = [] // 渲染世界 // 创建物理立方体 const boxShape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)) // 设置立方体的材质 const boxMaterialCon = new CANNON.Material(\u0026#34;boxMaterial\u0026#34;) boxMaterialCon.friction = 0 // 创建一个刚体 const boxBody = new CANNON.Body({ shape: boxShape, position: new CANNON.Vec3(2, 0.8, 0), mass: 1, material: boxMaterialCon }) // 将刚体添加到物理世界当中 world.addBody(boxBody) phyMeshes.push(boxBody) // 创建立方体几何体 const boxGeometry = new THREE.BoxGeometry(1, 1, 1) // 创建立方体材质 const boxMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 }) // 创建立方体网格 const boxMesh = new THREE.Mesh(boxGeometry, boxMaterial) // 将网格添加到3D场景当中 scene.add(boxMesh) meshes.push(boxMesh) // 创建物理球 const spereShape = new CANNON.Sphere(0.5) // 创建一个刚体 const sphereBody = new CANNON.Body({ shape: spereShape, position: new CANNON.Vec3(0, 0.8, 0), mass: 1, material: boxMaterialCon }) // 将刚体添加到物理世界当中 world.addBody(sphereBody) phyMeshes.push(sphereBody) // 创建球的几何体 const sphereGeometry = new THREE.SphereGeometry(0.5, 32, 32) // 创建球的材质 const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff }) // 创建球网格 const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial) // 将网格添加到3D场景当中 scene.add(sphereMesh) meshes.push(sphereMesh) // 创建物理圆柱体 const cylinderShape = new CANNON.Cylinder(0.5, 0.5, 1, 32) // 创建一个刚体 const cylinderBody = new CANNON.Body({ shape: cylinderShape, position: new CANNON.Vec3(-2, 0.8, 0), mass: 1, material: boxMaterialCon }) // 将刚体添加到物理世界当中 world.addBody(cylinderBody) phyMeshes.push(cylinderBody) // 创建圆柱体几何体 const cylinderGeometry = new THREE.CylinderGeometry(0.5 ,0.5, 1, 32) // 创建圆柱体材质 const cylinderMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }) // 创建圆柱体网格 const cylinderMesh = new THREE.Mesh(cylinderGeometry, cylinderMaterial) // 将网格添加到3D场景当中 scene.add(cylinderMesh) meshes.push(cylinderMesh) // 创建一个物理世界的平面 // const planeShape = new CANNON.Plane() const planeShape = new CANNON.Box(new CANNON.Vec3(5, 0.1, 5)) // 创建一个刚体 const planeBody = new CANNON.Body({ // mass: 0, // 设置质量为0，不受碰撞的影响 shape: planeShape, position: new CANNON.Vec3(0, 0, 0), type: CANNON.Body.STATIC, // 设置物体为静态，不受碰撞的影响 material: boxMaterialCon }) // 设置刚体旋转（设置旋转X轴） // planeBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), 0.1) // 将刚体添加到物理世界当中 world.addBody(planeBody) // 物理世界创建的东西不显示，所以我们要再通过three.js再创建一个平面 // const planeGeometry = new THREE.PlaneGeometry(10, 10) // 因为渲染的东西不是无限衍生，这里给10x10 const planeGeometry = new THREE.BoxGeometry(10, 0.2, 10) // 创建一个平面材质 const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 }) // 创建一个平面网格 const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial) // 旋转平面90度让其平铺 // planeMesh.rotation.x = 0.1 // 将网格添加到3D场景当中 scene.add(planeMesh) // 设置立方体的初始速度 boxBody.velocity.set(-2, 0, 0) // 渲染 let clock = new THREE.Clock() const animate = () =\u0026gt; { // 获取了两次渲染之间的时间差，通常用于控制动画和物理模拟。 let delta = clock.getDelta() world.step(delta) // 使用时间差来推进物理世界的模拟 for(let i = 0; i \u0026lt; phyMeshes.length; i++) { meshes[i].position.copy(phyMeshes[i].position) meshes[i].quaternion.copy(phyMeshes[i].quaternion) } controls.update() renderer.render(scene, camera) requestAnimationFrame(animate) } animate() return () =\u0026gt; { \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; } } }) 接下来实现碰撞组，碰撞组是为了更高效地管理和处理碰撞而引入的概念。通过将具有相似碰撞特性的物体分组，可以在碰撞检测和碰撞响应时只考虑同一组内的物体之间的碰撞，从而减少不必要的计算量，提高游戏的性能和效率。代码如下：\n我们设置立方体为组1，然后碰撞掩码就是能够和谁发生碰撞，我们设置立方体可以和所有物体碰撞：\n在球体的分组当中，我们设置碰撞掩码如下，可以看到我们的球不能碰撞圆柱体：\n最终呈现的效果如下：\n给出案例的完整代码供大家学习：\nimport { defineComponent } from \u0026#34;vue\u0026#34;; import * as THREE from \u0026#39;three\u0026#39; import { OrbitControls } from \u0026#39;three/examples/jsm/controls/OrbitControls.js\u0026#39; import * as CANNON from \u0026#39;cannon-es\u0026#39; import \u0026#39;./index.scss\u0026#39; export default defineComponent({ setup() { // 初始化物理世界 const world = new CANNON.World() // 初始化物理世界的重力 world.gravity.set(0, -9.82, 0) // 初始化3D世界 const scene = new THREE.Scene() // 初始化相机 const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000) camera.position.z = 8 camera.position.y = 5 camera.position.x = 2 // 初始化渲染器 const renderer = new THREE.WebGLRenderer({ antialias: true }) renderer.setSize(window.innerWidth, window.innerHeight) document.body.appendChild(renderer.domElement) // 初始化控制器 const controls = new OrbitControls(camera, renderer.domElement) controls.enableDamping = true // 创建网格数组 let phyMeshes: any[] = [] // 物理世界 let meshes: any[] = [] // 渲染世界 // 设置碰撞组，数值要用2的幂 const GROUP1 = 1 // 分组立方体 const GROUP2 = 2 // 分组球体 const GROUP3 = 4 // 分组圆柱体 const GROUP4 = 8 // 分组平面 // 创建物理立方体 const boxShape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)) // 设置立方体的材质 const boxMaterialCon = new CANNON.Material(\u0026#34;boxMaterial\u0026#34;) boxMaterialCon.friction = 0 // 创建一个刚体 const boxBody = new CANNON.Body({ shape: boxShape, position: new CANNON.Vec3(2, 0.8, 0), mass: 1, material: boxMaterialCon, collisionFilterGroup: GROUP1, // 设置碰撞组 collisionFilterMask: GROUP2 | GROUP3 | GROUP4, // 碰撞掩码，可以和二组和三、四组碰撞 }) // 将刚体添加到物理世界当中 world.addBody(boxBody) phyMeshes.push(boxBody) // 创建立方体几何体 const boxGeometry = new THREE.BoxGeometry(1, 1, 1) // 创建立方体材质 const boxMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 }) // 创建立方体网格 const boxMesh = new THREE.Mesh(boxGeometry, boxMaterial) // 将网格添加到3D场景当中 scene.add(boxMesh) meshes.push(boxMesh) // 创建物理球 const spereShape = new CANNON.Sphere(0.5) // 创建一个刚体 const sphereBody = new CANNON.Body({ shape: spereShape, position: new CANNON.Vec3(0, 0.8, 0), mass: 1, material: boxMaterialCon, collisionFilterGroup: GROUP2, // 设置碰撞组 collisionFilterMask: GROUP1 | GROUP4, // 碰撞掩码，可以和一、四组碰撞 }) // 将刚体添加到物理世界当中 world.addBody(sphereBody) phyMeshes.push(sphereBody) // 创建球的几何体 const sphereGeometry = new THREE.SphereGeometry(0.5, 32, 32) // 创建球的材质 const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff }) // 创建球网格 const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial) // 将网格添加到3D场景当中 scene.add(sphereMesh) meshes.push(sphereMesh) // 创建物理圆柱体 const cylinderShape = new CANNON.Cylinder(0.5, 0.5, 1, 32) // 创建一个刚体 const cylinderBody = new CANNON.Body({ shape: cylinderShape, position: new CANNON.Vec3(-2, 0.8, 0), mass: 1, material: boxMaterialCon, collisionFilterGroup: GROUP3, // 设置碰撞组 collisionFilterMask: GROUP1 | GROUP4, // 碰撞掩码，可以和一、四组碰撞 }) // 将刚体添加到物理世界当中 world.addBody(cylinderBody) phyMeshes.push(cylinderBody) // 创建圆柱体几何体 const cylinderGeometry = new THREE.CylinderGeometry(0.5 ,0.5, 1, 32) // 创建圆柱体材质 const cylinderMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }) // 创建圆柱体网格 const cylinderMesh = new THREE.Mesh(cylinderGeometry, cylinderMaterial) // 将网格添加到3D场景当中 scene.add(cylinderMesh) meshes.push(cylinderMesh) // 创建一个物理世界的平面 // const planeShape = new CANNON.Plane() const planeShape = new CANNON.Box(new CANNON.Vec3(5, 0.1, 5)) // 创建一个刚体 const planeBody = new CANNON.Body({ // mass: 0, // 设置质量为0，不受碰撞的影响 shape: planeShape, position: new CANNON.Vec3(0, 0.1, 0), type: CANNON.Body.STATIC, // 设置物体为静态，不受碰撞的影响 material: boxMaterialCon, collisionFilterGroup: GROUP4, // 设置碰撞组 collisionFilterMask: GROUP1 | GROUP2 | GROUP3, // 碰撞掩码，可以和一组、二组和三组碰撞 }) // 设置刚体旋转（设置旋转X轴） // planeBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), 0.1) // 将刚体添加到物理世界当中 world.addBody(planeBody) // 物理世界创建的东西不显示，所以我们要再通过three.js再创建一个平面 // const planeGeometry = new THREE.PlaneGeometry(10, 10) // 因为渲染的东西不是无限衍生，这里给10x10 const planeGeometry = new THREE.BoxGeometry(10, 0.2, 10) // 创建一个平面材质 const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 }) // 创建一个平面网格 const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial) // 旋转平面90度让其平铺 // planeMesh.rotation.x = 0.1 // 将网格添加到3D场景当中 scene.add(planeMesh) // 设置立方体的初始速度 boxBody.velocity.set(-2, 0, 0) // 渲染 let clock = new THREE.Clock() const animate = () =\u0026gt; { // 获取了两次渲染之间的时间差，通常用于控制动画和物理模拟。 let delta = clock.getDelta() world.step(delta) // 使用时间差来推进物理世界的模拟 for(let i = 0; i \u0026lt; phyMeshes.length; i++) { meshes[i].position.copy(phyMeshes[i].position) meshes[i].quaternion.copy(phyMeshes[i].quaternion) } controls.update() renderer.render(scene, camera) requestAnimationFrame(animate) } animate() return () =\u0026gt; { \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; } } }) ","permalink":"https://gohugo.io/hugo-blog/public/post/threejs/three.js--%E6%8E%A2%E5%AF%BBcannon.js%E6%9E%84%E5%BB%BA%E9%9C%87%E6%92%BC%E7%9A%843d%E7%89%A9%E7%90%86%E4%BA%A4%E4%BA%92%E4%BD%93%E9%AA%8C%E4%B8%80/","tags":[{"LinkTitle":"Sql","RelPermalink":"/hugo-blog/public/tags/sql/"}],"title":"Three.js--》探寻Cannon.js构建震撼的3D物理交互体验（一）"},{"categories":[],"content":"一、为什么选择 Three.js？ Three.js 是基于 WebGL 的轻量级 3D 引擎，无需复杂的数学计算即可实现：\n3D 模型渲染 动画与交互 物理引擎集成 高性能可视化 对比原生 WebGL：Three.js 封装了 90% 以上的底层代码，开发效率提升 80%！\n二、环境搭建 方案一：\n\u0026lt;!-- 引入Three.js最新版 --\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/three@0.158.0/build/three.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 引入辅助工具 --\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/three@0.158.0/examples/js/controls/OrbitControls.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/three@0.158.0/examples/js/libs/stats.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 注意：Three.js 在较新的版本中对模块的引入方式进行了调整，直接通过\u0026lt;script\u0026gt;标签引入的加载方式可能会出现问题。\n方案二：在项目中使用\n安装Three.js `npm install three` 引入Three.js库 // 引入 Three.js 核心库 import * as THREE from \u0026#39;three\u0026#39;; // 引入轨道控制器 import { OrbitControls } from \u0026#39;three/examples/jsm/controls/OrbitControls.js\u0026#39;; // 引入性能监控工具 import Stats from \u0026#39;three/examples/jsm/libs/stats.module.js\u0026#39;; 核心三要素：\n// 场景 const scene = new THREE.Scene(); // 相机（透视投影） const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000); // 渲染器 const renderer = new THREE.WebGLRenderer(); renderer.setSize(window.innerWidth, window.innerHeight); document.body.appendChild(renderer.domElement); 三、核心组件详解（含性能优化 ） 1. 几何体 // 基础几何体 const geometry = new THREE.BoxGeometry(); // 立方体 const geometry = new THREE.SphereGeometry(5, 32, 32); // 球体 // 复杂几何体 import { OBJLoader } from \u0026#39;three/addons/loaders/OBJLoader.js\u0026#39;; const loader = new OBJLoader(); loader.load(\u0026#39;model.obj\u0026#39;, function(object) { scene.add(object); }); 2. 材质 性能优化方案：\n// 使用MeshStandardMaterial替代MeshPhongMaterial const material = new THREE.MeshStandardMaterial({ color: 0x00ff00, metalness: 0.5, roughness: 0.3 }); // 实例化材质池（适用于大规模场景） const materialPool = new THREE.InstancedMesh(geometry, material, 1000); 3. 灯光 // 环境光 const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // 平行光（模拟太阳光） const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); directionalLight.position.set(5, 10, 10); 四、动画与交互实现 1. 基础动画 function animate() { requestAnimationFrame(animate); // 旋转动画 cube.rotation.x += 0.01; cube.rotation.y += 0.01; renderer.render(scene, camera); } animate(); 2. 鼠标交互 // 射线检测 const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2(); document.addEventListener(\u0026#39;mousemove\u0026#39;, function(event) { mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; }); function onMouseClick(event) { raycaster.setFromCamera(mouse, camera); const intersects = raycaster.intersectObjects(scene.children); if (intersects.length \u0026gt; 0) { intersects[0].object.material.color.set(0xff0000); } } 五、性能优化指南（提升 50% 渲染效率） 减少 Draw Call： // 使用InstancedMesh替代多次add() const instancedMesh = new THREE.InstancedMesh(geometry, material, 1000); scene.add(instancedMesh); 层级优化： // 合并静态模型 import { BufferGeometryUtils } from \u0026#39;three/addons/utils/BufferGeometryUtils.js\u0026#39;; const mergedGeometry = BufferGeometryUtils.mergeBufferGeometries(geometries); 材质缓存： const materialCache = new Map(); function getMaterial(type) { if (!materialCache.has(type)) { materialCache.set(type, new THREE.MeshStandardMaterial({ ... })); } return materialCache.get(type); } 六、常见问题解决方案 1. 模型加载异常 // 加载进度监听 loader.load(\u0026#39;model.obj\u0026#39;, function(object) { scene.add(object); }, function(xhr) { console.log((xhr.loaded / xhr.total * 100) + \u0026#39;% loaded\u0026#39;); }, function(error) { console.error(\u0026#39;加载失败:\u0026#39;, error); }); 2. 内存泄漏检测 // 使用Stats.js监控性能 const stats = new Stats(); document.body.appendChild(stats.dom); function updateStats() { stats.begin(); // 渲染逻辑 stats.end(); requestAnimationFrame(updateStats); } 完整代码\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Three.js Quick Start\u0026lt;/title\u0026gt; \u0026lt;!-- 引入Three.js最新版 --\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/three@0.158.0/build/three.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 引入辅助工具 --\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/three@0.158.0/examples/js/controls/OrbitControls.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/three@0.158.0/examples/js/libs/stats.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 场景 const scene = new THREE.Scene(); // 相机（透视投影） const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.z = 5; // 渲染器 const renderer = new THREE.WebGLRenderer(); renderer.setSize(window.innerWidth, window.innerHeight); document.body.appendChild(renderer.domElement); // 几何体 const geometry = new THREE.BoxGeometry(); // 材质 const material = new THREE.MeshStandardMaterial({ color: 0x00ff00, metalness: 0.5, roughness: 0.3 }); // 网格对象 const cube = new THREE.Mesh(geometry, material); scene.add(cube); // 灯光 // 环境光 const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); scene.add(ambientLight); // 平行光（模拟太阳光） const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); directionalLight.position.set(5, 10, 10); scene.add(directionalLight); // 轨道控制器 const controls = new THREE.OrbitControls(camera, renderer.domElement); // 性能监控 const stats = new Stats(); document.body.appendChild(stats.dom); // 射线检测 const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2(); document.addEventListener(\u0026#39;mousemove\u0026#39;, function (event) { mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; }); document.addEventListener(\u0026#39;click\u0026#39;, function (event) { raycaster.setFromCamera(mouse, camera); const intersects = raycaster.intersectObjects(scene.children); if (intersects.length \u0026gt; 0) { intersects[0].object.material.color.set(0xff0000); } }); // 动画函数 function animate() { requestAnimationFrame(animate); // 旋转动画 cube.rotation.x += 0.01; cube.rotation.y += 0.01; renderer.render(scene, camera); stats.update(); } animate(); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 七、实战项目推荐 3D 产品展示：使用 GLB 格式模型 + 轨道控制器 数据可视化：通过 BufferGeometry 生成自定义几何体 虚拟现实：配合 WebVR 插件实现沉浸式体验 八、学习资源推荐 官方文档 示例库 社区论坛 ","permalink":"https://gohugo.io/hugo-blog/public/post/threejs/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-three.js%E4%BB%8E-0-%E5%88%B0-1-%E6%9E%84%E5%BB%BA-3d-%E5%8F%AF%E8%A7%86%E5%8C%96%E9%A1%B9%E7%9B%AE/","tags":[{"LinkTitle":"Three.js","RelPermalink":"/hugo-blog/public/tags/three.js/"}],"title":"快速上手 Three.js：从 0 到 1 构建 3D 可视化项目"},{"categories":[{"LinkTitle":"A Category with Slug","RelPermalink":"/hugo-blog/public/categories/with-slug/"}],"content":" Photo by Behnam Norouzi on Unsplash\nTest for external image Test for svg ","permalink":"https://gohugo.io/hugo-blog/public/post/i18n-blog/image-process/","tags":[{"LinkTitle":"CustomTag","RelPermalink":"/hugo-blog/public/tags/custom/"}],"title":"Image Process"},{"categories":[{"LinkTitle":"Themes","RelPermalink":"/hugo-blog/public/categories/themes/"},{"LinkTitle":"Syntax","RelPermalink":"/hugo-blog/public/categories/syntax/"}],"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae.Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese List with checkbox Create a Hugo site Add content Add a style Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://gohugo.io/hugo-blog/public/post/i18n-blog/markdown-syntax/","tags":[{"LinkTitle":"Markdown","RelPermalink":"/hugo-blog/public/tags/markdown/"},{"LinkTitle":"Css","RelPermalink":"/hugo-blog/public/tags/css/"},{"LinkTitle":"Html","RelPermalink":"/hugo-blog/public/tags/html/"},{"LinkTitle":"Tag1","RelPermalink":"/hugo-blog/public/tags/tag1/"},{"LinkTitle":"Tag2","RelPermalink":"/hugo-blog/public/tags/tag2/"}],"title":"Markdown Syntax Guide"},{"categories":[],"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nBiliBili Simple Shortcode Asciinema Embed Shortcode Local Shortcode ","permalink":"https://gohugo.io/hugo-blog/public/post/i18n-blog/rich-content/","tags":[{"LinkTitle":"Shortcodes","RelPermalink":"/hugo-blog/public/tags/shortcodes/"},{"LinkTitle":"Privacy","RelPermalink":"/hugo-blog/public/tags/privacy/"}],"title":"Rich Content"},{"categories":[],"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon Mane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","permalink":"https://gohugo.io/hugo-blog/public/post/i18n-blog/placeholder-text/","tags":[{"LinkTitle":"Markdown","RelPermalink":"/hugo-blog/public/tags/markdown/"},{"LinkTitle":"Text","RelPermalink":"/hugo-blog/public/tags/text/"}],"title":"Placeholder Text"},{"categories":[],"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX Create a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions Examples Inline math: \\(\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…\\) Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","permalink":"https://gohugo.io/hugo-blog/public/post/i18n-blog/math-typesetting/","tags":[],"title":"Math Typesetting"},{"categories":[],"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes .\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","permalink":"https://gohugo.io/hugo-blog/public/post/i18n-blog/emoji-support/","tags":[{"LinkTitle":"Emoji","RelPermalink":"/hugo-blog/public/tags/emoji/"}],"title":"Emoji Support"},{"categories":[],"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\nhttps://github.com/yuin/goldmark https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremely fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub .\n","permalink":"https://gohugo.io/hugo-blog/public/about/","tags":[],"title":"About"},{"categories":[],"content":"","permalink":"https://gohugo.io/hugo-blog/public/manifest.json","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://gohugo.io/hugo-blog/public/search/_index.de/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://gohugo.io/hugo-blog/public/search/_index.es/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://gohugo.io/hugo-blog/public/search/_index.fr/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://gohugo.io/hugo-blog/public/search/_index.hi/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://gohugo.io/hugo-blog/public/search/_index.jp/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://gohugo.io/hugo-blog/public/search/_index.nl/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://gohugo.io/hugo-blog/public/search/_index.pl/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://gohugo.io/hugo-blog/public/search/_index.ru/","tags":[],"title":""},{"categories":[{"LinkTitle":"自定义 Slug 的分类","RelPermalink":"/hugo-blog/public/zh-cn/categories/with-slug/"}],"content":" Photo by Behnam Norouzi on Unsplash\nTest for external image Test for svg ","permalink":"https://gohugo.io/hugo-blog/public/zh-cn/post/i18n-blog/image-process/","tags":[{"LinkTitle":"随便一个标签","RelPermalink":"/hugo-blog/public/zh-cn/tags/custom/"}],"title":"图片处理"},{"categories":[{"LinkTitle":"Themes","RelPermalink":"/hugo-blog/public/zh-cn/categories/themes/"},{"LinkTitle":"Syntax","RelPermalink":"/hugo-blog/public/zh-cn/categories/syntax/"}],"content":"本文档提供可用于 Hugo 内容文件的基本 Markdown 语法示例，并且还展示了 Hugo 主题中是否用 CSS 修饰了 HTML 基本元素。\n标题 以下 HTML \u0026lt;h1\u0026gt;-\u0026lt;h6\u0026gt; 元素表示六个级别的分节标题。 \u0026lt;h1\u0026gt; 是最高级别分节标题，而 \u0026lt;h6\u0026gt; 是最低级别分节标题。\nH1 H2 H3 H4 H5 H6 段落 Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\n块引用 blockquote 元素表示从另一个资源引用的内容，可能带有一个在 footer 或 cite 元素内的引用，或者带有诸如注释和缩写之类的行内更改。\n没有归属的块引用 Tiam, ad mint andaepu dandae nostion secatur sequo quae.请注意在代码块中可以使用 Markdown 语法。\n带有归属的块引用 不要通过共享内存进行通信，而是通过通信共享内存。\nRob Pike[^1] [^1] 上述引用摘自 Rob Pike 于 2015 年 11 月 18 日在 Gopherfest 期间进行的 演讲 。\n表格 表格不是核心 Markdown 规范的一部分，但 Hugo 开箱即用地支持表格。\nName Age Bob 27 Alice 23 表格中的行内 Markdown 斜体 粗体 代码 斜体 粗体 代码 代码块 带反引号的代码块 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 用四个空格缩进的代码块 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 带有 Hugo 内部高亮短代码的代码块 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 列表类型 有序列表 第一个项目 第二个项目 第三个项目 无序列表 项目一 项目二 项目三 嵌套列表 水果 苹果 橙子 香蕉 乳制品 牛奶 奶酪 带有复选框的列表 创建 Hugo 网站 添加内容 添加样式 其他元素 - abbr、sub、sup、kbd、mark GIF 是一种位图图像格式。\nH2O\nXn + Yn = Zn\n按 CTRL+ALT+Delete 结束会话。\n大多数 火蜥蜴 在夜间活动，并捕食昆虫、蠕虫和其他小型生物。\n","permalink":"https://gohugo.io/hugo-blog/public/zh-cn/post/i18n-blog/markdown-syntax/","tags":[{"LinkTitle":"Markdown","RelPermalink":"/hugo-blog/public/zh-cn/tags/markdown/"},{"LinkTitle":"Css","RelPermalink":"/hugo-blog/public/zh-cn/tags/css/"},{"LinkTitle":"Html","RelPermalink":"/hugo-blog/public/zh-cn/tags/html/"},{"LinkTitle":"Tag1","RelPermalink":"/hugo-blog/public/zh-cn/tags/tag1/"},{"LinkTitle":"Tag2","RelPermalink":"/hugo-blog/public/zh-cn/tags/tag2/"}],"title":"Markdown语法指导"},{"categories":[],"content":"在 Hugo 项目中，可以通过使用第三方 JavaScript 库来启用数学符号。\n在本示例中，我们将使用 KaTeX 在 /layouts/partials/math.html 下创建一个局部文件 在此局部文件中引用 自动渲染扩展名 或在本地托管这些脚本。 以以下方式在模板中包含局部文件： {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} 要在全局启用 KaTeX，请在项目的配置中将参数 math 设置为 true 要逐页启用 KaTeX，请在内容文件中包含参数 math: true **注意：**使用 Supported TeX Functions 的在线参考\n示例 行内数学：\\( arphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…\\) 块级数学： $$ arphi = 1+\frac{1} {1+\frac{1} {1+\frac{1} {1+\\cdots} } } $$\n","permalink":"https://gohugo.io/hugo-blog/public/zh-cn/post/i18n-blog/math-typesetting/","tags":[],"title":"数学符号"},{"categories":[],"content":"可以在一个 Hugo 项目中通过多种方式启用 Emoji。\nemojify 函数可以被直接在模板或 Inline Shortcodes 中调用。\n若要全局启用 emoji，在你的网站的 配置 中将 enableEmoji 设置为 true，然后你就可以直接在内容文件中输入 emoji 的简写代码；例如：\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nEmoji 速查表 是 emoji 简写代码的有用参考。\n注 上述步骤可以在 Hugo 中启用 Unicode 标准的 emoji 字符和序列，但是这些字形的呈现取决于浏览器和平台。要给 emoji 设置样式，你可以使用第三方 emoji 字体或字体堆栈；例如：\n.emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","permalink":"https://gohugo.io/hugo-blog/public/zh-cn/post/i18n-blog/emoji-support/","tags":[{"LinkTitle":"Emoji","RelPermalink":"/hugo-blog/public/zh-cn/tags/emoji/"}],"title":"Emoji 支持"},{"categories":[],"content":"multilingual中文测试页面\n","permalink":"https://gohugo.io/hugo-blog/public/zh-cn/about/","tags":[],"title":"关于"},{"categories":[],"content":"// : # (\n)\n","permalink":"https://gohugo.io/hugo-blog/public/zh-cn/post/i18n-blog/rich-content/","tags":[],"title":""}]
<!DOCTYPE html>
<html lang="en-US" dir="ltr">
<head><script src="/hugo-blog/public/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=hugo-blog/public/livereload" data-no-instant defer></script>
  <title>Java 多线程开发（5）超详细的 ThreadPoolExecutor 源码解析 :: Hugo Theme Tailwind Example Site - Example site for hugo-theme-tailwind</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta
  name="description"
  content=" 公众号：字节数组 希望对你有所帮助 🤣🤣
目前，多线程编程可以说是在大部分平台和应用上都需要实现的一个基本需求。本系列文章就来对 Java 平台下的多线程编程知识进行讲解，从概念入门、底层实现到上层应用都会涉及到，预计一共会有五篇文章，希望对你有所帮助 😎😎
本篇文章是第五篇，应该也是最后一篇了，从现实需求出发到源码介绍，一步步理清楚线程池的作用和优势
线程池（ThreadPool）面对的是外部复杂多变的多线程环境，既需要保证多线程环境下的状态同步，也需要最大化对每个线程的利用率，还需要留给子类足够多的余地来实现功能扩展。所以说，线程池的难点在于如何实现，而在概念上其实还是挺简单的。在 Java 中，线程池这个概念一般都认为对应的是 JDK 中的 ThreadPoolExecutor 类及其各种衍生类，本篇文章就从实现思路出发，探索 ThreadPoolExecutor 的源码到底是如何实现的以及为什么这么实现
一、线程池 线程是一种昂贵的系统资源，其“昂贵”不仅在于创建线程所需要的资源开销，还在于使用过程中带来的资源消耗。一个系统能够支持同时运行的线程总数受限于该系统所拥有的处理器数目和内存大小等硬件条件，线程的运行需要占用处理器时间片，系统中处于运行状态的线程越多，每个线程单位时间内能分配到的时间片就会越少，线程调度带来的上下文切换的次数就会越多，最终导致处理器真正用于运算的时间就会越少。此外，在现实场景中一个程序在其整个生命周期内需要交由线程执行的任务数量往往是远多于系统所能支持同时运行的最大线程数。基于以上原因，为每个任务都创建一个线程来负责执行是不太现实的。那么，我们最直接的一个想法就是要考虑怎么来实现线程的复用了
线程池就是实现线程复用的一种有效方式。线程池的思想可以看做是对资源是有限的而需要处理的任务几乎是无限的这样一个现状的应对措施。线程池的一般实现思路是：线程池内部预先创建或者是先后创建一定数量的线程，外部将需要执行的任务作为一个对象提交给线程池，由线程池选择某条空闲线程来负责执行。如果所有线程都处于工作状态且线程总数已经达到限制条件了，则先将任务缓存到任务队列中，线程再不断从任务队列中取出任务并执行。因此，线程池可以看做是基于生产者-消费者模式的一种服务，内部维护的多个线程相当于消费者，提交的任务相当于产品，提交任务的外部就相当于生产者
二、思考下 好了，既然已经对线程池这个概念有了基本的了解，那么就再来思考下线程池应该具备的功能以及应该如何来实现线程池
线程池中的线程最大数量应该如何限定？ 既然我们不可能无限制地创建线程，那么在创建线程池前就需要为其设定一个最大数量，我们称之为最大线程池大小（maximumPoolSize），当线程池中的当前线程总数达到 maximumPoolSize 后就不应该再创建线程了。在开发中，我们需要根据运行设备的硬件条件和任务类型（I/O 密集型或者 CPU 密集型）来实际衡量该数值的大小，但任务的提交频率和任务的所需执行时间是不固定的，所以线程池的 maximumPoolSize 也应该支持动态调整
线程池中的线程应该在什么时候被创建呢？ 一般来说，如果线程池中的线程数量还没有达到 maximumPoolSize 时，我们可以等到当外部提交了任务时再来创建线程进行处理。但是，线程从被创建到被调度器选中运行，之间也是有着一定时间间隔的。从提高任务的处理响应速度这方面考虑，我们也可以选择预先就创建一批线程进行等待
线程池中的线程可以一直存活着吗？ 程序运行过程中可能只是偶发性地大批量提交任务，而大部分时间只是比较零散地提交少量任务，这就导致线程池中的线程可能会在一段时间内处于空闲状态。如果线程池中的线程只要创建了就可以一直存活着的话，那么线程池的“性价比”就显得没那么高了。所以，当线程处于空闲状态的时间超出允许的最大空闲时间（keepAliveTime）后，我们就应该将其回收，避免白白浪费系统资源。而又为了避免频繁地创建和销毁线程，线程池需要缓存一定数量的线程，即使其处于空闲状态也不会进行回收，这类线程我们就称之为核心线程，相应的线程数量就称之为核心线程池大小（corePoolSize）。大于 corePoolSize 而小于等于 maximumPoolSize 的那一部分线程，就称之为非核心线程
如何实现线程的复用？ 我们知道，当 Thread.run() 方法执行结束后线程就会被回收了，那么想要实现线程的复用，那么就要考虑如何避免退出 Thread.run() 了。这里，我们可以通过循环向任务队列取值的方式来实现。上面有提到，如果外部提交的任务过多，那么任务就需要被缓存到任务队列中。那么，我们就可以考虑使用一个阻塞队列来存放任务。线程循环从任务队列中取任务，如果队列不为空，那么就可以马上拿到任务进行执行；如果队列为空，那么就让线程一直阻塞等待，直到外部提交了任务被该线程拿到或者由于超时退出循环。通过这种循环获取&#43;阻塞等待的方式，就可以实现线程复用的目的
如何尽量实现线程的复用？ 这个问题和“如何实现线程的复用”不太一样，“如何实现线程的复用”针对的是单个线程的复用流程，本问题针对的是整个线程池范围的复用。线程池中需要使用到任务队列进行缓存，那么任务队列的使用时机可以有以下几种：
当线程数已经达到 maximumPoolSize ，且所有线程均处于工作状态时，此后外部提交的任务才被缓存到任务队列中 当核心线程都已经被创建了时，此后外部提交的任务就被缓存到任务队列中，当任务队列满了后才创建非核心线程来循环处理任务 很明显的，第二种方案会更加优秀。由于核心线程一般情况下是会被长久保留的，核心线程的存在保证了外部提交的任务一直有在被循环处理。如果外部提交的大部分都是耗时较短的任务或者任务的提交频率比较低的话，那么任务队列就可能没那么容易满，第二种方案就可以尽量避免去创建非核心线程。而且对于“偶发性地大批量提交任务，而大部分时间只是比较零散地提交少量任务”这种情况，第二种方案也会更加合适。当然，在任务的处理速度方面，第一种方案就会高一些，但是如果想要尽量提高第二种方案的任务处理速度的话，也可以通过将任务队列的容量调小的方式来实现
当任务队列满了后该如何处理？ 如果线程池实在“忙不过来”的话，那么任务队列也是有可能满的，那么就需要为这种情况指定处理策略。当然，我们也可以选择使用一个无界队列来缓存任务，但是无界队列容易掩盖掉一些程序异常。因为有界队列之所以会满，可能是由于发生线程池死锁或者依赖的某个基础服务失效导致的，从而令线程池中的任务一直迟迟得不到解决。如果使用的是无界队列的话，就可能使得当系统发生异常时程序还是看起来运转正常，从而降低了系统健壮性。所以，最常用的还是有界队列
现实需求是多样化的，在实现线程池时就需要留有交由外部自定义处理策略的余地。例如，当队列满了后，我们可以选择直接抛出异常来向外部“告知”这一异常情况。对于重要程度较低的任务，可以选择直接抛弃该任务，也可以选择抛弃队列头的任务而尝试接纳新到来的任务。如果任务必须被执行的话，也可以直接就在提交任务的线程上进行执行
以上就是线程池在实现过程中需要主要考虑的几个点，下面就来看下 Java 实际上是怎么实现线程池的
三、ThreadPoolExecutor java.util.concurrent.ThreadPoolExecutor 类就是 Java 对线程池的默认实现，下文如果没有特别说明的话，所说的线程池就是指 ThreadPoolExecutor
ThreadPoolExecutor 的继承关系如下图所示
"
/>
<meta
  name="keywords"
  content="hugo, tailwind, tailwindcss, hugo theme, hugo theme tailwind"
/>
<meta name="robots" content="noodp" /><link rel="manifest" href="/manifest.json" /><meta property="og:url" content="http://localhost:1313/hugo-blog/public/post/kotlin/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%915%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84-threadpoolexecutor-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">
  <meta property="og:site_name" content="Hugo Theme Tailwind Example Site">
  <meta property="og:title" content="Java 多线程开发（5）超详细的 ThreadPoolExecutor 源码解析">
  <meta property="og:description" content="公众号：字节数组 希望对你有所帮助 🤣🤣
目前，多线程编程可以说是在大部分平台和应用上都需要实现的一个基本需求。本系列文章就来对 Java 平台下的多线程编程知识进行讲解，从概念入门、底层实现到上层应用都会涉及到，预计一共会有五篇文章，希望对你有所帮助 😎😎
本篇文章是第五篇，应该也是最后一篇了，从现实需求出发到源码介绍，一步步理清楚线程池的作用和优势
线程池（ThreadPool）面对的是外部复杂多变的多线程环境，既需要保证多线程环境下的状态同步，也需要最大化对每个线程的利用率，还需要留给子类足够多的余地来实现功能扩展。所以说，线程池的难点在于如何实现，而在概念上其实还是挺简单的。在 Java 中，线程池这个概念一般都认为对应的是 JDK 中的 ThreadPoolExecutor 类及其各种衍生类，本篇文章就从实现思路出发，探索 ThreadPoolExecutor 的源码到底是如何实现的以及为什么这么实现
一、线程池 线程是一种昂贵的系统资源，其“昂贵”不仅在于创建线程所需要的资源开销，还在于使用过程中带来的资源消耗。一个系统能够支持同时运行的线程总数受限于该系统所拥有的处理器数目和内存大小等硬件条件，线程的运行需要占用处理器时间片，系统中处于运行状态的线程越多，每个线程单位时间内能分配到的时间片就会越少，线程调度带来的上下文切换的次数就会越多，最终导致处理器真正用于运算的时间就会越少。此外，在现实场景中一个程序在其整个生命周期内需要交由线程执行的任务数量往往是远多于系统所能支持同时运行的最大线程数。基于以上原因，为每个任务都创建一个线程来负责执行是不太现实的。那么，我们最直接的一个想法就是要考虑怎么来实现线程的复用了
线程池就是实现线程复用的一种有效方式。线程池的思想可以看做是对资源是有限的而需要处理的任务几乎是无限的这样一个现状的应对措施。线程池的一般实现思路是：线程池内部预先创建或者是先后创建一定数量的线程，外部将需要执行的任务作为一个对象提交给线程池，由线程池选择某条空闲线程来负责执行。如果所有线程都处于工作状态且线程总数已经达到限制条件了，则先将任务缓存到任务队列中，线程再不断从任务队列中取出任务并执行。因此，线程池可以看做是基于生产者-消费者模式的一种服务，内部维护的多个线程相当于消费者，提交的任务相当于产品，提交任务的外部就相当于生产者
二、思考下 好了，既然已经对线程池这个概念有了基本的了解，那么就再来思考下线程池应该具备的功能以及应该如何来实现线程池
线程池中的线程最大数量应该如何限定？ 既然我们不可能无限制地创建线程，那么在创建线程池前就需要为其设定一个最大数量，我们称之为最大线程池大小（maximumPoolSize），当线程池中的当前线程总数达到 maximumPoolSize 后就不应该再创建线程了。在开发中，我们需要根据运行设备的硬件条件和任务类型（I/O 密集型或者 CPU 密集型）来实际衡量该数值的大小，但任务的提交频率和任务的所需执行时间是不固定的，所以线程池的 maximumPoolSize 也应该支持动态调整
线程池中的线程应该在什么时候被创建呢？ 一般来说，如果线程池中的线程数量还没有达到 maximumPoolSize 时，我们可以等到当外部提交了任务时再来创建线程进行处理。但是，线程从被创建到被调度器选中运行，之间也是有着一定时间间隔的。从提高任务的处理响应速度这方面考虑，我们也可以选择预先就创建一批线程进行等待
线程池中的线程可以一直存活着吗？ 程序运行过程中可能只是偶发性地大批量提交任务，而大部分时间只是比较零散地提交少量任务，这就导致线程池中的线程可能会在一段时间内处于空闲状态。如果线程池中的线程只要创建了就可以一直存活着的话，那么线程池的“性价比”就显得没那么高了。所以，当线程处于空闲状态的时间超出允许的最大空闲时间（keepAliveTime）后，我们就应该将其回收，避免白白浪费系统资源。而又为了避免频繁地创建和销毁线程，线程池需要缓存一定数量的线程，即使其处于空闲状态也不会进行回收，这类线程我们就称之为核心线程，相应的线程数量就称之为核心线程池大小（corePoolSize）。大于 corePoolSize 而小于等于 maximumPoolSize 的那一部分线程，就称之为非核心线程
如何实现线程的复用？ 我们知道，当 Thread.run() 方法执行结束后线程就会被回收了，那么想要实现线程的复用，那么就要考虑如何避免退出 Thread.run() 了。这里，我们可以通过循环向任务队列取值的方式来实现。上面有提到，如果外部提交的任务过多，那么任务就需要被缓存到任务队列中。那么，我们就可以考虑使用一个阻塞队列来存放任务。线程循环从任务队列中取任务，如果队列不为空，那么就可以马上拿到任务进行执行；如果队列为空，那么就让线程一直阻塞等待，直到外部提交了任务被该线程拿到或者由于超时退出循环。通过这种循环获取&#43;阻塞等待的方式，就可以实现线程复用的目的
如何尽量实现线程的复用？ 这个问题和“如何实现线程的复用”不太一样，“如何实现线程的复用”针对的是单个线程的复用流程，本问题针对的是整个线程池范围的复用。线程池中需要使用到任务队列进行缓存，那么任务队列的使用时机可以有以下几种：
当线程数已经达到 maximumPoolSize ，且所有线程均处于工作状态时，此后外部提交的任务才被缓存到任务队列中 当核心线程都已经被创建了时，此后外部提交的任务就被缓存到任务队列中，当任务队列满了后才创建非核心线程来循环处理任务 很明显的，第二种方案会更加优秀。由于核心线程一般情况下是会被长久保留的，核心线程的存在保证了外部提交的任务一直有在被循环处理。如果外部提交的大部分都是耗时较短的任务或者任务的提交频率比较低的话，那么任务队列就可能没那么容易满，第二种方案就可以尽量避免去创建非核心线程。而且对于“偶发性地大批量提交任务，而大部分时间只是比较零散地提交少量任务”这种情况，第二种方案也会更加合适。当然，在任务的处理速度方面，第一种方案就会高一些，但是如果想要尽量提高第二种方案的任务处理速度的话，也可以通过将任务队列的容量调小的方式来实现
当任务队列满了后该如何处理？ 如果线程池实在“忙不过来”的话，那么任务队列也是有可能满的，那么就需要为这种情况指定处理策略。当然，我们也可以选择使用一个无界队列来缓存任务，但是无界队列容易掩盖掉一些程序异常。因为有界队列之所以会满，可能是由于发生线程池死锁或者依赖的某个基础服务失效导致的，从而令线程池中的任务一直迟迟得不到解决。如果使用的是无界队列的话，就可能使得当系统发生异常时程序还是看起来运转正常，从而降低了系统健壮性。所以，最常用的还是有界队列
现实需求是多样化的，在实现线程池时就需要留有交由外部自定义处理策略的余地。例如，当队列满了后，我们可以选择直接抛出异常来向外部“告知”这一异常情况。对于重要程度较低的任务，可以选择直接抛弃该任务，也可以选择抛弃队列头的任务而尝试接纳新到来的任务。如果任务必须被执行的话，也可以直接就在提交任务的线程上进行执行
以上就是线程池在实现过程中需要主要考虑的几个点，下面就来看下 Java 实际上是怎么实现线程池的
三、ThreadPoolExecutor java.util.concurrent.ThreadPoolExecutor 类就是 Java 对线程池的默认实现，下文如果没有特别说明的话，所说的线程池就是指 ThreadPoolExecutor
ThreadPoolExecutor 的继承关系如下图所示">
  <meta property="og:locale" content="en_US">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">


  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Java 多线程开发（5）超详细的 ThreadPoolExecutor 源码解析">
  <meta name="twitter:description" content="公众号：字节数组 希望对你有所帮助 🤣🤣
目前，多线程编程可以说是在大部分平台和应用上都需要实现的一个基本需求。本系列文章就来对 Java 平台下的多线程编程知识进行讲解，从概念入门、底层实现到上层应用都会涉及到，预计一共会有五篇文章，希望对你有所帮助 😎😎
本篇文章是第五篇，应该也是最后一篇了，从现实需求出发到源码介绍，一步步理清楚线程池的作用和优势
线程池（ThreadPool）面对的是外部复杂多变的多线程环境，既需要保证多线程环境下的状态同步，也需要最大化对每个线程的利用率，还需要留给子类足够多的余地来实现功能扩展。所以说，线程池的难点在于如何实现，而在概念上其实还是挺简单的。在 Java 中，线程池这个概念一般都认为对应的是 JDK 中的 ThreadPoolExecutor 类及其各种衍生类，本篇文章就从实现思路出发，探索 ThreadPoolExecutor 的源码到底是如何实现的以及为什么这么实现
一、线程池 线程是一种昂贵的系统资源，其“昂贵”不仅在于创建线程所需要的资源开销，还在于使用过程中带来的资源消耗。一个系统能够支持同时运行的线程总数受限于该系统所拥有的处理器数目和内存大小等硬件条件，线程的运行需要占用处理器时间片，系统中处于运行状态的线程越多，每个线程单位时间内能分配到的时间片就会越少，线程调度带来的上下文切换的次数就会越多，最终导致处理器真正用于运算的时间就会越少。此外，在现实场景中一个程序在其整个生命周期内需要交由线程执行的任务数量往往是远多于系统所能支持同时运行的最大线程数。基于以上原因，为每个任务都创建一个线程来负责执行是不太现实的。那么，我们最直接的一个想法就是要考虑怎么来实现线程的复用了
线程池就是实现线程复用的一种有效方式。线程池的思想可以看做是对资源是有限的而需要处理的任务几乎是无限的这样一个现状的应对措施。线程池的一般实现思路是：线程池内部预先创建或者是先后创建一定数量的线程，外部将需要执行的任务作为一个对象提交给线程池，由线程池选择某条空闲线程来负责执行。如果所有线程都处于工作状态且线程总数已经达到限制条件了，则先将任务缓存到任务队列中，线程再不断从任务队列中取出任务并执行。因此，线程池可以看做是基于生产者-消费者模式的一种服务，内部维护的多个线程相当于消费者，提交的任务相当于产品，提交任务的外部就相当于生产者
二、思考下 好了，既然已经对线程池这个概念有了基本的了解，那么就再来思考下线程池应该具备的功能以及应该如何来实现线程池
线程池中的线程最大数量应该如何限定？ 既然我们不可能无限制地创建线程，那么在创建线程池前就需要为其设定一个最大数量，我们称之为最大线程池大小（maximumPoolSize），当线程池中的当前线程总数达到 maximumPoolSize 后就不应该再创建线程了。在开发中，我们需要根据运行设备的硬件条件和任务类型（I/O 密集型或者 CPU 密集型）来实际衡量该数值的大小，但任务的提交频率和任务的所需执行时间是不固定的，所以线程池的 maximumPoolSize 也应该支持动态调整
线程池中的线程应该在什么时候被创建呢？ 一般来说，如果线程池中的线程数量还没有达到 maximumPoolSize 时，我们可以等到当外部提交了任务时再来创建线程进行处理。但是，线程从被创建到被调度器选中运行，之间也是有着一定时间间隔的。从提高任务的处理响应速度这方面考虑，我们也可以选择预先就创建一批线程进行等待
线程池中的线程可以一直存活着吗？ 程序运行过程中可能只是偶发性地大批量提交任务，而大部分时间只是比较零散地提交少量任务，这就导致线程池中的线程可能会在一段时间内处于空闲状态。如果线程池中的线程只要创建了就可以一直存活着的话，那么线程池的“性价比”就显得没那么高了。所以，当线程处于空闲状态的时间超出允许的最大空闲时间（keepAliveTime）后，我们就应该将其回收，避免白白浪费系统资源。而又为了避免频繁地创建和销毁线程，线程池需要缓存一定数量的线程，即使其处于空闲状态也不会进行回收，这类线程我们就称之为核心线程，相应的线程数量就称之为核心线程池大小（corePoolSize）。大于 corePoolSize 而小于等于 maximumPoolSize 的那一部分线程，就称之为非核心线程
如何实现线程的复用？ 我们知道，当 Thread.run() 方法执行结束后线程就会被回收了，那么想要实现线程的复用，那么就要考虑如何避免退出 Thread.run() 了。这里，我们可以通过循环向任务队列取值的方式来实现。上面有提到，如果外部提交的任务过多，那么任务就需要被缓存到任务队列中。那么，我们就可以考虑使用一个阻塞队列来存放任务。线程循环从任务队列中取任务，如果队列不为空，那么就可以马上拿到任务进行执行；如果队列为空，那么就让线程一直阻塞等待，直到外部提交了任务被该线程拿到或者由于超时退出循环。通过这种循环获取&#43;阻塞等待的方式，就可以实现线程复用的目的
如何尽量实现线程的复用？ 这个问题和“如何实现线程的复用”不太一样，“如何实现线程的复用”针对的是单个线程的复用流程，本问题针对的是整个线程池范围的复用。线程池中需要使用到任务队列进行缓存，那么任务队列的使用时机可以有以下几种：
当线程数已经达到 maximumPoolSize ，且所有线程均处于工作状态时，此后外部提交的任务才被缓存到任务队列中 当核心线程都已经被创建了时，此后外部提交的任务就被缓存到任务队列中，当任务队列满了后才创建非核心线程来循环处理任务 很明显的，第二种方案会更加优秀。由于核心线程一般情况下是会被长久保留的，核心线程的存在保证了外部提交的任务一直有在被循环处理。如果外部提交的大部分都是耗时较短的任务或者任务的提交频率比较低的话，那么任务队列就可能没那么容易满，第二种方案就可以尽量避免去创建非核心线程。而且对于“偶发性地大批量提交任务，而大部分时间只是比较零散地提交少量任务”这种情况，第二种方案也会更加合适。当然，在任务的处理速度方面，第一种方案就会高一些，但是如果想要尽量提高第二种方案的任务处理速度的话，也可以通过将任务队列的容量调小的方式来实现
当任务队列满了后该如何处理？ 如果线程池实在“忙不过来”的话，那么任务队列也是有可能满的，那么就需要为这种情况指定处理策略。当然，我们也可以选择使用一个无界队列来缓存任务，但是无界队列容易掩盖掉一些程序异常。因为有界队列之所以会满，可能是由于发生线程池死锁或者依赖的某个基础服务失效导致的，从而令线程池中的任务一直迟迟得不到解决。如果使用的是无界队列的话，就可能使得当系统发生异常时程序还是看起来运转正常，从而降低了系统健壮性。所以，最常用的还是有界队列
现实需求是多样化的，在实现线程池时就需要留有交由外部自定义处理策略的余地。例如，当队列满了后，我们可以选择直接抛出异常来向外部“告知”这一异常情况。对于重要程度较低的任务，可以选择直接抛弃该任务，也可以选择抛弃队列头的任务而尝试接纳新到来的任务。如果任务必须被执行的话，也可以直接就在提交任务的线程上进行执行
以上就是线程池在实现过程中需要主要考虑的几个点，下面就来看下 Java 实际上是怎么实现线程池的
三、ThreadPoolExecutor java.util.concurrent.ThreadPoolExecutor 类就是 Java 对线程池的默认实现，下文如果没有特别说明的话，所说的线程池就是指 ThreadPoolExecutor
ThreadPoolExecutor 的继承关系如下图所示">


<link rel="canonical" href="http://localhost:1313/hugo-blog/public/post/kotlin/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%915%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84-threadpoolexecutor-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" />

<link rel="shortcut icon" href="/hugo-blog/public/favicon.ico" />
<link rel="stylesheet" href="/hugo-blog/public/css/index.c3a5d1586276a68cf55558ab67f2c726fee27f4aea3add1802872f471c5f233d.css">









  
  <script type="application/ld+json">
  {"@context":"https://schema.org","@type":"Article","author":{"@type":"Person","name":"Xiaoliang Wang"},"dateModified":"0001-01-01T00:00:00Z","datePublished":"0001-01-01T00:00:00Z","description":" 公众号：字节数组 希望对你有所帮助 🤣🤣\n目前，多线程编程可以说是在大部分平台和应用上都需要实现的一个基本需求。本系列文章就来对 Java 平台下的多线程编程知识进行讲解，从概念入门、底层实现到上层应用都会涉及到，预计一共会有五篇文章，希望对你有所帮助 😎😎\n本篇文章是第五篇，应该也是最后一篇了，从现实需求出发到源码介绍，一步步理清楚线程池的作用和优势\n线程池（ThreadPool）面对的是外部复杂多变的多线程环境，既需要保证多线程环境下的状态同步，也需要最大化对每个线程的利用率，还需要留给子类足够多的余地来实现功能扩展。所以说，线程池的难点在于如何实现，而在概念上其实还是挺简单的。在 Java 中，线程池这个概念一般都认为对应的是 JDK 中的 ThreadPoolExecutor 类及其各种衍生类，本篇文章就从实现思路出发，探索 ThreadPoolExecutor 的源码到底是如何实现的以及为什么这么实现\n一、线程池 线程是一种昂贵的系统资源，其“昂贵”不仅在于创建线程所需要的资源开销，还在于使用过程中带来的资源消耗。一个系统能够支持同时运行的线程总数受限于该系统所拥有的处理器数目和内存大小等硬件条件，线程的运行需要占用处理器时间片，系统中处于运行状态的线程越多，每个线程单位时间内能分配到的时间片就会越少，线程调度带来的上下文切换的次数就会越多，最终导致处理器真正用于运算的时间就会越少。此外，在现实场景中一个程序在其整个生命周期内需要交由线程执行的任务数量往往是远多于系统所能支持同时运行的最大线程数。基于以上原因，为每个任务都创建一个线程来负责执行是不太现实的。那么，我们最直接的一个想法就是要考虑怎么来实现线程的复用了\n线程池就是实现线程复用的一种有效方式。线程池的思想可以看做是对资源是有限的而需要处理的任务几乎是无限的这样一个现状的应对措施。线程池的一般实现思路是：线程池内部预先创建或者是先后创建一定数量的线程，外部将需要执行的任务作为一个对象提交给线程池，由线程池选择某条空闲线程来负责执行。如果所有线程都处于工作状态且线程总数已经达到限制条件了，则先将任务缓存到任务队列中，线程再不断从任务队列中取出任务并执行。因此，线程池可以看做是基于生产者-消费者模式的一种服务，内部维护的多个线程相当于消费者，提交的任务相当于产品，提交任务的外部就相当于生产者\n二、思考下 好了，既然已经对线程池这个概念有了基本的了解，那么就再来思考下线程池应该具备的功能以及应该如何来实现线程池\n线程池中的线程最大数量应该如何限定？ 既然我们不可能无限制地创建线程，那么在创建线程池前就需要为其设定一个最大数量，我们称之为最大线程池大小（maximumPoolSize），当线程池中的当前线程总数达到 maximumPoolSize 后就不应该再创建线程了。在开发中，我们需要根据运行设备的硬件条件和任务类型（I/O 密集型或者 CPU 密集型）来实际衡量该数值的大小，但任务的提交频率和任务的所需执行时间是不固定的，所以线程池的 maximumPoolSize 也应该支持动态调整\n线程池中的线程应该在什么时候被创建呢？ 一般来说，如果线程池中的线程数量还没有达到 maximumPoolSize 时，我们可以等到当外部提交了任务时再来创建线程进行处理。但是，线程从被创建到被调度器选中运行，之间也是有着一定时间间隔的。从提高任务的处理响应速度这方面考虑，我们也可以选择预先就创建一批线程进行等待\n线程池中的线程可以一直存活着吗？ 程序运行过程中可能只是偶发性地大批量提交任务，而大部分时间只是比较零散地提交少量任务，这就导致线程池中的线程可能会在一段时间内处于空闲状态。如果线程池中的线程只要创建了就可以一直存活着的话，那么线程池的“性价比”就显得没那么高了。所以，当线程处于空闲状态的时间超出允许的最大空闲时间（keepAliveTime）后，我们就应该将其回收，避免白白浪费系统资源。而又为了避免频繁地创建和销毁线程，线程池需要缓存一定数量的线程，即使其处于空闲状态也不会进行回收，这类线程我们就称之为核心线程，相应的线程数量就称之为核心线程池大小（corePoolSize）。大于 corePoolSize 而小于等于 maximumPoolSize 的那一部分线程，就称之为非核心线程\n如何实现线程的复用？ 我们知道，当 Thread.run() 方法执行结束后线程就会被回收了，那么想要实现线程的复用，那么就要考虑如何避免退出 Thread.run() 了。这里，我们可以通过循环向任务队列取值的方式来实现。上面有提到，如果外部提交的任务过多，那么任务就需要被缓存到任务队列中。那么，我们就可以考虑使用一个阻塞队列来存放任务。线程循环从任务队列中取任务，如果队列不为空，那么就可以马上拿到任务进行执行；如果队列为空，那么就让线程一直阻塞等待，直到外部提交了任务被该线程拿到或者由于超时退出循环。通过这种循环获取+阻塞等待的方式，就可以实现线程复用的目的\n如何尽量实现线程的复用？ 这个问题和“如何实现线程的复用”不太一样，“如何实现线程的复用”针对的是单个线程的复用流程，本问题针对的是整个线程池范围的复用。线程池中需要使用到任务队列进行缓存，那么任务队列的使用时机可以有以下几种：\n当线程数已经达到 maximumPoolSize ，且所有线程均处于工作状态时，此后外部提交的任务才被缓存到任务队列中 当核心线程都已经被创建了时，此后外部提交的任务就被缓存到任务队列中，当任务队列满了后才创建非核心线程来循环处理任务 很明显的，第二种方案会更加优秀。由于核心线程一般情况下是会被长久保留的，核心线程的存在保证了外部提交的任务一直有在被循环处理。如果外部提交的大部分都是耗时较短的任务或者任务的提交频率比较低的话，那么任务队列就可能没那么容易满，第二种方案就可以尽量避免去创建非核心线程。而且对于“偶发性地大批量提交任务，而大部分时间只是比较零散地提交少量任务”这种情况，第二种方案也会更加合适。当然，在任务的处理速度方面，第一种方案就会高一些，但是如果想要尽量提高第二种方案的任务处理速度的话，也可以通过将任务队列的容量调小的方式来实现\n当任务队列满了后该如何处理？ 如果线程池实在“忙不过来”的话，那么任务队列也是有可能满的，那么就需要为这种情况指定处理策略。当然，我们也可以选择使用一个无界队列来缓存任务，但是无界队列容易掩盖掉一些程序异常。因为有界队列之所以会满，可能是由于发生线程池死锁或者依赖的某个基础服务失效导致的，从而令线程池中的任务一直迟迟得不到解决。如果使用的是无界队列的话，就可能使得当系统发生异常时程序还是看起来运转正常，从而降低了系统健壮性。所以，最常用的还是有界队列\n现实需求是多样化的，在实现线程池时就需要留有交由外部自定义处理策略的余地。例如，当队列满了后，我们可以选择直接抛出异常来向外部“告知”这一异常情况。对于重要程度较低的任务，可以选择直接抛弃该任务，也可以选择抛弃队列头的任务而尝试接纳新到来的任务。如果任务必须被执行的话，也可以直接就在提交任务的线程上进行执行\n以上就是线程池在实现过程中需要主要考虑的几个点，下面就来看下 Java 实际上是怎么实现线程池的\n三、ThreadPoolExecutor java.util.concurrent.ThreadPoolExecutor 类就是 Java 对线程池的默认实现，下文如果没有特别说明的话，所说的线程池就是指 ThreadPoolExecutor\nThreadPoolExecutor 的继承关系如下图所示\n","name":"Java 多线程开发（5）超详细的 ThreadPoolExecutor 源码解析","url":"http://localhost:1313/hugo-blog/public/post/kotlin/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%915%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84-threadpoolexecutor-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"}
</script>

</head>
<body class="flex flex-col min-h-screen w-full bg-slate-50 dark:bg-gray-800">
    
<div class="fixed right-0 top-0 z-50 flex items-center justify-center bg-gray-200 p-2 text-sm uppercase text-black sm:bg-red-200 md:bg-yellow-200 lg:bg-green-200 xl:bg-blue-200 2xl:bg-pink-200">
  <span class="block sm:hidden">all</span>
  <span class="hidden sm:block md:hidden">sm</span>
  <span class="hidden md:block lg:hidden">md</span>
  <span class="hidden lg:block xl:hidden">lg</span>
  <span class="hidden xl:block 2xl:hidden">xl</span>
  <span class="hidden 2xl:block">2xl</span>
</div>

  <header class="flex flex-none justify-center z-10">
    <div class="flex flex-row gap justify-between w-full max-w-4xl lg:max-w-5xl h-12 mt-3">
  <div class="flex-none ml-2 md:ml-0">
    <a href="/hugo-blog/public/" class="">
      <img class="h-12 w-12 rounded-full object-cover bg-gray-100" src="/hugo-blog/public/logo.svg" alt="logo">
    </a>
  </div>
  
  <h1 class="hidden md:flex flex-col justify-center mx-2">
    <a href="/hugo-blog/public/" class="text-2xl font-semibold text-slate-800 dark:text-slate-200">
      Hugo Theme Tailwind
    </a>
  </h1>
  
  <div class="flex-1"></div>
  <div class="flex-none">
    



<nav class="h-full static">
  <button id="navbar-menu-toggle" type="button" class="inline-flex items-center p-2 text-sm text-slate-800 dark:text-slate-200 rounded-lg md:hidden" aria-controls="navbar-menu" aria-expanded="false">
    <span class="sr-only">Open main menu</span>
    <i class="w-8 h-8">
      <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-menu-2" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 6l16 0" />
  <path d="M4 12l16 0" />
  <path d="M4 18l16 0" />
</svg>

    </i>
  </button>
  <div class="absolute md:static top-16 left-0 right-0 z-50 hidden w-full md:block md:w-auto" id="navbar-menu">
    <ul class="flex flex-col mx-2 md:mx-0 md:flex-row md:border-0 rounded-xs md:rounded-full px-3 text-base font-medium text-slate-800 dark:text-slate-200 shadow-lg bg-white dark:bg-gray-600 shadow-slate-800/5 dark:shadow-slate-200/5 ring-1 ring-slate-900/5 dark:ring-slate-100/5">
    
        <li id="post" class="">
          <a class="block px-3 py-3 hover:text-emerald-600 text-emerald-600"
            href="/hugo-blog/public/post/" title="Post">Post</a>
        </li>
      
    
        <li id="about" class="">
          <a class="block px-3 py-3 hover:text-emerald-600"
            href="/hugo-blog/public/about/" title="About">About</a>
        </li>
      
    
    </ul>
  </div>
</nav>


  </div>
  
  <div class="flex-none">
    <div class="h-full static">
      <button id="navbar-lang-toggle" type="button" class="inline-flex items-center p-2 text-sm text-slate-800 dark:text-slate-200 rounded-lg" aria-controls="navbar-menu" aria-expanded="false">
        <span class="sr-only">Open language switcher</span>
        <i class="w-8 h-8">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 5h7" />
  <path d="M9 3v2c0 4.418 -2.239 8 -5 8" />
  <path d="M5 9c0 2.144 2.952 3.908 6.7 4" />
  <path d="M12 20l4 -9l4 9" />
  <path d="M19.1 18h-6.2" />
</svg>

        </i>
      </button>
      <div class="absolute hidden top-16 z-50" id="navbar-lang">
        <ul class="flex flex-col rounded-xs px-3 text-base font-medium text-slate-800 dark:text-slate-200 shadow-lg bg-white dark:bg-gray-600 shadow-slate-800/5 dark:shadow-slate-200/5 ring-1 ring-slate-900/5 dark:ring-slate-100/5">
          <li class="">
            <span class="block px-3 py-3 cursor-default hover:text-emerald-600">English</span>
            </li>
        
        </ul>
      </div>
    </div>
  </div>
  
  <div class="flex-none md:hidden">
    <a href=/hugo-blog/public/search/ class="inline-flex items-center p-2 text-sm text-slate-800 dark:text-slate-200 rounded-lg" aria-controls="navbar-menu" aria-expanded="false">
      <span class="sr-only">Search</span>
      <i class="w-8 h-8">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none" />
    <path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0" />
    <path d="M21 21l-6 -6" />
</svg>

      </i>
    </a>
  </div>
  <div class="darkmode-toggle flex flex-none mr-2 md:mr-0">
    <label for="darkmode-toggle" class="relative flex items-center gap-1 px-3 cursor-pointer rounded-full bg-gray-100 dark:bg-gray-600" title="Toggle dark mode">
      <input name="darkmode-toggle" id="darkmode-toggle" type="checkbox" class="sr-only peer" aria-label="Toggle dark mode">
      <div class="absolute z-10 w-15 h-8 rounded-full bg-white dark:bg-gray-700"></div>
      <i class="h-6 w-6 z-20 ml-1 flex-none rounded-full bg-yellow-400 place-self-center peer-checked:invisible">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brightness-down" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M12 12m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0"></path>
   <path d="M12 5l0 .01"></path>
   <path d="M17 7l0 .01"></path>
   <path d="M19 12l0 .01"></path>
   <path d="M17 17l0 .01"></path>
   <path d="M12 19l0 .01"></path>
   <path d="M7 17l0 .01"></path>
   <path d="M5 12l0 .01"></path>
   <path d="M7 7l0 .01"></path>
</svg>

      </i>
      <i class="h-6 w-6 z-20 mr-1 flex-none rounded-full place-self-center invisible peer-checked:visible">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-moon-stars" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
   <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
   <path d="M19 11h2m-1 -1v2"></path>
</svg>

      </i>
    </label>
  </div>
</div>

  </header>
  <main class="flex flex-auto justify-center">
    
<div id="progress" class="fixed top-0 left-0 w-full h-1 bg-blue-500"></div>
<div class="w-full max-w-4xl lg:max-w-5xl">
  <div class="flex flex-col mt-6 mx-2 md:mx-0 rounded-lg overflow-hidden shadow-md bg-white dark:bg-gray-700">
    <div>
      <a href="/hugo-blog/public/post/kotlin/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%915%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84-threadpoolexecutor-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">
        
      </a>
    </div>
    <div class="flex flex-col gap-y-3 p-6">
      <h1 class="text-4xl font-semibold text-slate-800 dark:text-slate-100">
        <a href="/hugo-blog/public/post/kotlin/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%915%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84-threadpoolexecutor-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">Java 多线程开发（5）超详细的 ThreadPoolExecutor 源码解析</a>
      </h1>

      
      


      <div class="flex flex-col gap-y-1 md:flex-row md:gap-y-0 md:gap-x-4 text-slate-500 dark:text-slate-300">
  <div class="flex flex-row text-base gap-x-1">
    <i class="h-6 w-6 flex-none">
      <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hourglass-high" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M6.5 7h11"></path>
   <path d="M6 20v-2a6 6 0 1 1 12 0v2a1 1 0 0 1 -1 1h-10a1 1 0 0 1 -1 -1z"></path>
   <path d="M6 4v2a6 6 0 1 0 12 0v-2a1 1 0 0 0 -1 -1h-10a1 1 0 0 0 -1 1z"></path>
</svg>

    </i>
    <span>
      13 minutes to read
    </span>
  </div>
</div>

      <div class="flex flex-col gap-y-1 md:flex-row md:gap-y-0 md:gap-x-4 text-slate-500 dark:text-slate-300">
  <div class="flex flex-row text-base gap-x-1">
    <i class="h-6 w-6 flex-none">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
    class="icon icon-tabler icons-tabler-outline icon-tabler-user">
    <path stroke="none" d="M0 0h24v24H0z" fill="none" />
    <path d="M8 7a4 4 0 1 0 8 0a4 4 0 0 0 -8 0" />
    <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>

    </i>
    <span>Xiaoliang Wang</span>
  </div>
</div>

      
        
        <section class="prose prose-slate dark:prose-invert w-full max-w-4xl lg:max-w-5xl mt-6">
          <h2>Table of Contents</h2>
          <aside><nav id="TableOfContents">
  <ul>
    <li><a href="#1线程池的状态如何保存">1、线程池的状态如何保存</a></li>
    <li><a href="#2线程的创建流程">2、线程的创建流程</a></li>
    <li><a href="#3线程的执行流程">3、线程的执行流程</a></li>
    <li><a href="#4线程的回收流程">4、线程的回收流程</a></li>
    <li><a href="#5线程池的关闭流程">5、线程池的关闭流程</a></li>
    <li><a href="#6任务队列的选择">6、任务队列的选择</a></li>
    <li><a href="#7任务的拒绝策略">7、任务的拒绝策略</a></li>
    <li><a href="#8监控线程池的运行状态">8、监控线程池的运行状态</a></li>
  </ul>

  <ul>
    <li><a href="#1线程池死锁">1、线程池死锁</a></li>
    <li><a href="#2线程泄漏">2、线程泄漏</a></li>
  </ul>
</nav></aside>
        </section>
        
      

      <article class="mt-6 w-full max-w-4xl lg:max-w-5xl prose prose-slate dark:prose-invert prose-quoteless post-content">
        <blockquote>
<p>公众号：<a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adbc507fc3704fd8955aae739a433db2~tplv-k3u1fbpfcp-zoom-1.image" target="_blank" rel="noopener">字节数组</a>
</p>
<p>希望对你有所帮助 🤣🤣</p></blockquote>
<blockquote>
<p>目前，多线程编程可以说是在大部分平台和应用上都需要实现的一个基本需求。本系列文章就来对 <strong>Java 平台下的多线程编程知识</strong>进行讲解，从<strong>概念入门</strong>、<strong>底层实现</strong>到<strong>上层应用</strong>都会涉及到，预计一共会有五篇文章，希望对你有所帮助 😎😎</p>
<p>本篇文章是第五篇，应该也是最后一篇了，从现实需求出发到源码介绍，一步步理清楚线程池的作用和优势</p></blockquote>
<p>线程池（ThreadPool）面对的是外部复杂多变的多线程环境，既需要保证多线程环境下的状态同步，也需要最大化对每个线程的利用率，还需要留给子类足够多的余地来实现功能扩展。所以说，线程池的难点在于如何实现，而在概念上其实还是挺简单的。在 Java 中，线程池这个概念一般都认为对应的是 JDK 中的 ThreadPoolExecutor 类及其各种衍生类，本篇文章就从实现思路出发，探索 ThreadPoolExecutor 的源码到底是如何实现的以及为什么这么实现</p>
<h1 id="一线程池">一、线程池</h1>
<p>线程是一种昂贵的系统资源，其“昂贵”不仅在于创建线程所需要的资源开销，还在于使用过程中带来的资源消耗。一个系统能够支持同时运行的线程总数受限于该系统所拥有的处理器数目和内存大小等硬件条件，线程的运行需要占用处理器时间片，系统中处于运行状态的线程越多，每个线程单位时间内能分配到的时间片就会越少，线程调度带来的上下文切换的次数就会越多，最终导致处理器真正用于运算的时间就会越少。此外，在现实场景中一个程序在其整个生命周期内需要交由线程执行的任务数量往往是远多于系统所能支持同时运行的最大线程数。基于以上原因，为每个任务都创建一个线程来负责执行是不太现实的。那么，我们最直接的一个想法就是要考虑怎么来实现线程的复用了</p>
<p><strong>线程池</strong>就是实现线程复用的一种有效方式。线程池的思想可以看做是对<strong>资源是有限的而需要处理的任务几乎是无限的</strong>这样一个现状的应对措施。线程池的一般实现思路是：线程池内部预先创建或者是先后创建一定数量的线程，外部将需要执行的任务作为一个对象提交给线程池，由线程池选择某条空闲线程来负责执行。如果所有线程都处于工作状态且线程总数已经达到限制条件了，则先将任务缓存到任务队列中，线程再不断从任务队列中取出任务并执行。因此，线程池可以看做是基于<strong>生产者-消费者模式</strong>的一种服务，内部维护的多个线程相当于消费者，提交的任务相当于产品，提交任务的外部就相当于生产者</p>
<h1 id="二思考下">二、思考下</h1>
<p>好了，既然已经对线程池这个概念有了基本的了解，那么就再来思考下线程池应该具备的功能以及应该如何来实现线程池</p>
<ol>
<li>线程池中的线程最大数量应该如何限定？</li>
</ol>
<p>既然我们不可能无限制地创建线程，那么在创建线程池前就需要为其设定一个最大数量，我们称之为<strong>最大线程池大小（maximumPoolSize）</strong>，当线程池中的当前线程总数达到 maximumPoolSize 后就不应该再创建线程了。在开发中，我们需要根据运行设备的硬件条件和任务类型（I/O 密集型或者 CPU 密集型）来实际衡量该数值的大小，但任务的提交频率和任务的所需执行时间是不固定的，所以线程池的 maximumPoolSize 也应该支持动态调整</p>
<ol start="2">
<li>线程池中的线程应该在什么时候被创建呢？</li>
</ol>
<p>一般来说，如果线程池中的线程数量还没有达到 maximumPoolSize 时，我们可以等到当外部提交了任务时再来创建线程进行处理。但是，线程从被创建到被调度器选中运行，之间也是有着一定时间间隔的。从提高任务的处理响应速度这方面考虑，我们也可以选择预先就创建一批线程进行等待</p>
<ol start="3">
<li>线程池中的线程可以一直存活着吗？</li>
</ol>
<p>程序运行过程中可能只是偶发性地大批量提交任务，而大部分时间只是比较零散地提交少量任务，这就导致线程池中的线程可能会在一段时间内处于空闲状态。如果线程池中的线程只要创建了就可以一直存活着的话，那么线程池的“性价比”就显得没那么高了。所以，当线程处于空闲状态的时间超出允许的最大空闲时间（keepAliveTime）后，我们就应该将其回收，避免白白浪费系统资源。而又为了避免频繁地创建和销毁线程，线程池需要缓存一定数量的线程，即使其处于空闲状态也不会进行回收，这类线程我们就称之为<strong>核心线程</strong>，相应的线程数量就称之为<strong>核心线程池大小（corePoolSize）</strong>。大于 corePoolSize 而小于等于 maximumPoolSize 的那一部分线程，就称之为<strong>非核心线程</strong></p>
<ol start="4">
<li>如何实现线程的复用？</li>
</ol>
<p>我们知道，当 <code>Thread.run()</code> 方法执行结束后线程就会被回收了，那么想要实现线程的复用，那么就要考虑如何避免退出 <code>Thread.run()</code> 了。这里，我们可以通过<strong>循环向任务队列取值</strong>的方式来实现。上面有提到，如果外部提交的任务过多，那么任务就需要被缓存到任务队列中。那么，我们就可以考虑使用一个阻塞队列来存放任务。线程循环从任务队列中取任务，如果队列不为空，那么就可以马上拿到任务进行执行；如果队列为空，那么就让线程一直阻塞等待，直到外部提交了任务被该线程拿到或者由于超时退出循环。通过这种<strong>循环获取+阻塞等待</strong>的方式，就可以实现线程复用的目的</p>
<ol start="5">
<li>如何尽量实现线程的复用？</li>
</ol>
<p>这个问题和“如何实现线程的复用”不太一样，“如何实现线程的复用”针对的是单个线程的复用流程，本问题针对的是整个线程池范围的复用。线程池中需要使用到任务队列进行缓存，那么任务队列的使用时机可以有以下几种：</p>
<ul>
<li>当线程数已经达到 maximumPoolSize ，且所有线程均处于工作状态时，此后外部提交的任务才被缓存到任务队列中</li>
<li>当核心线程都已经被创建了时，此后外部提交的任务就被缓存到任务队列中，当任务队列满了后才创建非核心线程来循环处理任务</li>
</ul>
<p>很明显的，第二种方案会更加优秀。由于核心线程一般情况下是会被长久保留的，核心线程的存在保证了外部提交的任务一直有在被循环处理。如果外部提交的大部分都是耗时较短的任务或者任务的提交频率比较低的话，那么任务队列就可能没那么容易满，第二种方案就可以尽量避免去创建非核心线程。而且对于“偶发性地大批量提交任务，而大部分时间只是比较零散地提交少量任务”这种情况，第二种方案也会更加合适。当然，在任务的处理速度方面，第一种方案就会高一些，但是如果想要尽量提高第二种方案的任务处理速度的话，也可以通过<strong>将任务队列的容量调小</strong>的方式来实现</p>
<ol start="6">
<li>当任务队列满了后该如何处理？</li>
</ol>
<p>如果线程池实在“忙不过来”的话，那么任务队列也是有可能满的，那么就需要为这种情况指定处理策略。当然，我们也可以选择使用一个<strong>无界队列</strong>来缓存任务，但是无界队列容易掩盖掉一些程序异常。因为有界队列之所以会满，可能是由于发生线程池死锁或者依赖的某个基础服务失效导致的，从而令线程池中的任务一直迟迟得不到解决。如果使用的是无界队列的话，就可能使得当系统发生异常时程序还是看起来运转正常，从而降低了系统健壮性。所以，最常用的还是有界队列</p>
<p>现实需求是多样化的，在实现线程池时就需要留有交由外部自定义处理策略的余地。例如，当队列满了后，我们可以选择直接抛出异常来向外部“告知”这一异常情况。对于重要程度较低的任务，可以选择直接抛弃该任务，也可以选择抛弃队列头的任务而尝试接纳新到来的任务。如果任务必须被执行的话，也可以直接就在提交任务的线程上进行执行</p>
<p>以上就是线程池在实现过程中需要主要考虑的几个点，下面就来看下 Java 实际上是怎么实现线程池的</p>
<h1 id="三threadpoolexecutor">三、ThreadPoolExecutor</h1>
<p><code>java.util.concurrent.ThreadPoolExecutor</code> 类就是 Java 对线程池的默认实现，下文如果没有特别说明的话，所说的线程池就是指 <code>ThreadPoolExecutor</code></p>
<p>ThreadPoolExecutor 的继承关系如下图所示</p>
<p><div class="not-prose">
<figure>
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b73cde5111446a8bd4e41af1b028e61~tplv-k3u1fbpfcp-zoom-1.image"
      alt="" 
      loading="lazy"
    >
  </figure></div>
</p>
<p>ThreadPoolExecutor 实现的最顶层接口是 Executor。Executor 提供了一种将<strong>任务的提交</strong>和<strong>任务的执行</strong>两个操作进行解耦的思路：客户端无需关注执行任务的线程是如何创建、运行和回收的，只需要将任务的执行逻辑包装为一个 Runnable 对象传递进来即可，由 Executor 的实现类自己来完成最复杂的执行逻辑</p>
<p>ExecutorService 接口在 Executor 的基础上扩展了一些功能：</p>
<ol>
<li>扩展执行任务的能力。例如：获取任务的执行结果、取消任务等功能</li>
<li>提供了关闭线程池、停止线程池，以及阻塞等待线程池完全终止的方法</li>
</ol>
<p>AbstractExecutorService 则是上层的抽象类，负责将任务的执行流程串联起来，从而使得下层的实现类 ThreadPoolExecutor 只需要实现一个执行任务的方法即可</p>
<p>也正如上文所说的那样，ThreadPoolExecutor 可以看做是基于<strong>生产者-消费者模式</strong>的一种服务，内部维护的多个线程相当于消费者，提交的任务相当于产品，提交任务的外部就相当于生产者。其整个运行流程如下图所示</p>
<p><div class="not-prose">
<figure>
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31321bc8231648f2a455106a31e94884~tplv-k3u1fbpfcp-zoom-1.image"
      alt="" 
      loading="lazy"
    >
  </figure></div>
</p>
<p>而在线程池的整个生命周期中，以下三个关于线程数量的统计结果也影响着线程池的流程走向</p>
<ol>
<li>当前线程池大小（currentPoolSize）。表示当前实时状态下线程池中线程的数量</li>
<li>最大线程池大小（maximumPoolSize）。表示线程池中允许存在的线程的数量上限</li>
<li>核心线程池大小（corePoolSize）。表示一个不大于 maximumPoolSize 的线程数量上限</li>
</ol>
<p>三者之间的关系如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">当前线程池大小</span><span class="w">  </span><span class="err">≤</span><span class="w">  </span><span class="n">核心线程池大小</span><span class="w">  </span><span class="err">≤</span><span class="w">  </span><span class="n">最大线程池大小</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">or</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">核心线程池大小</span><span class="w">  </span><span class="err">≤</span><span class="w">  </span><span class="n">当前线程池大小</span><span class="w">  </span><span class="err">≤</span><span class="w">  </span><span class="n">最大线程池大小</span><span class="w">
</span></span></span></code></pre></div><p>当中，除了“当前线程池大小”是对线程池现有的工作者线程进行实时计数的结果，其它两个值都是对线程池配置的参数值。三个值的作用在上文也都已经介绍了</p>
<p>ThreadPoolExecutor 中参数最多的一个构造函数的声明如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="nf">ThreadPoolExecutor</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">corePoolSize</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                          </span><span class="kt">int</span><span class="w"> </span><span class="n">maximumPoolSize</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                          </span><span class="kt">long</span><span class="w"> </span><span class="n">keepAliveTime</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                          </span><span class="n">TimeUnit</span><span class="w"> </span><span class="n">unit</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                          </span><span class="n">BlockingQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span><span class="w"> </span><span class="n">workQueue</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                          </span><span class="n">ThreadFactory</span><span class="w"> </span><span class="n">threadFactory</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                          </span><span class="n">RejectedExecutionHandler</span><span class="w"> </span><span class="n">handler</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">corePoolSize</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">0</span><span class="w"> </span><span class="o">||</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">maximumPoolSize</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">0</span><span class="w"> </span><span class="o">||</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">maximumPoolSize</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">corePoolSize</span><span class="w"> </span><span class="o">||</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">keepAliveTime</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">IllegalArgumentException</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">workQueue</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">threadFactory</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">handler</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">NullPointerException</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="na">getSecurityManager</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">?</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kc">null</span><span class="w"> </span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">AccessController</span><span class="p">.</span><span class="na">getContext</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">corePoolSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">corePoolSize</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">maximumPoolSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">maximumPoolSize</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">workQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">workQueue</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">keepAliveTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unit</span><span class="p">.</span><span class="na">toNanos</span><span class="p">(</span><span class="n">keepAliveTime</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">threadFactory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadFactory</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">handler</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><ul>
<li>corePoolSize ：用于指定线程池的核心线程数大小</li>
<li>maximumPoolSize：用于指定最大线程池大小</li>
<li>keepAliveTime、unit   ：一起用于指定线程池中空闲线程的最大存活时间</li>
<li>workQueue ：任务队列，相当于生产者-消费者模式中的传输管道，用于存放待处理的任务</li>
<li>threadFactory：用于指定创建线程的线程工厂</li>
<li>handler：用于指定当任务队列已满且线程数量达到 maximumPoolSize 时任务的处理策略</li>
</ul>
<p><strong>下面就以点见面，从细节处来把握整个线程池的流程走向</strong></p>
<h2 id="1线程池的状态如何保存">1、线程池的状态如何保存</h2>
<p>这里所说的“状态”指的是一个<strong>复合数据</strong>，包含“<strong>线程池生命周期状态</strong>”和“<strong>线程池当前线程数量</strong>”这两项。线程池从启动到最终终止，其内部需要记录其当前状态来决定流程走向。而线程池的当前线程数量，也关乎着线程是否需要进行回收以及是否需要执行任务的拒绝策略</p>
<p>线程池一共包含以下五种生命周期状态，涵盖了线程池从启动到终止的这整个范围。线程池的生命周期状态可以按顺序跃迁，但无法反向回转，每个状态的数值大小也是逐步递增的</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">//运行状态，线程池正处于运行中</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">RUNNING</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">COUNT_BITS</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">//关闭状态，当调用 shutdown() 方法后处于这个状态，任务队列中的任务会继续处理，但不再接受新任务，</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">SHUTDOWN</span><span class="w">   </span><span class="o">=</span><span class="w">  </span><span class="n">0</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">COUNT_BITS</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">//停止状态，当调用 shutdownNow() 方法后处于这个状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">//任务队列中的任务也不再处理且作为方法返回值返回，此后不再接受新任务</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">STOP</span><span class="w">       </span><span class="o">=</span><span class="w">  </span><span class="n">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">COUNT_BITS</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">//TERMINATED 之前的临时状态，当线程都被回收且任务队列已清空后就会处于这个状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">TIDYING</span><span class="w">    </span><span class="o">=</span><span class="w">  </span><span class="n">2</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">COUNT_BITS</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">//终止状态，在处于 TIDYING 状态后会立即调用 terminated() 方法，调用完成就会马上转到此状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">TERMINATED</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">3</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">COUNT_BITS</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p><div class="not-prose">
<figure>
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42fd1e9319824fdca526dbcdaeb4fe90~tplv-k3u1fbpfcp-zoom-1.image"
      alt="" 
      loading="lazy"
    >
  </figure></div>
</p>
<p>在日常开发中，如果我们想要用一个 int 类型的 state 变量来表示这五种状态的话，那么就可能是通过让 state 分别取值 <strong>1，2，3，4，5</strong> 来进行标识，而 state 作为一个 int 类型是一共有三十二位的，那其实上仅需要占用三位就足够标识了，即 2 x 2 x 2 = 8 种可能。那还剩下 29 位可以用来存放其它数据</p>
<p>实际上 ThreadPoolExecutor 就是通过将一个 32 位的 int 类型变量分割为两段，<strong>高 3 位用来表示线程池的当前生命周期状态，低 29 位就拿来表示线程池的当前线程数量</strong>，从而做到用一个变量值来维护两份数据，这个变量值就是 <code>ctl</code>。从 <code>ctl</code> 的初始值就可以知道线程池的初始生命周期状态( runState )是 <code>RUNNING</code>，初始线程数量 ( workerCount )是 0。这种用一个变量去存储两个值的做法，可以避免在做相关决策时出现不一致的情况，且不必为了维护两者的一致而使用锁，后续需要获取线程池的<strong>当前生命周期状态</strong>和<strong>线程数量</strong>的时候，也可以直接采用位运算的方式获取，在速度上相比基本运算会快很多</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">AtomicInteger</span><span class="w"> </span><span class="n">ctl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AtomicInteger</span><span class="p">(</span><span class="n">ctlOf</span><span class="p">(</span><span class="n">RUNNING</span><span class="p">,</span><span class="w"> </span><span class="n">0</span><span class="p">));</span><span class="w">
</span></span></span></code></pre></div><p>ThreadPoolExecutor 还声明了以下两个常量用来参与位运算</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">//用来表示线程数量的位数，即 29</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">COUNT_BITS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Integer</span><span class="p">.</span><span class="na">SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">3</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">//线程池所能表达的最大线程数，即一个“高3位全是0，低29位全是1”的数值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">CAPACITY</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">COUNT_BITS</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>相应的，那么就需要有几个方法可以来分别取“生命周期状态”和“线程数”这两个值，以及将这两个值合并保存的方法，这几个方法都使用到了位运算</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// Packing and unpacking ctl</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">//通过按位取反 + 按位与运算，将 c 的高3位保留，舍弃低29位，从而得到线程池状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">runStateOf</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w">     </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">CAPACITY</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">//通过按位与运算，将 c 的高3位舍弃，保留低29位，从而得到工作线程数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">workerCountOf</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">CAPACITY</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">//rs，即 runState，线程池的生命周期状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">//wc，即 workerCount，工作线程数量</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">//通过按位或运算来合并值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">ctlOf</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">rs</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">wc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">rs</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">wc</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">runStateLessThan</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">runStateAtLeast</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">//用于判断线程池是否处于 RUNNING 状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">//由于五个状态值的大小是依次递增的，所以只需要和 SHUTDOWN 比较即可</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">isRunning</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">SHUTDOWN</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">isShutdown</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">!</span><span class="n">isRunning</span><span class="p">(</span><span class="n">ctl</span><span class="p">.</span><span class="na">get</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">//用于判断当前状态是否处于 SHUTDOWN、STOP、TIDYING 三者中的一个</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">isTerminating</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctl</span><span class="p">.</span><span class="na">get</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">!</span><span class="n">isRunning</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">runStateLessThan</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">TERMINATED</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">//用于判断当前状态是否处于 TERMINATED</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">isTerminated</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">runStateAtLeast</span><span class="p">(</span><span class="n">ctl</span><span class="p">.</span><span class="na">get</span><span class="p">(),</span><span class="w"> </span><span class="n">TERMINATED</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h2 id="2线程的创建流程">2、线程的创建流程</h2>
<p>在初始状态下，客户端每提交一个任务，线程池就会通过 <code>threadFactory</code> 创建线程来处理该任务，如果开发者没有指定 <code>threadFactory</code> 的话，则会使用 <code>Executors.DefaultThreadFactory</code>。线程池在最先开始创建的线程属于核心线程，线程数量在大于 corePoolSize 而小于等于 maximumPoolSize 这个范围内的线程属于非核心线程。需要注意的是，核心线程和非核心线程并非是两种不同类型的线程对象，这两个概念只是对不同数量范围内的线程进行的区分，实质上这两者指向的都是同一类型</p>
<p>线程的创建流程可以通过任务的提交流程来了解，任务的提交流程图如下所示</p>
<p><div class="not-prose">
<figure>
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5743941998c94452872373a79b68c90a~tplv-k3u1fbpfcp-zoom-1.image"
      alt="" 
      loading="lazy"
    >
  </figure></div>
</p>
<p>线程池开放了多个让外部提交任务的方法，这里主要看 <code>execute(Runnable command)</code> 方法。该方法需要先后多次校验状态值，因为线程池面对的调用方可以来自于多个不同的线程。可能在当前线程提交任务的同时，其它线程就刚好关闭了线程池或者是调整了线程池的线程大小参数，需要考虑当前的线程数量是否已经达到限制了</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="n">Runnable</span><span class="w"> </span><span class="n">command</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">command</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">NullPointerException</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctl</span><span class="p">.</span><span class="na">get</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">workerCountOf</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">corePoolSize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//如果当前线程数还未达到 corePoolSize，则尝试创建一个核心线程来处理任务</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//addWorker 可能会因为线程池被关闭了、线程数量超出限制等原因返回 false</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">addWorker</span><span class="p">(</span><span class="n">command</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctl</span><span class="p">.</span><span class="na">get</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isRunning</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">workQueue</span><span class="p">.</span><span class="na">offer</span><span class="p">(</span><span class="n">command</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">//线程池还处于运行状态且成功添加任务到任务队列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//需要重新检查下运行状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//因为等执行到这里时，线程池可能被其它线程关闭了</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">recheck</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctl</span><span class="p">.</span><span class="na">get</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//1、如果线程池已经处于非运行状态了</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//1.1、如果移除 command 成功，则走拒绝策略</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//1.2、如果移除 command 失败（因为 command 可能已经被其它线程拿去执行了），则走第 3 步</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//2、如果线程池还处于运行状态，则走第 3 步</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//3、如果当前线程数量为 0，则创建线程进行处理</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//第 3 步的意义在于：corePoolSize 可以被设为 0，所以这里需要检查下，在需要的时候创建一个非核心线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="w"> </span><span class="n">isRunning</span><span class="p">(</span><span class="n">recheck</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">remove</span><span class="p">(</span><span class="n">command</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">reject</span><span class="p">(</span><span class="n">command</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">workerCountOf</span><span class="p">(</span><span class="n">recheck</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">addWorker</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//如果线程池处于非运行状态了，或者是处于运行状态但队列已满了，此时就会走到这里</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//在这里尝试创建一个非核心线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//如果线程创建失败，说明要么是线程池当前状态大于等于 STOP，或者是任务队列已满且线程总数达到 maximumPoolSize 了</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//此时就走拒绝策略</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">addWorker</span><span class="p">(</span><span class="n">command</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">reject</span><span class="p">(</span><span class="n">command</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>当中，<code>addWorker(Runnable firstTask, boolean core)</code> 方法用于尝试创建并启动线程，同时将线程保存到 <code>workers</code>。第一个参数用于指定线程启动时需要执行的第一个任务，可以为 null。第二个参数用于指定要创建的是否是核心线程，这个参数会关系到线程是否能被成功创建</p>
<p>该方法在实际创建线程前，都需要先通过 CAS 来更新（递增加一）当前的线程总数，通过 for 循环来不断进行重试。当 CAS 成功后，则会再来实际进行线程的创建操作。但在这时候线程也未必能够创建成功，因为在 CAS 成功后线程池可能被关闭了，或者是在创建线程时抛出异常了，此时就需要回滚对 workerCount 的修改</p>
<p>该方法如果返回 true，意味着新创建了一个 Worker 线程，同时线程也被启动了</p>
<p>该方法如果返回 false，则可能是由于以下情况：</p>
<ol>
<li>生命周期状态大于等于 STOP</li>
<li>生命周期状态等于 SHUTDOWN，但 firstTask 不为 null，或者任务队列为空</li>
<li>当前线程数已经超出限制</li>
<li>符合创建线程的条件，但创建过程中或启动线程的过程中抛出了异常</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">addWorker</span><span class="p">(</span><span class="n">Runnable</span><span class="w"> </span><span class="n">firstTask</span><span class="p">,</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="n">core</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//下面的 for 主要逻辑：</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//在创建线程前通过 CAS 原子性地将“工作者线程数量递增加一”</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//由于 CAS 可能会失败，所以将之放到 for 循环中进行循环重试</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//每次循环前后都需要检查下当前状态是否允许创建线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">retry</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;;)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctl</span><span class="p">.</span><span class="na">get</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">rs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">runStateOf</span><span class="p">(</span><span class="n">c</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Check if queue empty only if necessary.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rs</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">SHUTDOWN</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="o">!</span><span class="w"> </span><span class="p">(</span><span class="n">rs</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SHUTDOWN</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">               </span><span class="n">firstTask</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">               </span><span class="o">!</span><span class="w"> </span><span class="n">workQueue</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">()))</span><span class="w">   
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//当外部调用 shutdown() 方法后，线程池状态会变迁为 SHUTDOWN</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//此时依然允许创建线程来对队列中的任务进行处理，但是不会再接受新任务</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//除这种情况之外不允许在非 RUNNING 的时候还创建线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(;;)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">wc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">workerCountOf</span><span class="p">(</span><span class="n">c</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">wc</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">CAPACITY</span><span class="w"> </span><span class="o">||</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">wc</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="p">(</span><span class="n">core</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">corePoolSize</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">maximumPoolSize</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">//当前线程数已经超出最大限制</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">compareAndIncrementWorkerCount</span><span class="p">(</span><span class="n">c</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">//通过 CAS 更新工作者线程数成功后就跳出循环，去实际创建线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">break</span><span class="w"> </span><span class="n">retry</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctl</span><span class="p">.</span><span class="na">get</span><span class="p">();</span><span class="w">  </span><span class="c1">// Re-read ctl</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">runStateOf</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">rs</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">//循环过程中线程池状态被改变了，重新循环</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">continue</span><span class="w"> </span><span class="n">retry</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// else CAS failed due to workerCount change; retry inner loop</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">boolean</span><span class="w"> </span><span class="n">workerStarted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">boolean</span><span class="w"> </span><span class="n">workerAdded</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Worker</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Worker</span><span class="p">(</span><span class="n">firstTask</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">final</span><span class="w"> </span><span class="n">Thread</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">w</span><span class="p">.</span><span class="na">thread</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">final</span><span class="w"> </span><span class="n">ReentrantLock</span><span class="w"> </span><span class="n">mainLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">mainLock</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">mainLock</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">// Recheck while holding lock.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">// Back out on ThreadFactory failure or if</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">// shut down before lock acquired.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">rs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">runStateOf</span><span class="p">(</span><span class="n">ctl</span><span class="p">.</span><span class="na">get</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rs</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">SHUTDOWN</span><span class="w"> </span><span class="o">||</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">(</span><span class="n">rs</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SHUTDOWN</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">firstTask</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="na">isAlive</span><span class="p">())</span><span class="w"> </span><span class="c1">// precheck that t is startable</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">IllegalThreadStateException</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">workers</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">w</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">//更新线程池曾经达到的最大线程数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">workers</span><span class="p">.</span><span class="na">size</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">largestPoolSize</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">largestPoolSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">workerAdded</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">mainLock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">workerAdded</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">t</span><span class="p">.</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">workerStarted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//如果线程没有被成功启动，则需要将该任务从队列中移除并重新更新工作者线程数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="w"> </span><span class="n">workerStarted</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">addWorkerFailed</span><span class="p">(</span><span class="n">w</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">workerStarted</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h2 id="3线程的执行流程">3、线程的执行流程</h2>
<p>上面所讲的线程其实指的是 ThreadPoolExecutor 的内部类 Worker ，Worker 内部包含了一个 Thread 对象，所以本文就把 Worker 实例也看做线程来对待</p>
<p>Worker 继承于 AbstractQueuedSynchronizer，意味着 Worker 就相当于一个锁。之没有使用 synchronized 或者 ReentrantLock，是因为它们都是<strong>可重入锁</strong>，Worker 继承于 AQS 为的就是自定义实现<strong>不可重入</strong>的特性来辅助判断线程是否处于执行任务的状态：在开始执行任务前进行加锁，在任务执行结束后解锁，以便在后续通过判断 Worker 是否处于锁定状态来得知其是否处于执行阶段</p>
<ol>
<li>Worker 在开始执行任务前会执行 <code>Worker.lock()</code> ，表明线程正在执行任务</li>
<li>如果 Worker 处于锁定状态，则不应该对其进行中断，避免任务执行一半就被打断</li>
<li>如果 Worker 处于非锁定状态，说明其当前是处于阻塞获取任务的状态，此时才允许对其进行中断</li>
<li>线程池在执行 <code>shutdown()</code> 方法或 <code>shutdownNow()</code> 方法时会调用 <code>interruptIdleWorkers()</code> 方法来回收空闲的线程，<code>interruptIdleWorkers()</code> 方法会使用<code>Worker.tryLock()</code> 方法来尝试获取锁，由于 Worker 是不可重入锁，所以如果锁获取成功就说明线程处于空闲状态，此时才可以进行回收</li>
</ol>
<p>Worker 同时也是 Runnable 类型，<code>thread</code> 是通过 <code>getThreadFactory().newThread(this)</code> 来创建的，即将 Worker 本身作为构造参数传给 Thread 进行初始化，所以在 <code>thread</code> 启动的时候 Worker 的 <code>run()</code> 方法就会被执行</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Worker</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">AbstractQueuedSynchronizer</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Runnable</span><span class="w">  </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * This class will never be serialized, but we provide a
</span></span></span><span class="line"><span class="cl"><span class="cm">     * serialVersionUID to suppress a javac warning.
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">serialVersionUID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">6138294804551838833L</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/** Thread this worker is running in.  Null if factory fails. */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">Thread</span><span class="w"> </span><span class="n">thread</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//线程要执行的第一个任务，可能为 null</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/** Initial task to run.  Possibly null. */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Runnable</span><span class="w"> </span><span class="n">firstTask</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//用于标记 Worker 执行过的任务数（不管成功与否都记录）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/** Per-thread task counter */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">volatile</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">completedTasks</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * Creates with given first task and thread from ThreadFactory.
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param firstTask the first task (null if none)
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Worker</span><span class="p">(</span><span class="n">Runnable</span><span class="w"> </span><span class="n">firstTask</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">setState</span><span class="p">(</span><span class="o">-</span><span class="n">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// inhibit interrupts until runWorker</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">firstTask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">firstTask</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">thread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getThreadFactory</span><span class="p">().</span><span class="na">newThread</span><span class="p">(</span><span class="k">this</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/** Delegates main run loop to outer runWorker  */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">runWorker</span><span class="p">(</span><span class="k">this</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Lock methods</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// The value 0 represents the unlocked state.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// The value 1 represents the locked state.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">protected</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">isHeldExclusively</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">getState</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//只有在 state 值为 0 的时候才能获取到锁，以此实现不可重入的特性</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">protected</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">tryAcquire</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">unused</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">compareAndSetState</span><span class="p">(</span><span class="n">0</span><span class="p">,</span><span class="w"> </span><span class="n">1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">setExclusiveOwnerThread</span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">protected</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">tryRelease</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">unused</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">setExclusiveOwnerThread</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">setState</span><span class="p">(</span><span class="n">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">lock</span><span class="p">()</span><span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="n">acquire</span><span class="p">(</span><span class="n">1</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">tryLock</span><span class="p">()</span><span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">tryAcquire</span><span class="p">(</span><span class="n">1</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">unlock</span><span class="p">()</span><span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="n">release</span><span class="p">(</span><span class="n">1</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">isLocked</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">isHeldExclusively</span><span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//向线程发起中断请求</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">interruptIfStarted</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Thread</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">getState</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">t</span><span class="p">.</span><span class="na">isInterrupted</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">t</span><span class="p">.</span><span class="na">interrupt</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">SecurityException</span><span class="w"> </span><span class="n">ignore</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><code>runWorker(Worker)</code> 方法就是线程正式进行任务执行的地方。该方法通过 while 循环不断从任务队列中取出任务来进行执行，如果 <code>getTask()</code>方法返回了 null，那此时就需要将此线程进行回收。如果在任务执行过程中抛出了异常，那也需要回收此线程</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">final</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">runWorker</span><span class="p">(</span><span class="n">Worker</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Thread</span><span class="w"> </span><span class="n">wt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Runnable</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">w</span><span class="p">.</span><span class="na">firstTask</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">w</span><span class="p">.</span><span class="na">firstTask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//因为 Worker 的默认值是 -1，而 Worker 的 interruptIfStarted() 方法只有在 state &gt;=0 的时候才允许进行中断</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//所以这里调用 unlock() 并不是为了解锁，而是为了让 Worker 的 state 值变为 0，让 Worker 允许外部进行中断</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//所以，即使客户端调用了 shutdown 或者 shutdownNow 方法，在 Worker 线程还未执行到这里前，无法在 interruptWorkers() 方法里发起中断请求</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">w</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w"> </span><span class="c1">// allow interrupts</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//用于标记是否由于被打断而非正常结束导致的线程终止</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//为 true 表示非正常结束</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">boolean</span><span class="w"> </span><span class="n">completedAbruptly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 如果 getTask() 为 null，说明线程池已经被停止或者需要进行线程回收</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">task</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getTask</span><span class="p">())</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//在开始执行任务前进行加锁，在任务执行结束后解锁</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//以便在后续通过判断 Worker 是否处于锁定状态来得知其是否处于执行阶段</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">w</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// If pool is stopping, ensure thread is interrupted;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// if not, ensure thread is not interrupted.  This</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// requires a recheck in second case to deal with</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// shutdownNow race while clearing interrupt</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//确保当状态值大于等于 STOP 时有向线程发起过中断请求</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">runStateAtLeast</span><span class="p">(</span><span class="n">ctl</span><span class="p">.</span><span class="na">get</span><span class="p">(),</span><span class="w"> </span><span class="n">STOP</span><span class="p">)</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="o">||</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">interrupted</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">runStateAtLeast</span><span class="p">(</span><span class="n">ctl</span><span class="p">.</span><span class="na">get</span><span class="p">(),</span><span class="w"> </span><span class="n">STOP</span><span class="p">)))</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="o">&amp;&amp;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="o">!</span><span class="n">wt</span><span class="p">.</span><span class="na">isInterrupted</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">wt</span><span class="p">.</span><span class="na">interrupt</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">beforeExecute</span><span class="p">(</span><span class="n">wt</span><span class="p">,</span><span class="w"> </span><span class="n">task</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Throwable</span><span class="w"> </span><span class="n">thrown</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">task</span><span class="p">.</span><span class="na">run</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">RuntimeException</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">thrown</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="k">throw</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">Error</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">thrown</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="k">throw</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">Throwable</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">thrown</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Error</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">afterExecute</span><span class="p">(</span><span class="n">task</span><span class="p">,</span><span class="w"> </span><span class="n">thrown</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">w</span><span class="p">.</span><span class="na">completedTasks</span><span class="o">++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">w</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">completedAbruptly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//回收此线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">processWorkerExit</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">completedAbruptly</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="n">Runnable</span><span class="w"> </span><span class="nf">getTask</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">boolean</span><span class="w"> </span><span class="n">timedOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Did the last poll() time out?</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctl</span><span class="p">.</span><span class="na">get</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">rs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">runStateOf</span><span class="p">(</span><span class="n">c</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Check if queue empty only if necessary.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//如何当前状态大于等于 STOP，则返回 null</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//如何当前状态是 SHUTDOWN 且任务队列为空，则返回 null</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rs</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">SHUTDOWN</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">rs</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">STOP</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">workQueue</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">decrementWorkerCount</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">wc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">workerCountOf</span><span class="p">(</span><span class="n">c</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Are workers subject to culling?</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//timed 用于标记从任务队列中取任务时是否需要进行超时控制</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//如果允许回收空闲核心线程或者是当前的线程总数已经超出 corePoolSize 了，那么就需要进行超时控制</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">boolean</span><span class="w"> </span><span class="n">timed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allowCoreThreadTimeOut</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">wc</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">corePoolSize</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//1. 线程总数超出 maximumPoolSize</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//2. 允许回收核心线程，且核心线程的空闲时间已达到限制了</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//如果以上两种情况之一有一个满足，且当前线程数大于 1 或者任务队列为空时就返回 null（如果 CAS 更新 WorkerCount 成功的话）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//避免在任务队列不为空且只有一个线程时还回收线程导致任务没人处理</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">wc</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">maximumPoolSize</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">timed</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">timedOut</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">wc</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">workQueue</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">compareAndDecrementWorkerCount</span><span class="p">(</span><span class="n">c</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">continue</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Runnable</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">timed</span><span class="w"> </span><span class="o">?</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">workQueue</span><span class="p">.</span><span class="na">poll</span><span class="p">(</span><span class="n">keepAliveTime</span><span class="p">,</span><span class="w"> </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">NANOSECONDS</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">workQueue</span><span class="p">.</span><span class="na">take</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//如果 r 为 null，说明是由于超时导致 poll 返回了 null</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//在下一次循环时将判断是否回收此线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">timedOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">retry</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">timedOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><code>getTask()</code> 方法获取任务的流程图如下所示：</p>
<p><div class="not-prose">
<figure>
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27aa45cbba2848de85cb20fdccd5ae42~tplv-k3u1fbpfcp-zoom-1.image"
      alt="" 
      loading="lazy"
    >
  </figure></div>
</p>
<h2 id="4线程的回收流程">4、线程的回收流程</h2>
<p>当外部调用了线程池的以下几个方法之一时，就会触发到线程的回收机制：</p>
<ol>
<li>允许回收核心线程：allowCoreThreadTimeOut()</li>
<li>重置核心线程池大小：setCorePoolSize()</li>
<li>重置最大线程池大小：setMaximumPoolSize()</li>
<li>重置线程最大空闲时间：setKeepAliveTime()</li>
<li>关闭线程池：shutdown()</li>
<li>停止线程池：shutdownNow()</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 用于控制核心线程是否可以由于空闲时间超时而被回收
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 超时时间和非核心线程一样由 keepAliveTime 来指定
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param value
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">allowCoreThreadTimeOut</span><span class="p">(</span><span class="kt">boolean</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">keepAliveTime</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">IllegalArgumentException</span><span class="p">(</span><span class="s">&#34;Core threads must have nonzero keep alive times&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">allowCoreThreadTimeOut</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">allowCoreThreadTimeOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//回收掉空闲线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">interruptIdleWorkers</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 重置 corePoolSize
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param corePoolSize
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">setCorePoolSize</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">corePoolSize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">corePoolSize</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">IllegalArgumentException</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">delta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">corePoolSize</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">corePoolSize</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">corePoolSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">corePoolSize</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">workerCountOf</span><span class="p">(</span><span class="n">ctl</span><span class="p">.</span><span class="na">get</span><span class="p">())</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">corePoolSize</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//如果当前的线程总数已经超出新的 corePoolSize 的话那就进行线程回收</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">interruptIdleWorkers</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">delta</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//会走进这里，说明新的 corePoolSize 比原先的大，但当前线程总数还小于等于新的 corePoolSize</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//此时如果任务队列不为空的话，那么就需要创建一批新的核心线程来处理任务</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//delta 和 workQueueSize 中的最小值就是需要启动的线程数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//而如果在创建过程中任务队列已经空了（被其它线程拿去处理了），那就不再创建线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="na">min</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span><span class="w"> </span><span class="n">workQueue</span><span class="p">.</span><span class="na">size</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="o">--</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">addWorker</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">workQueue</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">break</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 用于设置线程池允许存在的最大活跃线程数
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param maximumPoolSize
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">setMaximumPoolSize</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">maximumPoolSize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">maximumPoolSize</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">maximumPoolSize</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">corePoolSize</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">IllegalArgumentException</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">maximumPoolSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">maximumPoolSize</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">workerCountOf</span><span class="p">(</span><span class="n">ctl</span><span class="p">.</span><span class="na">get</span><span class="p">())</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">maximumPoolSize</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//回收掉空闲线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">interruptIdleWorkers</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 用于设置非核心线程在空闲状态能够存活的时间
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param time
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param unit
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">setKeepAliveTime</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">TimeUnit</span><span class="w"> </span><span class="n">unit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">time</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">IllegalArgumentException</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//为了避免频繁创建线程，核心线程如果允许超时回收的话，超时时间不能为 0</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">time</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">allowsCoreThreadTimeOut</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">IllegalArgumentException</span><span class="p">(</span><span class="s">&#34;Core threads must have nonzero keep alive times&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">keepAliveTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unit</span><span class="p">.</span><span class="na">toNanos</span><span class="p">(</span><span class="n">time</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">delta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">keepAliveTime</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">keepAliveTime</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">keepAliveTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">keepAliveTime</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">delta</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w"> </span><span class="c1">//如果新设置的值比原先的超时时间小的话，那就需要去回收掉空闲线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">interruptIdleWorkers</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 关闭线程池
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">shutdown</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">ReentrantLock</span><span class="w"> </span><span class="n">mainLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">mainLock</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">mainLock</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">checkShutdownAccess</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//将当前状态设置为 SHUTDOWN</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">advanceRunState</span><span class="p">(</span><span class="n">SHUTDOWN</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//回收掉空闲线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">interruptIdleWorkers</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">onShutdown</span><span class="p">();</span><span class="w"> </span><span class="c1">// hook for ScheduledThreadPoolExecutor</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">mainLock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//尝试看是否能把线程池状态置为 TERMINATED</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">tryTerminate</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 停止线程池
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 任务队列中缓存的所有任务
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">shutdownNow</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tasks</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">ReentrantLock</span><span class="w"> </span><span class="n">mainLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">mainLock</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">mainLock</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">checkShutdownAccess</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//将当前状态设置为 STOP</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">advanceRunState</span><span class="p">(</span><span class="n">STOP</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//回收掉空闲线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">interruptWorkers</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//获取任务队列中缓存的所有任务</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">tasks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">drainQueue</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">mainLock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//尝试看是否能把线程池状态置为 TERMINATED</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">tryTerminate</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">tasks</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>上述的几个方法最终都会调用 <code>interruptIdleWorkers(boolean onlyOne)</code> 方法来回收空闲线程。该方法通过向线程发起中断请求来使 Worker 退出 <code>runWorker(Worker w)</code> 方法，最终会调用 <code>processWorkerExit(Worker w, boolean completedAbruptly)</code> 方法来完成实际的线程回收操作</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">interruptIdleWorkers</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">interruptIdleWorkers</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">interruptIdleWorkers</span><span class="p">(</span><span class="kt">boolean</span><span class="w"> </span><span class="n">onlyOne</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">ReentrantLock</span><span class="w"> </span><span class="n">mainLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">mainLock</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">mainLock</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Worker</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">workers</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Thread</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">w</span><span class="p">.</span><span class="na">thread</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//仅在线程的中断标记为 false 时才发起中断，避免重复发起中断请求</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//且仅在 w.tryLock() 能成功（即 Worker 并非处于执行任务的阶段）才发起中断，避免任务还未执行完就被打断</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">.</span><span class="na">isInterrupted</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">w</span><span class="p">.</span><span class="na">tryLock</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">t</span><span class="p">.</span><span class="na">interrupt</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">SecurityException</span><span class="w"> </span><span class="n">ignore</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">w</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">onlyOne</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">break</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">mainLock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 回收线程
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param w                 Worker
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param completedAbruptly 是否是由于任务执行过程抛出异常导致需要来回收线程
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                          true：由于任务抛出异常
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                          false：由于线程空闲时间达到限制条件
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">processWorkerExit</span><span class="p">(</span><span class="n">Worker</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="n">completedAbruptly</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">completedAbruptly</span><span class="p">)</span><span class="w"> </span><span class="c1">// If abrupt, then workerCount wasn&#39;t adjusted</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">decrementWorkerCount</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">ReentrantLock</span><span class="w"> </span><span class="n">mainLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">mainLock</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">mainLock</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//更新线程池总共处理过的任务数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">completedTaskCount</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">w</span><span class="p">.</span><span class="na">completedTasks</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//移除此线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">workers</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">w</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">mainLock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">tryTerminate</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctl</span><span class="p">.</span><span class="na">get</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">runStateLessThan</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">STOP</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//在任务队列不为空的时候，需要确保至少有一个线程可以来处理任务，否则就还是需要再创建一个新线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">completedAbruptly</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allowCoreThreadTimeOut</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">0</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">corePoolSize</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">min</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">workQueue</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">workerCountOf</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">min</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="p">;</span><span class="w"> </span><span class="c1">// replacement not needed</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">addWorker</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>除了上述几个方法会主动触发到线程回收机制外，当线程池满足以下几种情况之一时，也会进行线程的回收：</p>
<ol>
<li>非核心线程的空闲时间超出了 keepAliveTime</li>
<li>allowCoreThreadTimeOut 为 true 且核心线程的空闲时间超出了 keepAliveTime</li>
</ol>
<p>以上几种情况其触发时机主要看 <code>getTask()</code> 方法就可以。在向任务队列 workQueue 获取任务前，通过判断当前线程池的 <code>allowCoreThreadTimeOut、corePoolSize、workerCount</code> 等参数来决定是否需要对“从任务队列获取任务”这个操作进行限时。如果需要进行限时且获取任务的时间超出 keepAliveTime 的话，那就说明此线程的空闲时间已经达到限制了，需要对其进行回收</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span><span class="w"> </span><span class="n">Runnable</span><span class="w"> </span><span class="nf">getTask</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">boolean</span><span class="w"> </span><span class="n">timedOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Did the last poll() time out?</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctl</span><span class="p">.</span><span class="na">get</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">rs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">runStateOf</span><span class="p">(</span><span class="n">c</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rs</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">SHUTDOWN</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">rs</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">STOP</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">workQueue</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">decrementWorkerCount</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">wc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">workerCountOf</span><span class="p">(</span><span class="n">c</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Are workers subject to culling?</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//timed 用于标记从任务队列中取任务时是否需要进行超时控制</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//如果允许回收空闲核心线程或者是当前的线程总数已经超出 corePoolSize 了，那么就需要进行超时控制</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">boolean</span><span class="w"> </span><span class="n">timed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allowCoreThreadTimeOut</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">wc</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">corePoolSize</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//1. 线程总数超出 maximumPoolSize</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//2. 允许回收核心线程，且核心线程的空闲时间已达到限制了</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//如果以上两种情况之一有一个满足，且当前线程数大于 1 或者任务队列为空时就返回 null（如果 CAS 更新 WorkerCount 成功的话）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//避免在任务队列不为空且只有一个线程时还回收线程导致任务没人处理</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">wc</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">maximumPoolSize</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">timed</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">timedOut</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">wc</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">workQueue</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">compareAndDecrementWorkerCount</span><span class="p">(</span><span class="n">c</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">continue</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Runnable</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">timed</span><span class="w"> </span><span class="o">?</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">workQueue</span><span class="p">.</span><span class="na">poll</span><span class="p">(</span><span class="n">keepAliveTime</span><span class="p">,</span><span class="w"> </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">NANOSECONDS</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">workQueue</span><span class="p">.</span><span class="na">take</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">timedOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//如果能执行到 timedOut = true 说明是由于超时导致 poll 返回了 null</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//之所以不在判断到 r 不为 null 的时候就直接 return 出去</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//是因为可能在获取任务的过程中外部又重新修改了 allowCoreThreadTimeOut 和 corePoolSize 等配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//导致此时又不需要回收此线程了，所以就在下一次循环时再判断是否回收此线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">retry</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">timedOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>以上就是线程池基本所有的线程回收流程。线程回收机制有助于节约系统资源，但如果 <strong>corePoolSize、keepAliveTime</strong> 等参数设置得和系统的实际运行情况不符的话，反而会导致线程频繁地被创建和回收，反而加大了资源开销</p>
<h2 id="5线程池的关闭流程">5、线程池的关闭流程</h2>
<p><code>shutdown()</code> 和 <code>shutdownNow()</code> 方法可以用来关闭和停止线程池</p>
<ul>
<li>shutdown()。使用该方法，已提交的任务会被继续执行，而后续新提交的任务则会走拒绝策略。该方法返回时，线程池可能尚未走向终止状态 TERMINATED，即线程池中可能还有线程还在执行任务</li>
<li>shutdownNow()。使用该方法，正在运行的线程会尝试停止，任务队列中的任务也不会执行而是作为方法返回值返回。由于该方法是通过调用 <code>Thread.interrupt()</code> 方法来停止正在执行的任务的，因此某些无法响应中断的任务可能需要等到任务完成后才能停止线程</li>
</ul>
<p>由于这两个方法调用过后线程池都不会再接收新任务了，所以在回收空闲线程后，还需要检查下线程是否都已经回收完毕了，是的话则需要将线程池的生命周期状态向 TIDYING 和 TERMINATED 迁移</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">final</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">tryTerminate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;;)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctl</span><span class="p">.</span><span class="na">get</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//在以下几种情况不需要终止线程池：</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//1.还处于运行状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//2.已经处于 TIDYING 或 TERMINATED 状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//3.处于 SHUTDOWN 状态且还有待处理的任务</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isRunning</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">runStateAtLeast</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">TIDYING</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">(</span><span class="n">runStateOf</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SHUTDOWN</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="n">workQueue</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">()))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//在达到 TIDYING 状态前需要确保所有线程都被关闭了</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">workerCountOf</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Eligible to terminate</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">interruptIdleWorkers</span><span class="p">(</span><span class="n">ONLY_ONE</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">final</span><span class="w"> </span><span class="n">ReentrantLock</span><span class="w"> </span><span class="n">mainLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">mainLock</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">mainLock</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ctl</span><span class="p">.</span><span class="na">compareAndSet</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">ctlOf</span><span class="p">(</span><span class="n">TIDYING</span><span class="p">,</span><span class="w"> </span><span class="n">0</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">//terminated() 方法执行完毕后，线程池状态就从 TIDYING 转为 TERMINATED 了，此时线程池就走向终止了</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">terminated</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">ctl</span><span class="p">.</span><span class="na">set</span><span class="p">(</span><span class="n">ctlOf</span><span class="p">(</span><span class="n">TERMINATED</span><span class="p">,</span><span class="w"> </span><span class="n">0</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">//唤醒所有在等待线程池 TERMINATED 的线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">termination</span><span class="p">.</span><span class="na">signalAll</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">mainLock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// else retry on failed CAS</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h2 id="6任务队列的选择">6、任务队列的选择</h2>
<p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取数据的线程会阻塞等待直到从队列获取到任务。当队列已满时，存储数据的线程会阻塞等待直到队列空出位置可以存入数据。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加数据的线程，消费者是从队列里取出数据的线程。阻塞队列就是生产者存放数据的容器，而消费者也只从容器里取数据</p>
<p>线程池实现解耦的关键就是有了 <strong>任务队列/阻塞队列</strong> 的存在。线程池中是以<strong>生产者消费者模式+阻塞队列</strong>来实现的，任务队列负责缓存外部提交的任务，线程负责从任务队列取出任务，这样客户端提交的任务就避免了和线程直接关联</p>
<p>选择不同的阻塞队列可以实现不一样的任务存取策略：</p>
<p><div class="not-prose">
<figure>
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/deee7e19ca544678bf862481adbabed0~tplv-k3u1fbpfcp-zoom-1.image"
      alt="" 
      loading="lazy"
    >
  </figure></div>
</p>
<h2 id="7任务的拒绝策略">7、任务的拒绝策略</h2>
<p>随着客户端不断地提交任务，当前线程池大小也会不断增加。在当前线程池大小达到 corePoolSize 的时候，新提交的任务会被缓存到任务队列之中，由线程后续不断从队列中取出任务并执行。当任务队列满了之后，线程池就会创建非核心线程。当线程总数达到 maximumPoolSize 且所有线程都处于工作状态，同时任务队列也满了后，客户端再次提交任务时就会被拒绝。而被拒绝的任务具体的处理策略则由 <code>RejectedExecutionHandler</code> 来进行定义</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">RejectedExecutionHandler</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">rejectedExecution</span><span class="p">(</span><span class="n">Runnable</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">ThreadPoolExecutor</span><span class="w"> </span><span class="n">executor</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>当客户端提交的任务被拒绝时，线程池关联的 RejectedExecutionHandler 对象的 <code>rejectedExecution</code> 方法就会被调用，相应的拒绝策略可以由客户端来指定</p>
<p>ThreadPoolExecutor 提供了以下几种拒绝策略，默认使用的是 AbortPolicy</p>
<table>
  <thead>
      <tr>
          <th>实现类</th>
          <th>策略</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>AbortPolicy</td>
          <td>直接抛出异常，是 ThreadPoolExecutor 的默认策略</td>
      </tr>
      <tr>
          <td>DiscardPolicy</td>
          <td>直接丢弃该任务，不做任何响应也不会抛出异常</td>
      </tr>
      <tr>
          <td>DiscardOldestPolicy</td>
          <td>如果线程池未被停止，则将工作队列中最老的任务丢弃，然后尝试接纳该任务</td>
      </tr>
      <tr>
          <td>CallerRunsPolicy</td>
          <td>如果线程池未被停止，则直接在客户端线程上执行该任务</td>
      </tr>
  </tbody>
</table>
<p>任务的拒绝策略只会在提交任务的时候被触发，即只在 <code>execute(Runnable command)</code> 方法中被触发到。<code>execute(Runnable command)</code> 方法会判断当前状态是否允许接受该任务，如果不允许的话则会走拒绝任务的流程</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="n">Runnable</span><span class="w"> </span><span class="n">command</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">command</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">NullPointerException</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctl</span><span class="p">.</span><span class="na">get</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">workerCountOf</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">corePoolSize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">addWorker</span><span class="p">(</span><span class="n">command</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctl</span><span class="p">.</span><span class="na">get</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isRunning</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">workQueue</span><span class="p">.</span><span class="na">offer</span><span class="p">(</span><span class="n">command</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">//线程池还处于运行状态且成功添加任务到任务队列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//需要重新检查下运行状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//因为等执行到这里时，线程池可能被其它线程关闭了</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">recheck</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctl</span><span class="p">.</span><span class="na">get</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//1、如果线程池已经处于非运行状态了</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//1.1、如果移除 command 成功，则走拒绝策略</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//1.2、如果移除 command 失败（因为 command 可能已经被其它线程拿去执行了），则走第 3 步</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//2、如果线程池还处于运行状态，则走第 3 步</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//3、如果当前线程数量为 0，则创建线程进行处理</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//第 3 步的意义在于：corePoolSize 可以被设为 0，所以这里需要检查下，在需要的时候创建一个非核心线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="w"> </span><span class="n">isRunning</span><span class="p">(</span><span class="n">recheck</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">remove</span><span class="p">(</span><span class="n">command</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">reject</span><span class="p">(</span><span class="n">command</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">workerCountOf</span><span class="p">(</span><span class="n">recheck</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">addWorker</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//如果线程池处于非运行状态了，或者是处于运行状态但队列已满了，此时就会走到这里</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//在这里尝试创建一个非核心线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//如果线程创建失败，说明要么是线程池当前状态大于等于 STOP，或者是任务队列已满且线程总数达到 maximumPoolSize 了</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//此时就走拒绝策略</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">addWorker</span><span class="p">(</span><span class="n">command</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">reject</span><span class="p">(</span><span class="n">command</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">final</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">reject</span><span class="p">(</span><span class="n">Runnable</span><span class="w"> </span><span class="n">command</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">handler</span><span class="p">.</span><span class="na">rejectedExecution</span><span class="p">(</span><span class="n">command</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h2 id="8监控线程池的运行状态">8、监控线程池的运行状态</h2>
<p>ThreadPoolExecutor 提供了多个配置参数以便满足多种不同的需求，这些配置参数包含：<strong>corePoolSize、maximumPoolSize、keepAliveTime、allowCoreThreadTimeOut 等</strong>。但很多时候我们一开始使用线程池时并不知道该如何配置参数才最为适应当前需求，那么就只能通过监控线程池的运行状态来进行考察，最终得到一份最合理的配置参数</p>
<p>可以通过 ThreadPoolExecutor 的以下几个属性来监控线程池的运行状态：</p>
<ol>
<li>taskCount：线程池已执行结束（不管成功与否）的任务数加上任务队列中目前包含的任务数</li>
<li>completedTaskCount：线程池已执行结束（不管成功与否）的任务数，小于等于 taskCount</li>
<li>largestPoolSize：线程池曾经创建过的最大线程数量。如果该数值等于 maximumPoolSize 那就说明线程池曾经满过</li>
<li>getPoolSize()：获取当前线程总数</li>
<li>getActiveCount()：获取当前正在执行任务的线程总数</li>
</ol>
<p>此外，ThreadPoolExecutor 也预留了几个钩子方法可以由子类去实现。通过以下几个方法，就可以实现每个任务开始执行前和执行后，以及线程池走向终止时插入一些自定义的监控代码，以此来实现：<strong>计算任务的平均执行时间、最小执行时间和最大执行时间</strong>等功能</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">protected</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">beforeExecute</span><span class="p">(</span><span class="n">Thread</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">Runnable</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">protected</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">afterExecute</span><span class="p">(</span><span class="n">Runnable</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">Throwable</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">protected</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">terminated</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h1 id="四executors">四、Executors</h1>
<p>Executors 是 JDK 提供的一个线程池创建工具类，封装了很多个创建 ExecutorService 实例的方法，这里就来介绍下这几个方法，这些线程池的差别主要都是由于选择了不同的任务队列导致的，读者需要先认识下以下几种任务队列</p>
<p><div class="not-prose">
<figure>
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b34aa0ed8322449d821b8f07666a66e2~tplv-k3u1fbpfcp-zoom-1.image"
      alt="" 
      loading="lazy"
    >
  </figure></div>
</p>
<p><code>newFixedThreadPool</code>方法创建的线程池，核心线程数和最大线程数都是 nThreads，所以线程池在任何时候最多也只会有 nThreads 个线程在同时运行，且在停止线程池前所有线程都不会被回收。LinkedBlockingQueue 的默认容量是 Integer.MAX_VALUE，近乎无限，在线程繁忙的情况下有可能导致等待处理的任务持续堆积，使得系统频繁 GC，最终导致 OOM</p>
<p>此类线程池适合用于希望所有任务都能够被执行的情况</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">ExecutorService</span><span class="w"> </span><span class="nf">newFixedThreadPool</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">nThreads</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">nThreads</span><span class="p">,</span><span class="w"> </span><span class="n">nThreads</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                  </span><span class="n">0L</span><span class="p">,</span><span class="w"> </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">MILLISECONDS</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                  </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedBlockingQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">ExecutorService</span><span class="w"> </span><span class="nf">newFixedThreadPool</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">nThreads</span><span class="p">,</span><span class="w"> </span><span class="n">ThreadFactory</span><span class="w"> </span><span class="n">threadFactory</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">nThreads</span><span class="p">,</span><span class="w"> </span><span class="n">nThreads</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                  </span><span class="n">0L</span><span class="p">,</span><span class="w"> </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">MILLISECONDS</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                  </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedBlockingQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                  </span><span class="n">threadFactory</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><code>newSingleThreadExecutor</code>方法创建的线程池，核心线程数和最大线程数都是 1，所以线程池在任何时候最多也只会有 1 个线程在同时运行，且在停止线程池前所有线程都不会被回收。由于使用了 LinkedBlockingQueue，所以在极端情况下也是有发生 OOM 的可能</p>
<p>此类线程池适合用于执行需要串行处理的任务，或者是任务的提交间隔比任务的执行时间长的情况</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">ExecutorService</span><span class="w"> </span><span class="nf">newSingleThreadExecutor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">FinalizableDelegatedExecutorService</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">1</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="n">0L</span><span class="p">,</span><span class="w"> </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">MILLISECONDS</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedBlockingQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span><span class="p">()));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">ExecutorService</span><span class="w"> </span><span class="nf">newSingleThreadExecutor</span><span class="p">(</span><span class="n">ThreadFactory</span><span class="w"> </span><span class="n">threadFactory</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">FinalizableDelegatedExecutorService</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">1</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="n">0L</span><span class="p">,</span><span class="w"> </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">MILLISECONDS</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedBlockingQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="n">threadFactory</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><code>newCachedThreadPool</code>方法创建的线程池，核心线程数是 0，最大线程数是 Integer.MAX_VALUE，所以允许同时运行的线程数量近乎无限。再加上 SynchronousQueue 是一个不储存元素的阻塞队列，每当有新任务到来时，如果当前没有空闲线程的话就会马上启动一个新线程来执行任务，这使得任务总是能够很快被执行，提升了响应速度，但同时也存在由于要执行的任务过多导致一直创建线程的可能性，这在任务耗时过长且任务量过多的情况下也可能导致 OOM</p>
<p>此类线程池适合用于对任务的处理速度要求比较高的情况</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">ExecutorService</span><span class="w"> </span><span class="nf">newCachedThreadPool</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">0</span><span class="p">,</span><span class="w"> </span><span class="n">Integer</span><span class="p">.</span><span class="na">MAX_VALUE</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                  </span><span class="n">60L</span><span class="p">,</span><span class="w"> </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">SECONDS</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                  </span><span class="k">new</span><span class="w"> </span><span class="n">SynchronousQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">ExecutorService</span><span class="w"> </span><span class="nf">newCachedThreadPool</span><span class="p">(</span><span class="n">ThreadFactory</span><span class="w"> </span><span class="n">threadFactory</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">0</span><span class="p">,</span><span class="w"> </span><span class="n">Integer</span><span class="p">.</span><span class="na">MAX_VALUE</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                  </span><span class="n">60L</span><span class="p">,</span><span class="w"> </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">SECONDS</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                  </span><span class="k">new</span><span class="w"> </span><span class="n">SynchronousQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                  </span><span class="n">threadFactory</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><code>newScheduledThreadPool</code>方法创建的线程池对应的是 ScheduledThreadPoolExecutor，其继承于 ThreadPoolExecutor 并实现了 ScheduledExecutorService 接口，在线程池的基础上扩展实现了执行定时任务的能力。ScheduledThreadPoolExecutor 的核心线程数由入参 corePoolSize 决定，最大线程数是 Integer.MAX_VALUE，keepAliveTime 是 0 秒，所以该线程池可能同时运行近乎无限的线程，但一旦当前没有待执行的任务的话，线程就会马上被回收</p>
<p>此类线程池适合用于需要定时多次执行特定任务的情况</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">ScheduledExecutorService</span><span class="w"> </span><span class="nf">newScheduledThreadPool</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">corePoolSize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ScheduledThreadPoolExecutor</span><span class="p">(</span><span class="n">corePoolSize</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">ScheduledExecutorService</span><span class="w"> </span><span class="nf">newScheduledThreadPool</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">corePoolSize</span><span class="p">,</span><span class="w"> </span><span class="n">ThreadFactory</span><span class="w"> </span><span class="n">threadFactory</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ScheduledThreadPoolExecutor</span><span class="p">(</span><span class="n">corePoolSize</span><span class="p">,</span><span class="w"> </span><span class="n">threadFactory</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><code>newSingleThreadScheduledExecutor</code>方法 <code>newScheduledThreadPool</code> 方法基本一样，只是直接指定了核心线程数为 1</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">ScheduledExecutorService</span><span class="w"> </span><span class="nf">newSingleThreadScheduledExecutor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">DelegatedScheduledExecutorService</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">ScheduledThreadPoolExecutor</span><span class="p">(</span><span class="n">1</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">ScheduledExecutorService</span><span class="w"> </span><span class="nf">newSingleThreadScheduledExecutor</span><span class="p">(</span><span class="n">ThreadFactory</span><span class="w"> </span><span class="n">threadFactory</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">DelegatedScheduledExecutorService</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">ScheduledThreadPoolExecutor</span><span class="p">(</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">threadFactory</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h1 id="五线程池故障">五、线程池故障</h1>
<h2 id="1线程池死锁">1、线程池死锁</h2>
<p>多个线程会因为循环等待对方持有的排他性资源而导致死锁，线程池也可能会因为多个任务间的相互依赖而导致<strong>线程池死锁</strong>。例如，如果在线程池中执行的任务 A 在其执行过程中又向同个线程池提交了任务 B，且任务 A 的执行结束又依赖于任务 B 的执行结果，那么就可能出现这样的一种极端情形：线程池中的所有正在执行任务的线程都在等待其它任务的处理结果，而这些任务均在任务队列中处于待执行状态，且由于线程总数已经达到线程池的最大线程数量限制，所以任务队列中的任务就会一直无法被执行，最终导致所有任务都无法完成，从而形成线程池死锁</p>
<p>因此，提交给同一个线程池的任务必须是没有互相依赖关系的。对于有依赖关系的任务，应该提交给不同的线程池，以此来避免死锁的发生</p>
<h2 id="2线程泄漏">2、线程泄漏</h2>
<p><strong>线程泄漏</strong>指由于某种原因导致线程池中实际可用的线程变少的一种异常情况。如果线程泄漏持续存在，那么线程池中的线程会越来越少，最终使得线程池再也无法处理任务。导致线程泄露的原因可能有两种：由于线程异常自动终止或者由于程序缺陷导致线程处于非有效运行状态。前者通常是由于 <code>Thread.run()</code> 方法中没有捕获到任务抛出的 Exception 或者 Error 导致的，使得相应线程被提前终止而没有相应更新线程池当前的线程数量，ThreadPoolExecutor 内部已经对这种情形进行了预防。后者可能是由于客户端提交的任务包含阻塞操作（Object.wait() 等操作），而该操作又没有相应的时间或者条件方面的限制，那么就有可能导致线程一直处于等待状态而无法执行其它任务，这样最终也是形成了线程泄漏</p>
<h1 id="六总结">六、总结</h1>
<p>线程池通过复用一定数量的线程来执行不断被提交的任务，除了可以节约线程这种有限而昂贵的资源外，还包含以下好处：</p>
<ul>
<li>提高响应速度。ThreadPoolExecutor 提供了预先创建一定数量的线程的功能，使得后续提交的任务可以立即被执行而无须等待线程被创建，从而提高了系统的响应速度</li>
<li>抵消线程创建的开销。一个线程可以先后用于执行多个任务，那创建线程带来的成本（资源和时间）就可以看做是被平摊到其执行的所有任务中。一个线程执行的任务越多，那么创建该线程的“性价比”就越高</li>
<li>封装了任务的具体执行过程。线程池封装了每个线程在创建、管理、复用、回收等各个阶段的逻辑，使得客户端代码只需要提交任务和获取任务的执行结果，而无须关心任务的具体执行过程。即使后续想要将任务的执行方式从并发改为串行，往往也只需要修改线程池内部的处理逻辑即可，而无需修改客户端代码</li>
<li>减少销毁线程的开销。JVM 在销毁一个已经停止的线程时也有着资源和时间方面的开销，采用线程池可以避免频繁地创建线程，从而减少了销毁线程的次数，减少了相应开销</li>
</ul>
<h1 id="七参考资料">七、参考资料</h1>
<p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener">Java线程池实现原理及其在美团业务中的实践</a>
</p>

      </article>

      


  
<script type="text/javascript">
  (function() {
    const themeToggle = document.querySelector('.darkmode-toggle input');
    const light = 'light';
    const dark = 'dark';
    let isDark = localStorage.theme === dark || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches);
    let theme = isDark ? dark : light;

    const s = document.createElement('script');
    s.type = 'text/javascript';
    const dataset = {
        repo: 'tomowang\/hugo-theme-tailwind',
        repoId: 'R_kgDOKjVJHA',
        category: 'Announcements',
        categoryId: 'DIC_kwDOKjVJHM4CafqS',
        mapping: 'pathname',
        reactionsEnabled: '1',
        emitMetadata: '0',
        theme: theme,
        lang: 'en',
    };
    s.src = 'https://giscus.app/client.js';
    s.crossorigin = 'anonymous';
    s.async = true;
    Object.entries(dataset).forEach(function(a) {
        return s.dataset[a[0]] = a[1];
    });

    const curScriptElement = document.currentScript;
    curScriptElement.parentNode.insertBefore(s, curScriptElement);

    function sendMessage(message) {
      const iframe = document.querySelector('iframe.giscus-frame');
      
      if (!iframe) return;
      iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
    }

    themeToggle.addEventListener('change', function () {
      if (this.checked) {
        theme = dark;
      } else {
        theme = light;
      }
      sendMessage({
        setConfig: {
          theme: theme,
        }
      });
    });
  })();
</script>
  



    </div>
  </div>
</div>

  </main>
  <footer class="flex flex-none justify-center">
    <section class="flex flex-col md:flex-row mx-2 md:mx-0 gap-2 md:gap-0 justify-between w-full max-w-4xl lg:max-w-5xl py-6 text-slate-500 dark:text-slate-300">
  <div class="flex flex-row">
    
  
  
    <a href="https://x.com/hqqich" target="_blank" title="X" class="flex flex-row mr-2">
      <span class="hidden">X</span>
      <i class="h-6 w-6 flex-none"> <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-x" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M4 4l11.733 16h4.267l-11.733 -16z"></path>
   <path d="M4 20l6.768 -6.768m2.46 -2.46l6.772 -6.772"></path>
</svg>
 </i>
    </a>
  
  
  
    <a href="https://github.com/hqqich" target="_blank" title="Github" class="flex flex-row mr-2">
      <span class="hidden">Github</span>
      <i class="h-6 w-6 flex-none"> <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"></path>
</svg>
 </i>
    </a>
  
  


  </div>
  <div class="grow"></div>
  <div class="flex flex-row">
    <i class="h-6 w-6 flex-none"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0"></path>
   <path d="M14 9.75a3.016 3.016 0 0 0 -4.163 .173a2.993 2.993 0 0 0 0 4.154a3.016 3.016 0 0 0 4.163 .173"></path>
</svg>
</i> 2022 - 2025 Hqqich
    
  </div>
  
  <div class="flex flex-row">
    <span class="ml-0 pl-0 md:ml-2 md:pl-2 border-l-0 md:border-l border-slate-300 dark:border-slate-400">
      Powered by <a href="https://gohugo.io" target="_blank" rel="noopener" class="underline">Hugo</a> <span class="text-red-600">&hearts;</span> <a href="https://github.com/tomowang/hugo-theme-tailwind" target="_blank" rel="noopener" class="underline">Tailwind</a>
    </span>
  </div>
  
</section>

  </footer>
  <script src="/hugo-blog/public/main.js"></script>

<div class="hidden top-1 right-1" id="code-copy">
  <i class="h-6 w-6 block">
    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" />
  <path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" />
</svg>

  </i>
</div>
<div class="hidden top-1 right-1" id="code-copy-done">
  <i class="h-6 w-6 block">
    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-check" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M5 12l5 5l10 -10" />
</svg>

  </i>
</div><script src="/hugo-blog/public/code-copy.js"></script>





</body>
</html>

<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-EHXM4GYP5W"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-EHXM4GYP5W');
</script>
<!-- End Google Analytics -->



<!-- Baidu Analytics -->
<script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?0a6515fb9c839d6a56d4cfd8b7d243d4";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>
<!-- End Baidu Analytics -->


<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

  <meta name="author" content="hqqich">


  <meta name="subtitle" content="忙碌把时光缩短, 苦难把岁月拉长">




<title>主流开源库源码分析（11）OkHttp 源码详解 | Hexo-blog</title>



<link rel="icon" href="/hexo-blog/public/favicon.ico">



<link rel="stylesheet" href="/hexo-blog/public/css/main.css">


<link rel="stylesheet" href="/hexo-blog/public/lib/nprogress/nprogress.css">



<script src="/hexo-blog/public/lib/jquery.min.js"></script>


<script src="/hexo-blog/public/lib/iconify-icon.min.js"></script>


<script src="https://cdn.tailwindcss.com?plugins=typography"></script>
<script>
  tailwind.config = {
    darkMode: "class",
  };
</script>


<script src="/hexo-blog/public/lib/nprogress/nprogress.js"></script>

<script>
  $(document).ready(() => {
    NProgress.configure({
      showSpinner: false,
    });
    NProgress.start();
    $("#nprogress .bar").css({
      background: "#de7441",
    });
    $("#nprogress .peg").css({
      "box-shadow": "0 0 2px #de7441, 0 0 4px #de7441",
    });
    $("#nprogress .spinner-icon").css({
      "border-top-color": "#de7441",
      "border-left-color": "#de7441",
    });
    setTimeout(function () {
      NProgress.done();
      $(".fade").removeClass("out");
    }, 800);
  });
</script>

<script>
  (function () {
    const prefersDark =
      window.matchMedia &&
      window.matchMedia("(prefers-color-scheme: dark)").matches;
    const setting = localStorage.getItem("hexo-color-scheme") || "auto";
    if (setting === "dark" || (prefersDark && setting !== "light"))
      document.documentElement.classList.toggle("dark", true);
    let isDark = document.documentElement.classList.contains("dark");
  })();

  $(document).ready(function () {
    // init icon
    const prefersDark =
      window.matchMedia &&
      window.matchMedia("(prefers-color-scheme: dark)").matches;
    const isDark = document.documentElement.classList.contains("dark");
    $("#theme-icon").attr("icon", isDark ? "ri:moon-line" : "ri:sun-line");

    function toggleGiscusTheme() {
      const isDark = document.documentElement.classList.contains("dark");
      const giscusFrame = document.querySelector("iframe.giscus-frame");
      if (giscusFrame) {
        giscusFrame.contentWindow.postMessage(
          {
            giscus: {
              setConfig: {
                theme: isDark ? "dark" : "light",
              },
            },
          },
          "https://giscus.app"
        );
      }
    }

    // toggle dark mode
    function toggleDark() {
      let isDark = document.documentElement.classList.contains("dark");
      const setting = localStorage.getItem("hexo-color-scheme") || "auto";
      isDark = !isDark;
      document.documentElement.classList.toggle("dark", isDark);
      $("#theme-icon").attr("icon", isDark ? "ri:moon-line" : "ri:sun-line");
      if (prefersDark === isDark) {
        localStorage.setItem("hexo-color-scheme", "auto");
      } else {
        localStorage.setItem("hexo-color-scheme", isDark ? "dark" : "light");
      }
      toggleGiscusTheme();
    }

    // listen dark mode change
    window
      .matchMedia("(prefers-color-scheme: dark)")
      .addEventListener("change", (e) => {
        const setting = localStorage.getItem("hexo-color-scheme") || "auto";
        if (setting === "auto") {
          document.documentElement.classList.toggle("dark", e.matches);
          $("#theme-icon").attr(
            "icon",
            e.matches ? "ri:moon-line" : "ri:sun-line"
          );
          toggleGiscusTheme();
        }
      });

    $("#toggle-dark").click((event) => {
      const isAppearanceTransition = document.startViewTransition && !window.matchMedia('(prefers-reduced-motion: reduce)').matches
      if (!isAppearanceTransition) {
        toggleDark()
        return
      }
      const x = event.clientX
      const y = event.clientY
      const endRadius = Math.hypot(
        Math.max(x, innerWidth - x),
        Math.max(y, innerHeight - y),
      )
      const transition = document.startViewTransition(async () => {
        toggleDark()
      })

      transition.ready
        .then(() => {
          const isDark = document.documentElement.classList.contains("dark")
          const clipPath = [
            `circle(0px at ${x}px ${y}px)`,
            `circle(${endRadius}px at ${x}px ${y}px)`,
          ]
          document.documentElement.animate(
            {
              clipPath: isDark
                ? [...clipPath].reverse()
                : clipPath,
            },
            {
              duration: 400,
              easing: 'ease-out',
              pseudoElement: isDark
                ? '::view-transition-old(root)'
                : '::view-transition-new(root)',
            },
          )
        })
    });
  });
</script>




<meta name="generator" content="Hexo 7.3.0"></head>
<body class="font-sans bg-white dark:bg-zinc-900 text-gray-700 dark:text-gray-200 relative">
  <header class="fixed w-full px-5 py-1 z-10 backdrop-blur-xl backdrop-saturate-150 border-b border-black/5">
  <div class="max-auto">
    <nav class="flex items-center text-base">
      <a href="/hexo-blog/public/" class="group">
        <h2 class="font-medium tracking-tighterp text-l p-2">
          <img class="w-5 mr-2 inline-block transition-transform group-hover:rotate-[30deg]" id="logo" src="https://moe-counter-vercel-gamma.vercel.app/a?theme=rule34" alt="Hexo-blog" />
          Hexo-blog
        </h2>
      </a>
      <div id="header-title" class="opacity-0 md:ml-2 md:mt-[0.1rem] text-xs font-medium whitespace-nowrap overflow-hidden overflow-ellipsis">
        主流开源库源码分析（11）OkHttp 源码详解
      </div>
      <div class="flex-1"></div>
      <div class="flex items-center gap-3">
        
          <a class="hidden sm:flex" href="/hexo-blog/public/archives">Posts</a>
        
          <a class="hidden sm:flex" href="/hexo-blog/public/category">Categories</a>
        
          <a class="hidden sm:flex" href="/hexo-blog/public/tag">Tags</a>
        
        
          
            <a class="w-5 h-5 hidden sm:flex" title="Github" target="_blank" rel="noopener" href="https://github.com/hqqich">
              <iconify-icon width="20" icon="ri:github-line"></iconify-icon>
            </a>
          
        
        <a class="w-5 h-5 hidden sm:flex" title="Github" href="rss2.xml">
          <iconify-icon width="20" icon="ri:rss-line"></iconify-icon>
        </a>
        <a class="w-5 h-5" title="toggle theme" id="toggle-dark">
          <iconify-icon width="20" icon="" id="theme-icon"></iconify-icon>
        </a>
      </div>
      <div class="flex items-center justify-center gap-3 ml-3 sm:hidden">
        <span class="w-5 h-5" aria-hidden="true" role="img" id="open-menu">
          <iconify-icon width="20" icon="carbon:menu" ></iconify-icon>
        </span>
        <span class="w-5 h-5 hidden" aria-hidden="true" role="img" id="close-menu">
          <iconify-icon  width="20" icon="carbon:close" ></iconify-icon>
        </span>
      </div>
    </nav>
  </div>
</header>
<div id="menu-panel" class="h-0 overflow-hidden sm:hidden fixed left-0 right-0 top-12 bottom-0 z-10">
  <div id="menu-content" class="relative z-20 bg-white/80 px-6 sm:px-8 py-2 backdrop-blur-xl -translate-y-full transition-transform duration-300">
    <ul class="nav flex flex-col sm:flex-row text-sm font-medium">
      
        <li class="nav-portfolio sm:mx-2 border-b sm:border-0 border-black/5 last:border-0 hover:text-main">
          <a href="/hexo-blog/public/archives" class="flex h-12 sm:h-auto items-center">Posts</a>
        </li>
      
        <li class="nav-portfolio sm:mx-2 border-b sm:border-0 border-black/5 last:border-0 hover:text-main">
          <a href="/hexo-blog/public/category" class="flex h-12 sm:h-auto items-center">Categories</a>
        </li>
      
        <li class="nav-portfolio sm:mx-2 border-b sm:border-0 border-black/5 last:border-0 hover:text-main">
          <a href="/hexo-blog/public/tag" class="flex h-12 sm:h-auto items-center">Tags</a>
        </li>
      
    </ul>
  </div>
  <div class="mask bg-black/20 absolute inset-0"></div>
</div>

  <main class="pt-14">
    <!-- css -->

<link rel="stylesheet" href="/hexo-blog/public/lib/fancybox/fancybox.min.css">


<link rel="stylesheet" href="/hexo-blog/public/lib/tocbot/tocbot.min.css">

<!-- toc -->

  <!-- tocbot -->
<nav class="post-toc toc text-sm w-48 relative top-32 right-0 opacity-70 hidden lg:block" style="position: fixed !important;"></nav>


<section class="px-6 max-w-prose mx-auto md:px-0">
  <!-- header -->
  <header class="overflow-hidden pt-6 pb-6 md:pt-12">
    <div class="pt-4 md:pt-6">
      <h1 id="article-title" class="text-[2rem] font-bold leading-snug mb-4 md:mb-6 md:text-[2.6rem]">
        主流开源库源码分析（11）OkHttp 源码详解
      </h1>
      <div>
        <section class="flex items-center gap-3 text-sm">
          <span class="flex items-center gap-1">
            <iconify-icon width="18" icon="carbon-calendar" ></iconify-icon>
            <time>2025-03-02</time>
          </span>
          <span class="text-gray-400">·</span>
          <span class="flex items-center gap-1">
            <iconify-icon width="18" icon="ic:round-access-alarm" ></iconify-icon>
            <span>30 min</span>
          </span>
          <span class="text-gray-400">·</span>
          <span class="flex items-center gap-1">
            <iconify-icon width="18" icon="icon-park-outline:font-search" ></iconify-icon>
            <span>7k words</span>
          </span>
          
            <span class="text-gray-400">·</span>
            <span class="flex items-center gap-1">
              <iconify-icon width="16" icon="icon-park-outline:box" class="mr-2"></iconify-icon>
              <a class="article-category-link" href="/hexo-blog/public/categories/kotlin/">kotlin</a>
            </span>
          
        </section>
      </div>
    </div>
  </header>
  <!-- content -->
  <article class="post-content prose m-auto slide-enter-content dark:prose-invert">
    <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">                        \\           <span class="comment">//</span></span><br><span class="line">                         \\  .ooo.  <span class="comment">//</span></span><br><span class="line">                          .@@@@@@@@@.</span><br><span class="line">                        :@@@@@@@@@@@@@:</span><br><span class="line">                       :@@. <span class="string">&#x27;@@@@@&#x27;</span> .@@:</span><br><span class="line">                       @@@@@@@@@@@@@@@@@</span><br><span class="line">                       @@@@@@@@@@@@@@@@@</span><br><span class="line"></span><br><span class="line">                  :@@ :@@@@@@@@@@@@@@@@@. @@:</span><br><span class="line">                  @@@ <span class="string">&#x27;@@@@@@@@@@@@@@@@@, @@@</span></span><br><span class="line"><span class="string">                  @@@ &#x27;</span>@@@@@@@@@@@@@@@@@, @@@</span><br><span class="line">                  @@@ <span class="string">&#x27;@@@@@@@@@@@@@@@@@, @@@</span></span><br><span class="line"><span class="string">                  @@@ &#x27;</span>@@@@@@@@@@@@@@@@@, @@@</span><br><span class="line">                  @@@ <span class="string">&#x27;@@@@@@@@@@@@@@@@@, @@@</span></span><br><span class="line"><span class="string">                  @@@ &#x27;</span>@@@@@@@@@@@@@@@@@, @@@</span><br><span class="line">                       @@@@@@@@@@@@@@@@@</span><br><span class="line">                       <span class="string">&#x27;@@@@@@@@@@@@@@@&#x27;</span></span><br><span class="line">                          @@@@   @@@@</span><br><span class="line">                          @@@@   @@@@</span><br><span class="line">                          @@@@   @@@@</span><br><span class="line">                          <span class="string">&#x27;@@&#x27;</span>   <span class="string">&#x27;@@&#x27;</span></span><br><span class="line"></span><br><span class="line">    :@@@.</span><br><span class="line">  .@@@@@@@:   +@@       `@@      @@`   @@     @@</span><br><span class="line"> .@@@@<span class="string">&#x27;@@@@:  +@@       `@@      @@`   @@     @@</span></span><br><span class="line"><span class="string"> @@@     @@@  +@@       `@@      @@`   @@     @@</span></span><br><span class="line"><span class="string">.@@       @@: +@@   @@@ `@@      @@` @@@@@@ @@@@@@  @@;@@@@@</span></span><br><span class="line"><span class="string">@@@       @@@ +@@  @@@  `@@      @@` @@@@@@ @@@@@@  @@@@@@@@@</span></span><br><span class="line"><span class="string">@@@       @@@ +@@ @@@   `@@@@@@@@@@`   @@     @@    @@@   :@@</span></span><br><span class="line"><span class="string">@@@       @@@ +@@@@@    `@@@@@@@@@@`   @@     @@    @@#    @@+</span></span><br><span class="line"><span class="string">@@@       @@@ +@@@@@+   `@@      @@`   @@     @@    @@:    @@#</span></span><br><span class="line"><span class="string"> @@:     .@@` +@@@+@@   `@@      @@`   @@     @@    @@#    @@+</span></span><br><span class="line"><span class="string"> @@@.   .@@@  +@@  @@@  `@@      @@`   @@     @@    @@@   ,@@</span></span><br><span class="line"><span class="string">  @@@@@@@@@   +@@   @@@ `@@      @@`   @@@@   @@@@  @@@@#@@@@</span></span><br><span class="line"><span class="string">   @@@@@@@    +@@   #@@ `@@      @@`   @@@@:  @@@@: @@&#x27;</span>@@@@@</span><br><span class="line">                                                    @@:</span><br><span class="line">                                                    @@:</span><br><span class="line">                                                    @@:</span><br></pre></td></tr></table></figure>

<blockquote>
<p>公众号：<a target="_blank" rel="noopener" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adbc507fc3704fd8955aae739a433db2~tplv-k3u1fbpfcp-zoom-1.image">字节数组</a></p>
<p>希望对你有所帮助 🤣🤣</p>
</blockquote>
<blockquote>
<p>对于 Android Developer 来说，很多开源库都是属于<strong>开发必备</strong>的知识点，从使用方式到实现原理再到源码解析，这些都需要我们有一定程度的了解和运用能力。所以我打算来写一系列关于开源库<strong>源码解析</strong>和<strong>实战演练</strong>的文章，初定的目标是 <strong>EventBus、ARouter、LeakCanary、Retrofit、Glide、OkHttp、Coil</strong> 等七个知名开源库，希望对你有所帮助 🤣🤣</p>
</blockquote>
<p>本文基于 OkHttp 的以下版本进行讲解。值得一提的是，OkHttp 和 OkIO 目前已经被官方用 Kotlin 语言重写了一遍，所以还没学 Kotlin 的同学可能连源码都比较难看懂了，Kotlin 入门可以看我的这篇文章：<a target="_blank" rel="noopener" href="https://juejin.im/post/6880602489297895438">两万六千字带你 Kotlin 入门</a></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;com.squareup.okhttp3:okhttp:4.9.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先来看一个小例子，后面的讲解都会基于这个例子涉及到的模块来展开</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: leavesCZY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Github</span>：https://github.com/leavesCZY</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> URL = <span class="string">&quot;https://publicobject.com/helloworld.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> okHttClient = OkHttpClient.Builder()</span><br><span class="line">        .connectTimeout(Duration.ofSeconds(<span class="number">10</span>))</span><br><span class="line">        .readTimeout(Duration.ofSeconds(<span class="number">10</span>))</span><br><span class="line">        .writeTimeout(Duration.ofSeconds(<span class="number">10</span>))</span><br><span class="line">        .retryOnConnectionFailure(<span class="literal">true</span>)</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">val</span> request = Request.Builder().url(URL).build()</span><br><span class="line">    <span class="keyword">val</span> call = okHttClient.newCall(request)</span><br><span class="line">    <span class="keyword">val</span> response = call.execute()</span><br><span class="line">    println(response.body?.string())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码就完成了一次 Get 请求，其包含的操作有：</p>
<ol>
<li>通过 Builder 模式得到 OkHttpClient，OkHttpClient 包含了对网络请求的全局配置信息，包括 <strong>链接超时时间、读写超时时间、链接失败重试</strong> 等各种配置</li>
<li>通过 Builder 模式得到 Request，Request 包含了本次网络请求的所有请求参数，包括 <strong>url、method、headers、body</strong> 等</li>
<li>通过 newCall 方法得到 Call，Call 就用于发起请求，可用于执行 <strong>同步请求（execute）、异步请求（enqueue）、取消请求（cancel）</strong> 等各种操作</li>
<li>调用 execute 方法发起同步请求并返回一个 Response 对象，Response 就包含了此次网络请求的所有返回信息，如果请求失败的话此方法会抛出异常</li>
<li>拿到 Response 对象的 body 并以字符串流的方式进行读取，打印结果即文章开头的 Android 机器人彩蛋</li>
</ol>
<h1 id="一、OkHttpClient"><a href="#一、OkHttpClient" class="headerlink" title="一、OkHttpClient"></a>一、OkHttpClient</h1><p>OkHttpClient 使用了 Builder 模式来完成初始化，其提供了很多的配置参数，每个选项都有默认值，但大多数时候我们还是需要来进行自定义，所以也有必要来了解下其包含的所有参数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Builder</span> <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">//调度器</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> dispatcher: Dispatcher = Dispatcher()</span><br><span class="line">    <span class="comment">//连接池</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> connectionPool: ConnectionPool = ConnectionPool()</span><br><span class="line">    <span class="comment">//拦截器列表</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> interceptors: MutableList&lt;Interceptor&gt; = mutableListOf()</span><br><span class="line">    <span class="comment">//网络拦截器列表</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> networkInterceptors: MutableList&lt;Interceptor&gt; = mutableListOf()</span><br><span class="line">    <span class="comment">//事件监听</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> eventListenerFactory: EventListener.Factory = EventListener.NONE.asFactory()</span><br><span class="line">    <span class="comment">//连接失败的时候是否重试</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> retryOnConnectionFailure = <span class="literal">true</span> </span><br><span class="line">    <span class="comment">//源服务器身份验证</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> authenticator: Authenticator = Authenticator.NONE</span><br><span class="line">    <span class="comment">//是否允许重定向</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> followRedirects = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//是否允许ssl重定向</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> followSslRedirects = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//Cookie</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> cookieJar: CookieJar = CookieJar.NO_COOKIES</span><br><span class="line">    <span class="comment">//缓存</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> cache: Cache? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//DNS</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> dns: Dns = Dns.SYSTEM</span><br><span class="line">    <span class="comment">//代理</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> proxy: Proxy? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//代理选择器</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> proxySelector: ProxySelector? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//代理身份验证</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> proxyAuthenticator: Authenticator = Authenticator.NONE</span><br><span class="line">    <span class="comment">//Socket工厂</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> socketFactory: SocketFactory = SocketFactory.getDefault()</span><br><span class="line">    <span class="comment">//安全套接层</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> sslSocketFactoryOrNull: SSLSocketFactory? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> x509TrustManagerOrNull: X509TrustManager? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> connectionSpecs: List&lt;ConnectionSpec&gt; = DEFAULT_CONNECTION_SPECS</span><br><span class="line">    <span class="comment">//HTTP 协议</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> protocols: List&lt;Protocol&gt; = DEFAULT_PROTOCOLS</span><br><span class="line">    <span class="comment">//主机名字确认</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> hostnameVerifier: HostnameVerifier = OkHostnameVerifier</span><br><span class="line">    <span class="comment">//证书链</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> certificatePinner: CertificatePinner = CertificatePinner.DEFAULT</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> certificateChainCleaner: CertificateChainCleaner? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> callTimeout = <span class="number">0</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> connectTimeout = <span class="number">10_000</span></span><br><span class="line">    <span class="comment">//读超时</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> readTimeout = <span class="number">10_000</span></span><br><span class="line">    <span class="comment">//写超时</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> writeTimeout = <span class="number">10_000</span></span><br><span class="line">    <span class="comment">//ping 之间的时间间隔</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> pingInterval = <span class="number">0</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> minWebSocketMessageToCompress = RealWebSocket.DEFAULT_MINIMUM_DEFLATE_SIZE</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> routeDatabase: RouteDatabase? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、Request"><a href="#二、Request" class="headerlink" title="二、Request"></a>二、Request</h1><p>Request 包含了网络请求时的所有请求参数，一共包含以下五个：</p>
<ol>
<li>url。即本次的网络请求地址以及可能包含的 query 键值对</li>
<li>method。即请求方式，可选参数有 GET、HEAD、POST、DELETE、PUT、PATCH</li>
<li>headers。即请求头，可用来存 token、时间戳等</li>
<li>body。即请求体</li>
<li>tags。可用来唯一标识本次请求</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">var</span> url: HttpUrl? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">var</span> method: String</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">var</span> headers: Headers.Builder</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">var</span> body: RequestBody? = <span class="literal">null</span></span><br><span class="line"><span class="comment">/** A mutable map of tags, or an immutable empty map if we don&#x27;t have any. */</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">var</span> tags: MutableMap&lt;Class&lt;*&gt;, Any&gt; = mutableMapOf()</span><br></pre></td></tr></table></figure>

<h1 id="三、Call"><a href="#三、Call" class="headerlink" title="三、Call"></a>三、Call</h1><p>当调用 <code>okHttClient.newCall(request)</code>时就会得到一个 Call 对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Prepares the [request] to be executed at some point in the future. */</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newCall</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Call = RealCall(<span class="keyword">this</span>, request, forWebSocket = <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>Call 是一个接口，我们可以将其看做是网络请求的启动器，可用于发起同步请求或异步请求，<strong>但重复发起多次请求的话会抛出异常</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Call</span> : <span class="type">Cloneable</span> &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//返回本次网络请求的 Request 对象</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">request</span><span class="params">()</span></span>: Request</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//发起同步请求，可能会抛出异常</span></span><br><span class="line">  <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//发起异步请求，通过 Callback 来回调最终结果 </span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(responseCallback: <span class="type">Callback</span>)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//取消网络请求</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">cancel</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//是否已经发起过请求</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">isExecuted</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//是否已经取消请求</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">isCanceled</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//超时计算</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">timeout</span><span class="params">()</span></span>: Timeout</span><br><span class="line"></span><br><span class="line">  <span class="comment">//同个 Call 不允许重复发起请求，想要再次发起请求可以通过此方法得到一个新的 Call 对象</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">clone</span><span class="params">()</span></span>: Call</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> Factory &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">newCall</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Call</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>newCall</code> 方法返回的实际类型是 RealCall，它是 Call 接口的唯一实现类</p>
<p>当我们调用 <code>execute</code> 方法发起同步请求时，其主要逻辑是：</p>
<ol>
<li>判读是否重复请求</li>
<li>事件记录</li>
<li>将自身加入到 dispatcher 中，并在请求结束时从 dispatcher 中移除自身</li>
<li>通过 <code>getResponseWithInterceptorChain</code> 方法得到 Response 对象</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealCall</span>(</span><br><span class="line">  <span class="keyword">val</span> client: OkHttpClient,</span><br><span class="line">  <span class="comment">/** The application&#x27;s original request unadulterated by redirects or auth headers. */</span></span><br><span class="line">  <span class="keyword">val</span> originalRequest: Request,</span><br><span class="line">  <span class="keyword">val</span> forWebSocket: <span class="built_in">Boolean</span></span><br><span class="line">) : Call &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    check(executed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123; <span class="string">&quot;Already Executed&quot;</span> &#125;</span><br><span class="line">    timeout.enter()</span><br><span class="line">    callStart()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、Dispatcher"><a href="#四、Dispatcher" class="headerlink" title="四、Dispatcher"></a>四、Dispatcher</h1><p>从上面的分析可以看出来，<code>getResponseWithInterceptorChain</code> 方法就是重头戏了，其返回了我们最终得到的 Response。但这里先不介绍该方法，先来看看 Dispatcher 的逻辑</p>
<p>Dispatcher 是一个调度器，用于对全局的网络请求进行缓存调度，其包含以下几个成员变量</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxRequests = <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maxRequestsPerHost = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Ready async calls in the order they&#x27;ll be run. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Running asynchronous calls. Includes canceled calls that haven&#x27;t finished yet. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> runningAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Running synchronous calls. Includes canceled calls that haven&#x27;t finished yet. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> runningSyncCalls = ArrayDeque&lt;RealCall&gt;()</span><br></pre></td></tr></table></figure>

<ul>
<li>maxRequests。同一时间允许并发执行网络请求的最大线程数</li>
<li>maxRequestsPerHost。同一 host 下的最大同时请求数</li>
<li>readyAsyncCalls。保存当前等待执行的异步任务</li>
<li>runningAsyncCalls。保存当前正在执行的异步任务</li>
<li>runningSyncCalls。保存当前正在执行的同步任务</li>
</ul>
<p>客户端不应该无限制地同时发起多个网络请求，因为除了网络资源所限外，系统资源也是有限的，每个请求都需要由一个线程来执行，而系统支持并发执行的线程数量是有限的，所以 OkHttp 内部就使用 maxRequests 来控制同时执行异步请求的最大线程数。此外，OkHttp 为了提高效率，允许多个指向同一 host 的网络请求共享同一个 Socket，而最大共享数量即 maxRequestsPerHost</p>
<p>为了统计以上两个运行参数，就需要使用 readyAsyncCalls、runningAsyncCalls 和 runningSyncCalls 来保存当前正在执行或者准备执行的网络请求。runningSyncCalls 用于保存<strong>当前正在执行的同步任务</strong>，其存储的是 RealCall。readyAsyncCalls 和 runningAsyncCalls 用于保存<strong>异步任务</strong>，其存储的是 AsyncCall</p>
<h2 id="1、同步请求"><a href="#1、同步请求" class="headerlink" title="1、同步请求"></a>1、同步请求</h2><p>RealCall 的 <code>execute()</code> 方法在开始请求前，会先将自身传给 dispatcher，在请求结束后又会从 dispatcher 中移除</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealCall</span>(</span><br><span class="line">  <span class="keyword">val</span> client: OkHttpClient,</span><br><span class="line">  <span class="comment">/** The application&#x27;s original request unadulterated by redirects or auth headers. */</span></span><br><span class="line">  <span class="keyword">val</span> originalRequest: Request,</span><br><span class="line">  <span class="keyword">val</span> forWebSocket: <span class="built_in">Boolean</span></span><br><span class="line">) : Call &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    check(executed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123; <span class="string">&quot;Already Executed&quot;</span> &#125;</span><br><span class="line">    timeout.enter()</span><br><span class="line">    callStart()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//添加到 dispatcher</span></span><br><span class="line">      client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//从 dispatcher 中移除</span></span><br><span class="line">      client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dispatcher 内部也只是相应的将 RealCall 添加到 runningSyncCalls 中或者是将其从 runningSyncCalls 中移除，保存到 runningSyncCalls 的目的是为了方便<strong>统计当前所有正在运行的请求总数</strong>以及<strong>能够取消所有请求</strong>。此外，由于同步请求会直接运行在调用者所在线程上，所以同步请求并不会受 maxRequests 的限制</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dispatcher</span> <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">/** Used by [Call.execute] to signal it is in-flight. */</span></span><br><span class="line">  	  <span class="meta">@Synchronized</span> </span><br><span class="line">      <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">executed</span><span class="params">(call: <span class="type">RealCall</span>)</span></span> &#123;</span><br><span class="line">    	runningSyncCalls.add(call)</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">/** Used by [Call.execute] to signal completion. */</span></span><br><span class="line">  	  <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">finished</span><span class="params">(call: <span class="type">RealCall</span>)</span></span> &#123;</span><br><span class="line">    	finished(runningSyncCalls, call)</span><br><span class="line">  	  &#125;</span><br><span class="line"></span><br><span class="line">  	  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">finished</span><span class="params">(calls: <span class="type">Deque</span>&lt;<span class="type">T</span>&gt;, call: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    	<span class="keyword">val</span> idleCallback: Runnable?</span><br><span class="line">    	synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      		<span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> AssertionError(<span class="string">&quot;Call wasn&#x27;t in-flight!&quot;</span>)</span><br><span class="line">      		idleCallback = <span class="keyword">this</span>.idleCallback</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="comment">//判断是否有需要处理的网络请求</span></span><br><span class="line">    	<span class="keyword">val</span> isRunning = promoteAndExecute()</span><br><span class="line">    	<span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">      		idleCallback.run()</span><br><span class="line">    	&#125;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、异步请求"><a href="#2、异步请求" class="headerlink" title="2、异步请求"></a>2、异步请求</h2><p>RealCall 的 <code>enqueue</code>方法会将外部传入的 Callback 包装为一个 AsyncCall 对象后传给 dispatcher</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealCall</span>(</span><br><span class="line">  <span class="keyword">val</span> client: OkHttpClient,</span><br><span class="line">  <span class="comment">/** The application&#x27;s original request unadulterated by redirects or auth headers. */</span></span><br><span class="line">  <span class="keyword">val</span> originalRequest: Request,</span><br><span class="line">  <span class="keyword">val</span> forWebSocket: <span class="built_in">Boolean</span></span><br><span class="line">) : Call &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(responseCallback: <span class="type">Callback</span>)</span></span> &#123;</span><br><span class="line">    check(executed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123; <span class="string">&quot;Already Executed&quot;</span> &#125;</span><br><span class="line">    callStart()</span><br><span class="line">    client.dispatcher.enqueue(AsyncCall(responseCallback))</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>enqueue</code>对应的是异步请求，所以 OkHttp 内部就需要自己构造一个线程来执行请求，在请求结束后再通过 Callback 来将结果值回调给外部，异步请求逻辑对应的载体就是 AsyncCall 这个类</p>
<p>AsyncCall 是 RealCall 的非静态内部类，所以 AsyncCall 可以访问到 RealCall 的所有变量和方法。此外，AsyncCall 继承了 Runnable 接口，其 <code>executeOn</code> 方法就用于传入一个线程池对象来执行<code>run</code> 方法。<code>run</code> 方法内还是调用了 <code>getResponseWithInterceptorChain()</code>方法来获取 response，并通过 Callback 来将执行结果（不管成功还是失败）回调出去，在请求结束后也会将自身从 dispatcher 中移除</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">AsyncCall</span>(<span class="keyword">private</span> <span class="keyword">val</span> responseCallback: Callback) : Runnable &#123;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Volatile</span> <span class="keyword">var</span> callsPerHost = AtomicInteger(<span class="number">0</span>)</span><br><span class="line">  		<span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">reuseCallsPerHostFrom</span><span class="params">(other: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">  		<span class="keyword">this</span>.callsPerHost = other.callsPerHost</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">executeOn</span><span class="params">(executorService: <span class="type">ExecutorService</span>)</span></span> &#123;</span><br><span class="line">        client.dispatcher.assertThreadDoesntHoldLock()</span><br><span class="line">        <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">this</span>)</span><br><span class="line">            success = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: RejectedExecutionException) &#123;</span><br><span class="line">            <span class="keyword">val</span> ioException = InterruptedIOException(<span class="string">&quot;executor rejected&quot;</span>)</span><br><span class="line">            ioException.initCause(e)</span><br><span class="line">            noMoreExchanges(ioException)</span><br><span class="line">            responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, ioException)</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                client.dispatcher.finished(<span class="keyword">this</span>) <span class="comment">// This call is no longer running!</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        threadName(<span class="string">&quot;OkHttp <span class="subst">$&#123;redactedUrl()&#125;</span>&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> signalledCallback = <span class="literal">false</span></span><br><span class="line">            timeout.enter()</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> response = getResponseWithInterceptorChain()</span><br><span class="line">                signalledCallback = <span class="literal">true</span></span><br><span class="line">                responseCallback.onResponse(<span class="keyword">this</span><span class="symbol">@RealCall</span>, response)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">                <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">                    <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">                    Platform.<span class="keyword">get</span>().log(<span class="string">&quot;Callback failure for <span class="subst">$&#123;toLoggableString()&#125;</span>&quot;</span>, Platform.INFO, e)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (t: Throwable) &#123;</span><br><span class="line">                cancel()</span><br><span class="line">                <span class="keyword">if</span> (!signalledCallback) &#123;</span><br><span class="line">                    <span class="keyword">val</span> canceledException = IOException(<span class="string">&quot;canceled due to <span class="variable">$t</span>&quot;</span>)</span><br><span class="line">                    canceledException.addSuppressed(t)</span><br><span class="line">                    responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, canceledException)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> t</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dispatcher 在拿到 AsyncCall 对象后，会先将其存到 readyAsyncCalls 中，然后通过 <code>findExistingCallWithHost</code>方法来查找当前是否有指向同一 Host 的异步请求，有的话则交换 callsPerHost 变量，该变量就用于标记当前指向同一 Host 的请求数量，最后调用 <code>promoteAndExecute</code> 方法来判断当前是否允许发起请求</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dispatcher</span> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      readyAsyncCalls.add(call)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to</span></span><br><span class="line">      <span class="comment">// the same host.</span></span><br><span class="line">      <span class="keyword">if</span> (!call.call.forWebSocket) &#123;</span><br><span class="line">        <span class="comment">//查找当前是否有指向同一 Host 的异步请求</span></span><br><span class="line">        <span class="keyword">val</span> existingCall = findExistingCallWithHost(call.host)</span><br><span class="line">        <span class="keyword">if</span> (existingCall != <span class="literal">null</span>) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    promoteAndExecute()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findExistingCallWithHost</span><span class="params">(host: <span class="type">String</span>)</span></span>: AsyncCall? &#123;</span><br><span class="line">    <span class="keyword">for</span> (existingCall <span class="keyword">in</span> runningAsyncCalls) &#123;</span><br><span class="line">      <span class="keyword">if</span> (existingCall.host == host) <span class="keyword">return</span> existingCall</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (existingCall <span class="keyword">in</span> readyAsyncCalls) &#123;</span><br><span class="line">      <span class="keyword">if</span> (existingCall.host == host) <span class="keyword">return</span> existingCall</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于当前正在执行的网络请求总数可能已经达到限制，或者是指向同一 Host 的请求也达到限制了，所以 <code>promoteAndExecute()</code>方法就用于从待执行列表 readyAsyncCalls 中获取当前符合运行条件的所有请求，将请求存到 runningAsyncCalls 中，并调用线程池来执行</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">promoteAndExecute</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> executableCalls = mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">    <span class="keyword">val</span> isRunning: <span class="built_in">Boolean</span></span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> i = readyAsyncCalls.iterator()</span><br><span class="line">      <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">val</span> asyncCall = i.next()</span><br><span class="line">	    <span class="comment">//如果当前正在执行的异步请求总数已经超出限制，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (runningAsyncCalls.size &gt;= <span class="keyword">this</span>.maxRequests) <span class="keyword">break</span> <span class="comment">// Max capacity.</span></span><br><span class="line">        <span class="comment">//如果指向同个 Host 的请求总数已经超出限制，则取下一个请求</span></span><br><span class="line">        <span class="keyword">if</span> (asyncCall.callsPerHost.<span class="keyword">get</span>() &gt;= <span class="keyword">this</span>.maxRequestsPerHost) <span class="keyword">continue</span> <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">        i.remove()</span><br><span class="line">        <span class="comment">//将 callsPerHost 递增加一，表示指向该 Host 的链接数加一了</span></span><br><span class="line">        asyncCall.callsPerHost.incrementAndGet()</span><br><span class="line">        <span class="comment">//将 asyncCall 存到可执行列表中</span></span><br><span class="line">        executableCalls.add(asyncCall)</span><br><span class="line">        <span class="comment">//将 asyncCall 存到正在执行列表中</span></span><br><span class="line">        runningAsyncCalls.add(asyncCall)</span><br><span class="line">      &#125;</span><br><span class="line">      isRunning = runningCallsCount() &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行所有符合条件的请求</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) &#123;</span><br><span class="line">      <span class="keyword">val</span> asyncCall = executableCalls[i]</span><br><span class="line">      asyncCall.executeOn(executorService)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isRunning</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、ArrayDeque"><a href="#3、ArrayDeque" class="headerlink" title="3、ArrayDeque"></a>3、ArrayDeque</h2><p>上面有讲到，三种请求的存储容器是 ArrayDeque。ArrayDeque 属于非线程安全的双端队列，所以涉及到多线程操作时都需要外部主动线程同步。那么让我们想一想，OkHttp 选择 ArrayDeque 作为任务容器的理由是什么？以我粗浅的眼光来看，有以下几点：</p>
<ul>
<li>ArrayDeque 内部使用数组结构来存储数据，元素具有明确的先后顺序，这符合我们对网络请求<strong>先到先执行</strong>的基本预期</li>
<li>在选择符合运行条件的异步请求时，需要对 readyAsyncCalls 进行遍历，数组在遍历效率上会比较高</li>
<li>在遍历到符合条件的请求后，需要将请求从 readyAsyncCalls 中移除并转移到 runningAsyncCalls 中，而 ArrayDeque 作为双端队列，在内存空间利用率上比较高</li>
<li>Dispatcher 面对的就是多线程环境，本身就需要进行线程同步，选择 ArrayDeque 这个非线程安全的容器可以省去多余的线程同步消耗</li>
</ul>
<h2 id="4、线程池"><a href="#4、线程池" class="headerlink" title="4、线程池"></a>4、线程池</h2><p>OkHttp 的异步请求是交由其内部的线程池来完成的，该线程池就长这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> executorServiceOrNull: ExecutorService? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@get:Synchronized</span></span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;executorService&quot;</span>) <span class="keyword">val</span> executorService: ExecutorService</span><br><span class="line"><span class="keyword">get</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (executorServiceOrNull == <span class="literal">null</span>) &#123;</span><br><span class="line">    executorServiceOrNull = ThreadPoolExecutor(<span class="number">0</span>, <span class="built_in">Int</span>.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">        SynchronousQueue(), threadFactory(<span class="string">&quot;<span class="variable">$okHttpName</span> Dispatcher&quot;</span>, <span class="literal">false</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> executorServiceOrNull!!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该线程池的参数设置有什么优势呢？以我粗浅的眼光来看，有以下两点：</p>
<ol>
<li>核心线程数为 0，线程超时时间是 60 秒。说明在没有待执行的任务的时候，如果线程闲置了 60 秒，那么线程就会被回收，这可以避免空闲线程白白浪费系统资源，适合于移动设备资源紧缺的情景</li>
<li>允许的最大线程数为 Int.MAX_VALUE，可以看做是完全没有限制的，且任务队列是 SynchronousQueue。SynchronousQueue 的特点是当有任务入队时，必须等待该任务被消费否则入队操作就会一直被阻塞，而由于线程池允许的最大线程数量是无限的，所以每个入队的任务都能马上交由线程处理（交付给空闲线程或者新建一个线程来处理），这就保证了任务的处理及时性，符合我们对网络请求应该尽快发起并完成的期望</li>
</ol>
<p>虽然线程池本身对于最大线程数几乎没有限制，但是由于提交任务的操作还受 maxRequests 的控制，所以实际上该线程池最多同时运行 maxRequests 个线程</p>
<h2 id="5、推动请求执行"><a href="#5、推动请求执行" class="headerlink" title="5、推动请求执行"></a>5、推动请求执行</h2><p>既然 OkHttp 内部的线程池是不可能无限制地新建线程来执行请求的，那么当请求总数已达到 maxRequests 后，后续的请求只能是先处于等待状态，那么这些等待状态的请求会在什么时候被启动呢？</p>
<p>同步请求和异步请求结束后都会调用到 Dispatcher 的两个 <code>finished</code> 方法，在这两个方法里又会触发到 <code>promoteAndExecute()</code>方法去遍历任务列表来执行，此时就推动了待处理列表的任务执行操作。所以说，Dispatcher 中的请求都可以看做是在自发性地启动，每个请求结束都会自动触发下一个请求执行（如果有的话），省去了多余的定时检查这类操作</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Used by [AsyncCall.run] to signal completion. */</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">finished</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">	call.callsPerHost.decrementAndGet()</span><br><span class="line">	finished(runningAsyncCalls, call)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Used by [Call.execute] to signal completion. */</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">finished</span><span class="params">(call: <span class="type">RealCall</span>)</span></span> &#123;</span><br><span class="line">	finished(runningSyncCalls, call)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">finished</span><span class="params">(calls: <span class="type">Deque</span>&lt;<span class="type">T</span>&gt;, call: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">val</span> idleCallback: Runnable?</span><br><span class="line">	synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">  		<span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> AssertionError(<span class="string">&quot;Call wasn&#x27;t in-flight!&quot;</span>)</span><br><span class="line">  		idleCallback = <span class="keyword">this</span>.idleCallback</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断当前是否有可以启动的待执行任务，有的话则启动</span></span><br><span class="line">	<span class="keyword">val</span> isRunning = promoteAndExecute()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">  		idleCallback.run()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h2><ul>
<li>如果是同步请求，那么网络请求过程就会直接在调用者所在线程上完成，不受 Dispatcher 的控制</li>
<li>如果是异步请求，该请求会先存到待执行列表 readyAsyncCalls 中，该请求是否可以立即发起受 maxRequests 和 maxRequestsPerHost 两个条件的限制。如果符合条件，那么就会从 readyAsyncCalls 取出并存到 runningAsyncCalls 中，然后交由 OkHttp 内部的线程池来执行</li>
<li>不管外部是同步请求还是异步请求，内部都是通过调用<code>getResponseWithInterceptorChain()</code>方法来拿到 Response 的</li>
<li>Dispatcher 内部的线程池本身允许同时运行 Int.MAX_VALUE 个线程，但是实际上的线程数量还是受 maxRequests 的控制</li>
</ul>
<h1 id="五、RealInterceptorChain"><a href="#五、RealInterceptorChain" class="headerlink" title="五、RealInterceptorChain"></a>五、RealInterceptorChain</h1><p>重点再来看 <code>getResponseWithInterceptorChain()</code>方法，其主要逻辑就是通过拦截器来完成整个网络请求过程。在该方法中，除了会获取外部主动设置的拦截器外，也会默认添加以下几个拦截器</p>
<ol>
<li>RetryAndFollowUpInterceptor。负责失败重试以及重定向</li>
<li>BridgeInterceptor。负责对用户构造的 Request 进行转换，添加必要的 header 和 cookie，在得到 response 后如果有需要的会进行 gzip 解压</li>
<li>CacheInterceptor。用于处理缓存</li>
<li>ConnectInterceptor。负责和服务器建立连接</li>
<li>CallServerInterceptor。负责向服务器发送请求和从服务器接收数据</li>
</ol>
<p>最后，request 和 interceptors 会用来生成一个 RealInterceptorChain 对象，由其来最终返回 response</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">    <span class="comment">//添加开发者设置的拦截器</span></span><br><span class="line">    interceptors += client.interceptors</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加默认的拦截器</span></span><br><span class="line">    interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">    interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">    interceptors += CacheInterceptor(client.cache)</span><br><span class="line">    interceptors += ConnectInterceptor</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      <span class="comment">//如果不是 WebSocket 的话，那就再添加开发者设置的 NetworkInterceptors</span></span><br><span class="line">      interceptors += client.networkInterceptors</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//CallServerInterceptor 是实际上发起网络请求的地方</span></span><br><span class="line">    interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> chain = RealInterceptorChain(</span><br><span class="line">        call = <span class="keyword">this</span>,</span><br><span class="line">        interceptors = interceptors,</span><br><span class="line">        index = <span class="number">0</span>,</span><br><span class="line">        exchange = <span class="literal">null</span>,</span><br><span class="line">        request = originalRequest,</span><br><span class="line">        connectTimeoutMillis = client.connectTimeoutMillis,</span><br><span class="line">        readTimeoutMillis = client.readTimeoutMillis,</span><br><span class="line">        writeTimeoutMillis = client.writeTimeoutMillis</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> calledNoMoreExchanges = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> response = chain.proceed(originalRequest)</span><br><span class="line">      <span class="keyword">if</span> (isCanceled()) &#123;</span><br><span class="line">        response.closeQuietly()</span><br><span class="line">        <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> response</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">      calledNoMoreExchanges = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">throw</span> noMoreExchanges(e) <span class="keyword">as</span> Throwable</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">        noMoreExchanges(<span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>Interceptor 是 OkHttp 里很重要的一环，OkHttp 也是靠此为开发者提供了很高的自由度</strong>。Interceptor 接口本身只包含一个 <code>intercept</code> 方法，在此方法内可拿到原始的 Request 对象以及最终的 Response</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> Interceptor &#123;</span></span><br><span class="line">   <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Chain</span>)</span></span>: Response   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，我们可以自定义一个 LogInterceptor 来打印网络请求的请求参数以及最终的返回值</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogInterceptor</span> : <span class="type">Interceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">        <span class="keyword">val</span> request = chain.request()</span><br><span class="line">        println(request)</span><br><span class="line">        <span class="keyword">val</span> response = chain.proceed(request)</span><br><span class="line">        println(response)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Interceptor 的实现初衷是为了给开发者提供一个可以控制网络请求的<strong>发起过程</strong>及<strong>收尾工作</strong>的入口，例如**添加 header、日志记录、请求拦截、ResponseBody修改 **等，每个 Interceptor 只负责自己关心的操作，那么势必就会有添加多个 Interceptor 的需求</p>
<p>我们知道，只有让每个 Interceptor 都依次处理完 request 之后，OkHttp 才能根据最终的 request 对象去联网请求得到 response，所以每个 Interceptor 需要依次拿到 request 进行自定义处理。请求到 response 后，Interceptor 可能还需要对 response 进行处理，那么就还需要将 response 再依次传递给每个 Interceptor。那么，怎么实现将多个 Interceptor 给串联起来呢？</p>
<p><strong>这里来看一个简化版本的 Interceptor 实现思路</strong></p>
<p>假设我们自己定义的 Interceptor 实现类有两个：LogInterceptor 和 HeaderInterceptor，这里只是简单地将获取到 request 和 response 的时机给打印出来，重点是要看每个 Interceptor 的先后调用顺序。为了将两个 Interceptor 给串联起来，RealInterceptorChain 会循环获取 index 指向的下一个 Interceptor 对象，每次构建一个新的 RealInterceptorChain 对象作为参数来调用 <code>intercept</code> 方法，这样外部只需要调用一次 <code>realInterceptorChain.proceed</code> 就可以拿到最终的 response 对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Request</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Response</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Chain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">request</span><span class="params">()</span></span>: Request</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">proceed</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Response</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Chain</span>)</span></span>: Response</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealInterceptorChain</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> request: Request,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> interceptors: List&lt;Interceptor&gt;,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> index: <span class="built_in">Int</span></span><br><span class="line">) : Chain &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(index: <span class="type">Int</span>)</span></span>: RealInterceptorChain &#123;</span><br><span class="line">        <span class="keyword">return</span> RealInterceptorChain(request, interceptors, index)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">request</span><span class="params">()</span></span>: Request &#123;</span><br><span class="line">        <span class="keyword">return</span> request</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">proceed</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Response &#123;</span><br><span class="line">        <span class="keyword">val</span> next = copy(index = index + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">val</span> interceptor = interceptors[index]</span><br><span class="line">        <span class="keyword">val</span> response = interceptor.intercept(next)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogInterceptor</span> : <span class="type">Interceptor</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">        <span class="keyword">val</span> request = chain.request()</span><br><span class="line">        println(<span class="string">&quot;LogInterceptor -- getRequest&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> response = chain.proceed(request)</span><br><span class="line">        println(<span class="string">&quot;LogInterceptor ---- getResponse&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeaderInterceptor</span> : <span class="type">Interceptor</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">        <span class="keyword">val</span> request = chain.request()</span><br><span class="line">        println(<span class="string">&quot;HeaderInterceptor -- getRequest&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> response = chain.proceed(request)</span><br><span class="line">        println(<span class="string">&quot;HeaderInterceptor ---- getResponse&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> interceptorList = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">    interceptorList.add(LogInterceptor())</span><br><span class="line">    interceptorList.add(HeaderInterceptor())</span><br><span class="line">    <span class="keyword">val</span> request = Request()</span><br><span class="line">    <span class="keyword">val</span> realInterceptorChain = RealInterceptorChain(request, interceptorList, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> response = realInterceptorChain.proceed(request)</span><br><span class="line">    println(<span class="string">&quot;main response&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码看着思路还可以，可是当运行后就会发现抛出了 IndexOutOfBoundsException，因为代码里并没有对 index 进行越界判断。而且，上面的代码也缺少了一个真正的生成 Response 对象的地方，每个 Interceptor 只是在进行中转调用而已，因此还需要一个来真正地完成网络请求并返回 Response 对象的地方，即 CallServerInterceptor</p>
<p>所以，CallServerInterceptor 的<code>intercept</code> 方法就用来真正地执行网络请求并生成 Response 对象，在这里就不能再调用 <code>proceed</code> 方法了，且 CallServerInterceptor 需要放在 interceptorList 的最后一位</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CallServerInterceptor</span> : <span class="type">Interceptor</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">        <span class="keyword">val</span> request = chain.request()</span><br><span class="line">        println(<span class="string">&quot;CallServerInterceptor -- getRequest&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> response = Response()</span><br><span class="line">        println(<span class="string">&quot;CallServerInterceptor ---- getResponse&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> interceptorList = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">    interceptorList.add(LogInterceptor())</span><br><span class="line">    interceptorList.add(HeaderInterceptor())</span><br><span class="line">    interceptorList.add(CallServerInterceptor())</span><br><span class="line">    <span class="keyword">val</span> request = Request()</span><br><span class="line">    <span class="keyword">val</span> realInterceptorChain = RealInterceptorChain(request, interceptorList, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> response = realInterceptorChain.proceed(request)</span><br><span class="line">    println(<span class="string">&quot;main response&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终的运行结果如下所示，可以看出来，<code>intercept</code> 方法是根据添加顺序来调用，而 response 是按照反方向来传递</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LogInterceptor -- getRequest</span><br><span class="line">HeaderInterceptor -- getRequest</span><br><span class="line">CallServerInterceptor -- getRequest</span><br><span class="line">CallServerInterceptor ---- getResponse</span><br><span class="line">HeaderInterceptor ---- getResponse</span><br><span class="line">LogInterceptor ---- getResponse</span><br><span class="line">main response</span><br></pre></td></tr></table></figure>

<p>以上代码我简化了 OkHttp 在实现 RealInterceptorChain 时的思路，其本质上就是通过将多个拦截器以责任链的方式来一层层调用，上一个拦截器处理完后将就将结果传给下一个拦截器，直到最后一个拦截器（即 CallServerInterceptor ）处理完后将 Response 再一层层往上传递</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealInterceptorChain</span>(</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">val</span> call: RealCall,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> interceptors: List&lt;Interceptor&gt;,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> index: <span class="built_in">Int</span>,</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">val</span> exchange: Exchange?,</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">val</span> request: Request,</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">val</span> connectTimeoutMillis: <span class="built_in">Int</span>,</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">val</span> readTimeoutMillis: <span class="built_in">Int</span>,</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">val</span> writeTimeoutMillis: <span class="built_in">Int</span></span><br><span class="line">) : Interceptor.Chain &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    index: <span class="type">Int</span> = this.index,</span></span></span><br><span class="line"><span class="params"><span class="function">    exchange: <span class="type">Exchange</span>? = this.exchange,</span></span></span><br><span class="line"><span class="params"><span class="function">    request: <span class="type">Request</span> = this.request,</span></span></span><br><span class="line"><span class="params"><span class="function">    connectTimeoutMillis: <span class="type">Int</span> = this.connectTimeoutMillis,</span></span></span><br><span class="line"><span class="params"><span class="function">    readTimeoutMillis: <span class="type">Int</span> = this.readTimeoutMillis,</span></span></span><br><span class="line"><span class="params"><span class="function">    writeTimeoutMillis: <span class="type">Int</span> = this.writeTimeoutMillis</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span> = RealInterceptorChain(call, interceptors, index, exchange, request, connectTimeoutMillis,</span><br><span class="line">      readTimeoutMillis, writeTimeoutMillis)</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">proceed</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Response &#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">val</span> next = copy(index = index + <span class="number">1</span>, request = request)</span><br><span class="line">    <span class="keyword">val</span> interceptor = interceptors[index]</span><br><span class="line">    <span class="meta">@Suppress(<span class="string">&quot;USELESS_ELVIS&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> response = interceptor.intercept(next) ?: <span class="keyword">throw</span> NullPointerException(</span><br><span class="line">        <span class="string">&quot;interceptor <span class="variable">$interceptor</span> returned null&quot;</span>)</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、Interceptor"><a href="#六、Interceptor" class="headerlink" title="六、Interceptor"></a>六、Interceptor</h1><p>我们在构建 OkHttpClient 的时候，添加拦截器的方法分为两类：<code>addInterceptor</code>和<code>addNetworkInterceptor</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> okHttClient = OkHttpClient.Builder()</span><br><span class="line">    .addInterceptor &#123; chain -&gt;</span><br><span class="line">        chain.proceed(chain.request())</span><br><span class="line">    &#125;</span><br><span class="line">    .addNetworkInterceptor &#123; chain -&gt;</span><br><span class="line">        chain.proceed(chain.request())</span><br><span class="line">    &#125;</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure>

<p>Interceptor 和 NetworkInterceptor 分别被称为<strong>应用拦截器</strong>和<strong>网络拦截器</strong>，那么它们有什么区别呢？</p>
<p>前面有讲到，OkHttp 在执行拦截器的时候，是按照如下顺序的，这个顺序就已经决定了不同拦截器的调用时机差异</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">interceptors += client.interceptors</span><br><span class="line">interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">interceptors += CacheInterceptor(client.cache)</span><br><span class="line">interceptors += ConnectInterceptor</span><br><span class="line"><span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">  	interceptors += client.networkInterceptors</span><br><span class="line">&#125;</span><br><span class="line">interceptors += CallServerInterceptor(forWebSocket)</span><br></pre></td></tr></table></figure>

<ul>
<li>由于应用拦截器处于列表头部，所以在整个责任链路中应用拦截器会首先被执行，即使之后在 RetryAndFollowUpInterceptor 中发生了<strong>请求失败重试或者网络重定向</strong>等情况，应用拦截器也只会被触发一次，但网络拦截器会被调用多次</li>
<li>网络拦截器位于 CacheInterceptor 之后，那么当 CacheInterceptor  命中缓存的时候就不会去执行网络请求了，此时网络拦截器就不会被调用，因此网络拦截器是存在短路的可能。此外，网络拦截器位于 ConnectInterceptor 之后，在调用网络拦截器之前就已经准备好网络链接了，说明网络拦截器本身就关联着实际的网络请求逻辑</li>
<li>从单次请求流程上来看，应用拦截器被调用并不意味着真正有发起了网络请求，而网络拦截器被调用就说明的确发起了一次网络请求。因此如果我们希望通过拦截器来记录网络请求详情的话，就需要考虑两者的调用时机差异：应用拦截器无法感知到 OkHttp 自动添加的一些 header，但是网络拦截器可以；应用拦截器除非主动中断请求，否则每次请求一定都会被执行，但网络拦截器可能存在被短路的可能</li>
</ul>
<p>借用官方的一张图片来表示</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46eebdde38824c5491cdb54450dadc7e~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>这里可以根据 <a target="_blank" rel="noopener" href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/Progress.java">square</a> 官方提供的一个例子，来实现在下载一张 10 MB 图片的时候通过拦截器对下载进度进行监听，并同时把图片下载到系统的桌面</p>
<p>实现思路就是对原始的 ResponseBody 进行多一层代理，计算已经从网络中读取到的字节数和资源的 contentLength 之间的百分比，从而得到下载进度。此外，因为该拦截器是和确切的网络请求相关，所以应该要设为网络拦截器才比较合理</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: leavesCZY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Github</span>：https://github.com/leavesCZY</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ProgressListener</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">(bytesRead: <span class="type">Long</span>, contentLength: <span class="type">Long</span>, done: <span class="type">Boolean</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">        .url(<span class="string">&quot;https://images.pexels.com/photos/5177790/pexels-photo-5177790.jpeg&quot;</span>)</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">val</span> progressListener: ProgressListener = <span class="keyword">object</span> : ProgressListener &#123;</span><br><span class="line">        <span class="keyword">var</span> firstUpdate = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">(bytesRead: <span class="type">Long</span>, contentLength: <span class="type">Long</span>, done: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                println(<span class="string">&quot;completed&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (firstUpdate) &#123;</span><br><span class="line">                    firstUpdate = <span class="literal">false</span></span><br><span class="line">                    <span class="keyword">if</span> (contentLength == -<span class="number">1L</span>) &#123;</span><br><span class="line">                        println(<span class="string">&quot;content-length: unknown&quot;</span>)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.<span class="keyword">out</span>.format(<span class="string">&quot;content-length: %d\n&quot;</span>, contentLength)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                println(bytesRead)</span><br><span class="line">                <span class="keyword">if</span> (contentLength != -<span class="number">1L</span>) &#123;</span><br><span class="line">                    System.<span class="keyword">out</span>.format(<span class="string">&quot;%d%% done\n&quot;</span>, <span class="number">100</span> * bytesRead / contentLength)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> client = OkHttpClient.Builder()</span><br><span class="line">        .addNetworkInterceptor &#123; chain: Interceptor.Chain -&gt;</span><br><span class="line">            <span class="keyword">val</span> originalResponse = chain.proceed(chain.request())</span><br><span class="line">            originalResponse.newBuilder()</span><br><span class="line">                .body(ProgressResponseBody(originalResponse.body!!, progressListener))</span><br><span class="line">                .build()</span><br><span class="line">        &#125;</span><br><span class="line">        .build()</span><br><span class="line">    client.newCall(request).execute().use &#123; response -&gt;</span><br><span class="line">        <span class="keyword">if</span> (!response.isSuccessful) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IOException(<span class="string">&quot;Unexpected code <span class="variable">$response</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> desktopDir = FileSystemView.getFileSystemView().homeDirectory</span><br><span class="line">        <span class="keyword">val</span> imageFile = File(desktopDir, <span class="string">&quot;<span class="subst">$&#123;System.currentTimeMillis()&#125;</span>.jpeg&quot;</span>)</span><br><span class="line">        imageFile.createNewFile()</span><br><span class="line">        <span class="comment">//读取 InputStream 写入到图片文件中</span></span><br><span class="line">        response.body!!.byteStream().copyTo(imageFile.outputStream())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ProgressResponseBody</span> <span class="keyword">constructor</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> responseBody: ResponseBody,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> progressListener: ProgressListener</span><br><span class="line">) : ResponseBody() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> bufferedSource: BufferedSource? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">contentType</span><span class="params">()</span></span>: MediaType? &#123;</span><br><span class="line">        <span class="keyword">return</span> responseBody.contentType()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">contentLength</span><span class="params">()</span></span>: <span class="built_in">Long</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> responseBody.contentLength()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">source</span><span class="params">()</span></span>: BufferedSource &#123;</span><br><span class="line">        <span class="keyword">if</span> (bufferedSource == <span class="literal">null</span>) &#123;</span><br><span class="line">            bufferedSource = source(responseBody.source()).buffer()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bufferedSource!!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">source</span><span class="params">(source: <span class="type">Source</span>)</span></span>: Source &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">object</span> : ForwardingSource(source) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> totalBytesRead = <span class="number">0L</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">(sink: <span class="type">Buffer</span>, byteCount: <span class="type">Long</span>)</span></span>: <span class="built_in">Long</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> bytesRead = <span class="keyword">super</span>.read(sink, byteCount)</span><br><span class="line">                <span class="comment">// read() returns the number of bytes read, or -1 if this source is exhausted.</span></span><br><span class="line">                totalBytesRead += <span class="keyword">if</span> (bytesRead != -<span class="number">1L</span>) bytesRead <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                progressListener.update(totalBytesRead, responseBody.contentLength(), bytesRead == -<span class="number">1L</span>)</span><br><span class="line">                <span class="keyword">return</span> bytesRead</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进度输出就类似于：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">content-length: <span class="number">11448857</span></span><br><span class="line"><span class="number">467</span></span><br><span class="line"><span class="number">0</span>% done</span><br><span class="line"><span class="number">1836</span></span><br><span class="line"><span class="number">0</span>% done</span><br><span class="line"><span class="number">3205</span></span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="number">99</span>% done</span><br><span class="line"><span class="number">11442570</span></span><br><span class="line"><span class="number">99</span>% done</span><br><span class="line"><span class="number">11448857</span></span><br><span class="line"><span class="number">100</span>% done</span><br><span class="line">completed</span><br></pre></td></tr></table></figure>

<h1 id="七、结尾"><a href="#七、结尾" class="headerlink" title="七、结尾"></a>七、结尾</h1><p>关于 OkHttp 的源码讲解到这里就结束了，但本文还缺少了对 ConnectInterceptor 和 CallServerInterceptor 的讲解，这两者是 OkHttp 完成实际网络请求的地方，涉及到了 Connection 和 Socket 这些比较底层的领域，我没法讲得多清晰，就直接略过这块内容了~~</p>
<p>OkHttp 的运行效率很高，但在使用上还是比较原始，一般我们还是需要在 OkHttp 之上进行一层封装，Retrofit 就是一个对 OkHttp 的优秀封装库，对 Retrofit 的源码讲解可以看我的这篇文章：<a target="_blank" rel="noopener" href="https://juejin.im/post/6886121327845965838">三方库源码笔记（7）-Retrofit 源码详解</a></p>
<p>下篇文章就来写关于 OkHttp 拦截器的实战内容吧</p>

  </article>
  <!-- tag -->
  <div class="mt-12 pt-6 border-t border-gray-200">
    
  </div>
  <!-- prev and next -->
  <div class="flex justify-between mt-12 pt-6 border-t border-gray-200">
    <div>
      
        <a href="/hexo-blog/public/2025/03/02/md/mysql/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/" class="text-sm text-gray-400 hover:text-gray-500 flex justify-center">
          <iconify-icon width="20" icon="ri:arrow-left-s-line" data-inline="false"></iconify-icon>
          
        </a>
      
    </div>
    <div>
      
        <a href="/hexo-blog/public/2025/03/02/md/kotlin/%E4%B8%BB%E6%B5%81%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%8812%EF%BC%89OkHttp%20&%20Retrofit%20%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E5%88%A9%E5%99%A8/" class="text-sm text-gray-400 hover:text-gray-500 flex justify-center">
          主流开源库源码分析（12）OkHttp & Retrofit 开发调试利器
          <iconify-icon width="20" icon="ri:arrow-right-s-line" data-inline="false"></iconify-icon>
        </a>
      
    </div>
  </div>
  <!-- comment -->
  <div class="article-comments mt-12">
    
<script
  src="https://giscus.app/client.js"
  data-repo="hqqich/giscus"
  data-repo-id="R_kgDOOCZUBA"
  data-category="General"
  data-category-id="DIC_kwDOOCZUBM4Cng1l"
  data-mapping="pathname"
  data-strict="0"
  data-reactions-enabled="1"
  data-emit-metadata="0"
  data-input-position="bottom"
  data-theme="preferred_color_scheme"
  data-lang="zh-CN"
  crossorigin="anonymous"
  async
></script>
<script>
  window.onload = function () {
    console.log("giscus loaded");
    const isDark = document.documentElement.classList.contains("dark");
    const giscusFrame = document.querySelector("iframe.giscus-frame");
    giscusFrame.contentWindow.postMessage(
      {
        giscus: {
          setConfig: {
            theme: isDark ? "dark" : "light",
          },
        },
      },
      "https://giscus.app"
    );
  };
</script>


  </div>
</section>
<!-- js inspect -->

<script src="/hexo-blog/public/lib/clipboard.min.js"></script>


<script async src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
  });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>



<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
  $(document).ready(() => {
    const maraidConfig = {
      theme: "default",
      logLevel: 3,
      flowchart: { curve: "linear" },
      gantt: { axisFormat: "%m/%d/%Y" },
      sequence: { actorMargin: 50 },
    };
    mermaid.initialize(maraidConfig);
  });
</script>



<script src="/hexo-blog/public/lib/fancybox/fancybox.umd.min.js"></script>

<script>
  $(document).ready(() => {
    $('.post-content').each(function(i){
      $(this).find('img').each(function(){
        if ($(this).parent().hasClass('fancybox') || $(this).parent().is('a')) return;
        var alt = this.alt;
        if (alt) $(this).after('<span class="fancybox-alt">' + alt + '</span>');
        $(this).wrap('<a class="fancybox-img" href="' + this.src + '" data-fancybox=\"gallery\" data-caption="' + alt + '"></a>')
      });
      $(this).find('.fancybox').each(function(){
        $(this).attr('rel', 'article' + i);
      });
    });

    Fancybox.bind('[data-fancybox="gallery"]', {
        // options
    })
  })
</script>

<!-- tocbot begin -->

<script src="/hexo-blog/public/lib/tocbot/tocbot.min.js"></script>

<script>
  $(document).ready(() => {
      tocbot.init({
        // Where to render the table of contents.
        tocSelector: '.post-toc',
        // Where to grab the headings to build the table of contents.
        contentSelector: '.post-content',
        // Which headings to grab inside of the contentSelector element.
        headingSelector: 'h1, h2, h3',
        // For headings inside relative or absolute positioned containers within content.
        hasInnerContainers: true,
    });
  })
</script>
<!-- tocbot end -->


  </main>
  <footer class="flex flex-col h-40 items-center justify-center text-gray-400 text-sm">
  <!-- busuanzi -->
  
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- Busuanzi Analytics -->
<div class="flex items-center gap-2">
  <span>Visitors</span>
  <span id="busuanzi_value_site_uv"></span>
  <span>Page Views</span>
  <span id="busuanzi_value_site_pv"></span>
</div>
<!-- End Busuanzi Analytics -->


  <!-- copyright -->
  <div class="flex items-center gap-2">
    <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" style="color: inherit;">CC BY-NC-SA 4.0</a>
    <span>© 2022</span>
    <iconify-icon width="18" icon="emojione-monotone:maple-leaf" ></iconify-icon>
    <a href="https://github.com/xbmlz" target="_blank" rel="noopener noreferrer">xbmlz</a>
  </div>
  <!-- powered by -->
  <div class="flex items-center gap-2">
    <span>Powered by</span>
    <a href="https://hexo.io/" target="_blank" rel="noopener noreferrer">Hexo</a>
    <span>&</span>
    <a href="https://github.com/xbmlz/hexo-theme-maple" target="_blank" rel="noopener noreferrer">Maple</a>
  </div>

</footer>

  <div class="back-to-top box-border fixed right-6 z-1024 -bottom-20 rounded py-1 px-1 bg-slate-900 opacity-60 text-white cursor-pointer text-center dark:bg-slate-600">
    <span class="flex justify-center items-center text-sm">
      <iconify-icon width="18" icon="ion:arrow-up-c" id="go-top"></iconify-icon>
      <span id="scrollpercent"><span>0</span> %</span>
    </span>
  </div>
  
<script src="/hexo-blog/public/js/main.js"></script>


  <script>
    $(document).ready(function () {
      const mapleCount = "10";
      const speed = "0.5";
      const mapleEl = document.getElementById("maple");
      const maples = Array.from({ length: mapleCount }).map(() => {
        const maple = document.createElement("div");
        const scale = Math.random() * 0.5 + 0.5;
        const offset = Math.random() * 2 - 1;
        const x = Math.random() * mapleEl.clientWidth;
        const y = -Math.random() * mapleEl.clientHeight;
        const duration = 10 / speed;
        const delay = -duration;
        maple.className = "maple";
        maple.style.width = `${24 * scale}px`;
        maple.style.height = `${24 * scale}px`;
        maple.style.left = `${x}px`;
        maple.style.top = `${y}px`;
        maple.style.setProperty("--maple-fall-offset", offset);
        maple.style.setProperty("--maple-fall-height", `${Math.abs(y) + mapleEl.clientHeight}px`);
        maple.style.animation = `fall ${duration}s linear infinite`;
        maple.style.animationDelay = `${delay}s`;
        mapleEl.appendChild(maple)
        return maple
      })
    });
  </script>
  


  <div class="fixed top-0 bottom-0 left-0 right-0 pointer-events-none print:hidden" id="maple"></div>
</body>

</html>

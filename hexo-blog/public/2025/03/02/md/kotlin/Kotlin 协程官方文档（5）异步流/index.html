<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-EHXM4GYP5W"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-EHXM4GYP5W');
</script>
<!-- End Google Analytics -->



<!-- Baidu Analytics -->
<script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?0a6515fb9c839d6a56d4cfd8b7d243d4";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>
<!-- End Baidu Analytics -->


<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

  <meta name="author" content="hqqich">


  <meta name="subtitle" content="忙碌把时光缩短, 苦难把岁月拉长">




<title>Kotlin 协程官方文档（5）异步流 | Hexo-blog</title>



<link rel="icon" href="/hexo-blog/public/favicon.ico">



<link rel="stylesheet" href="/hexo-blog/public/css/main.css">


<link rel="stylesheet" href="/hexo-blog/public/lib/nprogress/nprogress.css">



<script src="/hexo-blog/public/lib/jquery.min.js"></script>


<script src="/hexo-blog/public/lib/iconify-icon.min.js"></script>


<script src="https://cdn.tailwindcss.com?plugins=typography"></script>
<script>
  tailwind.config = {
    darkMode: "class",
  };
</script>


<script src="/hexo-blog/public/lib/nprogress/nprogress.js"></script>

<script>
  $(document).ready(() => {
    NProgress.configure({
      showSpinner: false,
    });
    NProgress.start();
    $("#nprogress .bar").css({
      background: "#de7441",
    });
    $("#nprogress .peg").css({
      "box-shadow": "0 0 2px #de7441, 0 0 4px #de7441",
    });
    $("#nprogress .spinner-icon").css({
      "border-top-color": "#de7441",
      "border-left-color": "#de7441",
    });
    setTimeout(function () {
      NProgress.done();
      $(".fade").removeClass("out");
    }, 800);
  });
</script>

<script>
  (function () {
    const prefersDark =
      window.matchMedia &&
      window.matchMedia("(prefers-color-scheme: dark)").matches;
    const setting = localStorage.getItem("hexo-color-scheme") || "auto";
    if (setting === "dark" || (prefersDark && setting !== "light"))
      document.documentElement.classList.toggle("dark", true);
    let isDark = document.documentElement.classList.contains("dark");
  })();

  $(document).ready(function () {
    // init icon
    const prefersDark =
      window.matchMedia &&
      window.matchMedia("(prefers-color-scheme: dark)").matches;
    const isDark = document.documentElement.classList.contains("dark");
    $("#theme-icon").attr("icon", isDark ? "ri:moon-line" : "ri:sun-line");

    function toggleGiscusTheme() {
      const isDark = document.documentElement.classList.contains("dark");
      const giscusFrame = document.querySelector("iframe.giscus-frame");
      if (giscusFrame) {
        giscusFrame.contentWindow.postMessage(
          {
            giscus: {
              setConfig: {
                theme: isDark ? "dark" : "light",
              },
            },
          },
          "https://giscus.app"
        );
      }
    }

    // toggle dark mode
    function toggleDark() {
      let isDark = document.documentElement.classList.contains("dark");
      const setting = localStorage.getItem("hexo-color-scheme") || "auto";
      isDark = !isDark;
      document.documentElement.classList.toggle("dark", isDark);
      $("#theme-icon").attr("icon", isDark ? "ri:moon-line" : "ri:sun-line");
      if (prefersDark === isDark) {
        localStorage.setItem("hexo-color-scheme", "auto");
      } else {
        localStorage.setItem("hexo-color-scheme", isDark ? "dark" : "light");
      }
      toggleGiscusTheme();
    }

    // listen dark mode change
    window
      .matchMedia("(prefers-color-scheme: dark)")
      .addEventListener("change", (e) => {
        const setting = localStorage.getItem("hexo-color-scheme") || "auto";
        if (setting === "auto") {
          document.documentElement.classList.toggle("dark", e.matches);
          $("#theme-icon").attr(
            "icon",
            e.matches ? "ri:moon-line" : "ri:sun-line"
          );
          toggleGiscusTheme();
        }
      });

    $("#toggle-dark").click((event) => {
      const isAppearanceTransition = document.startViewTransition && !window.matchMedia('(prefers-reduced-motion: reduce)').matches
      if (!isAppearanceTransition) {
        toggleDark()
        return
      }
      const x = event.clientX
      const y = event.clientY
      const endRadius = Math.hypot(
        Math.max(x, innerWidth - x),
        Math.max(y, innerHeight - y),
      )
      const transition = document.startViewTransition(async () => {
        toggleDark()
      })

      transition.ready
        .then(() => {
          const isDark = document.documentElement.classList.contains("dark")
          const clipPath = [
            `circle(0px at ${x}px ${y}px)`,
            `circle(${endRadius}px at ${x}px ${y}px)`,
          ]
          document.documentElement.animate(
            {
              clipPath: isDark
                ? [...clipPath].reverse()
                : clipPath,
            },
            {
              duration: 400,
              easing: 'ease-out',
              pseudoElement: isDark
                ? '::view-transition-old(root)'
                : '::view-transition-new(root)',
            },
          )
        })
    });
  });
</script>




<meta name="generator" content="Hexo 7.3.0"></head>
<body class="font-sans bg-white dark:bg-zinc-900 text-gray-700 dark:text-gray-200 relative">
  <header class="fixed w-full px-5 py-1 z-10 backdrop-blur-xl backdrop-saturate-150 border-b border-black/5">
  <div class="max-auto">
    <nav class="flex items-center text-base">
      <a href="/hexo-blog/public/" class="group">
        <h2 class="font-medium tracking-tighterp text-l p-2">
          <img class="w-5 mr-2 inline-block transition-transform group-hover:rotate-[30deg]" id="logo" src="https://moe-counter-vercel-gamma.vercel.app/a?theme=rule34" alt="Hexo-blog" />
          Hexo-blog
        </h2>
      </a>
      <div id="header-title" class="opacity-0 md:ml-2 md:mt-[0.1rem] text-xs font-medium whitespace-nowrap overflow-hidden overflow-ellipsis">
        Kotlin 协程官方文档（5）异步流
      </div>
      <div class="flex-1"></div>
      <div class="flex items-center gap-3">
        
          <a class="hidden sm:flex" href="/hexo-blog/public/archives">Posts</a>
        
          <a class="hidden sm:flex" href="/hexo-blog/public/category">Categories</a>
        
          <a class="hidden sm:flex" href="/hexo-blog/public/tag">Tags</a>
        
        
          
            <a class="w-5 h-5 hidden sm:flex" title="Github" target="_blank" rel="noopener" href="https://github.com/hqqich">
              <iconify-icon width="20" icon="ri:github-line"></iconify-icon>
            </a>
          
        
        <a class="w-5 h-5 hidden sm:flex" title="Github" href="rss2.xml">
          <iconify-icon width="20" icon="ri:rss-line"></iconify-icon>
        </a>
        <a class="w-5 h-5" title="toggle theme" id="toggle-dark">
          <iconify-icon width="20" icon="" id="theme-icon"></iconify-icon>
        </a>
      </div>
      <div class="flex items-center justify-center gap-3 ml-3 sm:hidden">
        <span class="w-5 h-5" aria-hidden="true" role="img" id="open-menu">
          <iconify-icon width="20" icon="carbon:menu" ></iconify-icon>
        </span>
        <span class="w-5 h-5 hidden" aria-hidden="true" role="img" id="close-menu">
          <iconify-icon  width="20" icon="carbon:close" ></iconify-icon>
        </span>
      </div>
    </nav>
  </div>
</header>
<div id="menu-panel" class="h-0 overflow-hidden sm:hidden fixed left-0 right-0 top-12 bottom-0 z-10">
  <div id="menu-content" class="relative z-20 bg-white/80 px-6 sm:px-8 py-2 backdrop-blur-xl -translate-y-full transition-transform duration-300">
    <ul class="nav flex flex-col sm:flex-row text-sm font-medium">
      
        <li class="nav-portfolio sm:mx-2 border-b sm:border-0 border-black/5 last:border-0 hover:text-main">
          <a href="/hexo-blog/public/archives" class="flex h-12 sm:h-auto items-center">Posts</a>
        </li>
      
        <li class="nav-portfolio sm:mx-2 border-b sm:border-0 border-black/5 last:border-0 hover:text-main">
          <a href="/hexo-blog/public/category" class="flex h-12 sm:h-auto items-center">Categories</a>
        </li>
      
        <li class="nav-portfolio sm:mx-2 border-b sm:border-0 border-black/5 last:border-0 hover:text-main">
          <a href="/hexo-blog/public/tag" class="flex h-12 sm:h-auto items-center">Tags</a>
        </li>
      
    </ul>
  </div>
  <div class="mask bg-black/20 absolute inset-0"></div>
</div>

  <main class="pt-14">
    <!-- css -->

<link rel="stylesheet" href="/hexo-blog/public/lib/fancybox/fancybox.min.css">


<link rel="stylesheet" href="/hexo-blog/public/lib/tocbot/tocbot.min.css">

<!-- toc -->

  <!-- tocbot -->
<nav class="post-toc toc text-sm w-48 relative top-32 right-0 opacity-70 hidden lg:block" style="position: fixed !important;"></nav>


<section class="px-6 max-w-prose mx-auto md:px-0">
  <!-- header -->
  <header class="overflow-hidden pt-6 pb-6 md:pt-12">
    <div class="pt-4 md:pt-6">
      <h1 id="article-title" class="text-[2rem] font-bold leading-snug mb-4 md:mb-6 md:text-[2.6rem]">
        Kotlin 协程官方文档（5）异步流
      </h1>
      <div>
        <section class="flex items-center gap-3 text-sm">
          <span class="flex items-center gap-1">
            <iconify-icon width="18" icon="carbon-calendar" ></iconify-icon>
            <time>2025-03-02</time>
          </span>
          <span class="text-gray-400">·</span>
          <span class="flex items-center gap-1">
            <iconify-icon width="18" icon="ic:round-access-alarm" ></iconify-icon>
            <span>37 min</span>
          </span>
          <span class="text-gray-400">·</span>
          <span class="flex items-center gap-1">
            <iconify-icon width="18" icon="icon-park-outline:font-search" ></iconify-icon>
            <span>8.4k words</span>
          </span>
          
            <span class="text-gray-400">·</span>
            <span class="flex items-center gap-1">
              <iconify-icon width="16" icon="icon-park-outline:box" class="mr-2"></iconify-icon>
              <a class="article-category-link" href="/hexo-blog/public/categories/kotlin/">kotlin</a>
            </span>
          
        </section>
      </div>
    </div>
  </header>
  <!-- content -->
  <article class="post-content prose m-auto slide-enter-content dark:prose-invert">
    <blockquote>
<p>公众号：<a target="_blank" rel="noopener" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adbc507fc3704fd8955aae739a433db2~tplv-k3u1fbpfcp-zoom-1.image">字节数组</a></p>
<p>希望对你有所帮助 🤣🤣</p>
</blockquote>
<blockquote>
<p>最近一直在了解关于 <strong>Kotlin协程</strong> 的知识，那最好的学习资料自然是官方提供的学习文档了，看了看后我就萌生了翻译官方文档的想法。前后花了要接近一个月时间，一共九篇文章，在这里也分享出来，希望对读者有所帮助。个人知识所限，有些翻译得不是太顺畅，也希望读者能提出意见</p>
<p>协程官方文档：<a target="_blank" rel="noopener" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md">coroutines-guide</a></p>
</blockquote>
<p>挂起函数可以异步返回单个值，但如何返回多个异步计算值呢？这就是 kotlin Flows（流） 的用处了</p>
<h1 id="一、表示多个值"><a href="#一、表示多个值" class="headerlink" title="一、表示多个值"></a>一、表示多个值</h1><p>可以使用集合在 kotlin 中表示多个值。例如，有一个函数 foo()，它返回包含三个数字的 List，然后使用 forEach 打印它们</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: List&lt;<span class="built_in">Int</span>&gt; = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    foo().forEach &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="1-1、序列"><a href="#1-1、序列" class="headerlink" title="1.1、序列"></a>1.1、序列</h2><p>如果我们使用一些 CPU 消耗型 的阻塞代码（每次计算需要100毫秒）来计算数字，那么我们可以使用一个序列(Sequence)来表示数字：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Sequence&lt;<span class="built_in">Int</span>&gt; = sequence &#123;</span><br><span class="line">    <span class="comment">// sequence builder</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>) <span class="comment">// pretend we are computing it</span></span><br><span class="line">        yield(i) <span class="comment">// yield next value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    foo().forEach &#123; value -&gt; println(value) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码输出相同的数字列表，但每打印一个数字前都需要等待100毫秒</p>
<h2 id="1-2、挂起函数"><a href="#1-2、挂起函数" class="headerlink" title="1.2、挂起函数"></a>1.2、挂起函数</h2><p>上一节的代码的计算操作会阻塞运行代码的主线程。当这些值由异步代码计算时，我们可以用 suspend 修饰符标记函数 foo，以便它可以在不阻塞的情况下执行其工作，并将结果作为列表返回</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*                 </span><br><span class="line">                           </span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// pretend we are doing something asynchronous here</span></span><br><span class="line">    <span class="keyword">return</span> listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    foo().forEach &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br></pre></td></tr></table></figure>

<p>这段代码在等待一秒后输出数字</p>
<h2 id="1-3、Flows"><a href="#1-3、Flows" class="headerlink" title="1.3、Flows"></a>1.3、Flows</h2><p>使用 List&lt; Int &gt; 作为返回值类型，意味着我们只能同时返回所有值。为了表示异步计算的值流，我们可以使用 Flow&lt; Int &gt; 类型，就像同步计算值的 Sequence&lt; Int &gt; 类型一样</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123; <span class="comment">// flow builder</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// pretend we are doing something useful here</span></span><br><span class="line">        emit(i) <span class="comment">// emit next value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// Launch a concurrent coroutine to check if the main thread is blocked</span></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;I&#x27;m not blocked <span class="variable">$k</span>&quot;</span>)</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Collect the flow</span></span><br><span class="line">    foo().collect &#123; value -&gt; println(value) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br></pre></td></tr></table></figure>

<p>此代码在打印每个数字前等待100毫秒，但不会阻塞主线程。通过从主线程中运行的单独协程中每隔100毫秒打印了一次 “I’m not blocked”，可以验证这一点：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I<span class="string">&#x27;m not blocked 1</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">I&#x27;</span>m not blocked <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">I<span class="string">&#x27;m not blocked 3</span></span><br><span class="line"><span class="string">3</span></span><br></pre></td></tr></table></figure>

<p>请注意，代码与前面示例中的 Flow 有以下不同：</p>
<ul>
<li>Flow 类型的构造器函数名为 flow</li>
<li>flow{…} 中的代码块可以挂起</li>
<li>foo 函数不再标记 suspend 修饰符</li>
<li>值通过 emit 函数从流中发出</li>
<li>通过 collect 函数从 flow 中取值</li>
</ul>
<blockquote>
<p>我们可以用 Thread.sleep 来代替 flow{…} 中的 delay，可以看到在这种情况下主线程被阻塞住了</p>
</blockquote>
<h1 id="二、流是冷的"><a href="#二、流是冷的" class="headerlink" title="二、流是冷的"></a>二、流是冷的</h1><p>Flows 是冷流（cold streams），类似于序列（sequences），flow builder 中的代码在开始收集流值之前不会运行。在下面的示例中可以清楚地看到这一点：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="comment">//sampleStart      </span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123; </span><br><span class="line">    println(<span class="string">&quot;Flow started&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">        emit(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    println(<span class="string">&quot;Calling foo...&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> flow = foo()</span><br><span class="line">    println(<span class="string">&quot;Calling collect...&quot;</span>)</span><br><span class="line">    flow.collect &#123; value -&gt; println(value) &#125; </span><br><span class="line">    println(<span class="string">&quot;Calling collect again...&quot;</span>)</span><br><span class="line">    flow.collect &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Calling foo...</span><br><span class="line">Calling collect...</span><br><span class="line">Flow started</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">Calling collect again...</span><br><span class="line">Flow started</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>这是 foo() 函数（返回了 flow）未标记 <code>suspend</code> 修饰符的一个关键原因。<code>foo()</code> 本身返回很快，不会进行任何等待。flow 每次收集时都会启动，这就是我们再次调用 <code>collect</code> 时会看到“flow started”的原因</p>
<h1 id="三、取消流"><a href="#三、取消流" class="headerlink" title="三、取消流"></a>三、取消流</h1><p>Flow 采用和协程取同样的协作取消。但是，Flow 实现基础并没有引入额外的取消点，它对于取消操作是完全透明的。通常，流的收集操作可以在当流在一个可取消的挂起函数（如 delay）中挂起的时候取消，否则不能取消</p>
<p>以下示例展示了在 withTimeoutOrNull 块中流如何在超时时被取消并停止执行</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">        println(<span class="string">&quot;Emitting <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        emit(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    withTimeoutOrNull(<span class="number">250</span>) &#123;</span><br><span class="line">        <span class="comment">// Timeout after 250ms</span></span><br><span class="line">        foo().collect &#123; value -&gt; println(value) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br></pre></td></tr></table></figure>

<p>注意，foo() 函数中的 Flow 只传出两个数字，得到以下输出：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Emitting <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">Emitting <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Done</span><br></pre></td></tr></table></figure>

<p>相对应的，可以注释掉 flow 中的 delay 函数，并增大 for 循环的循环范围，此时可以发现 flow 没有被取消，因为 flow 中没有引入额外的挂起点</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.<span class="built_in">Int</span>.MAX_VALUE) &#123;</span><br><span class="line"><span class="comment">//        delay(100)</span></span><br><span class="line">        println(<span class="string">&quot;Emitting <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        emit(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    withTimeoutOrNull(<span class="number">250</span>) &#123;</span><br><span class="line">        <span class="comment">// Timeout after 250ms</span></span><br><span class="line">        foo().collect &#123; value -&gt; println(value) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br></pre></td></tr></table></figure>

<h1 id="四、流构建器"><a href="#四、流构建器" class="headerlink" title="四、流构建器"></a>四、流构建器</h1><p>前面例子中的 flow{…} 是最基础的一个流构建器，还有其它的构建器可以更容易地声明流：</p>
<ul>
<li>flowOf() 定义了一个发出固定值集的流构建器</li>
<li>可以使用扩展函数 <code>.asFlow()</code> 将各种集合和序列转换为流</li>
</ul>
<p>因此，从流中打印从 1 到 3 的数字的例子可以改写成：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">//sampleStart</span></span><br><span class="line">    <span class="comment">// Convert an integer range to a flow</span></span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).asFlow().collect &#123; value -&gt; println(value) &#125;</span><br><span class="line">    <span class="comment">//sampleEnd</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h1 id="五、中间流运算符"><a href="#五、中间流运算符" class="headerlink" title="五、中间流运算符"></a>五、中间流运算符</h1><p>可以使用运算符来转换流，就像使用集合和序列一样。中间运算符应用于上游流并返回下游流。这些运算符是冷操作符，和流一样。此类运算符本身不是挂起函数，它工作得很快，其返回一个新的转换后的流，但引用仅包含对新流的操作定义，并不马上进行转换</p>
<p>基础运算符有着熟悉的名称，例如 map 和 filter。流运算符和序列的重要区别在于流运算符中的代码可以调用挂起函数</p>
<p>例如，可以使用 map 运算符将传入请求流映射为结果值，即使执行请求是由挂起函数实现的长时间运行的操作：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">performRequest</span><span class="params">(request: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// imitate long-running asynchronous work</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;response <span class="variable">$request</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).asFlow() <span class="comment">// a flow of requests</span></span><br><span class="line">        .map &#123; request -&gt; performRequest(request) &#125;</span><br><span class="line">        .collect &#123; response -&gt; println(response) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br></pre></td></tr></table></figure>

<p>运行结果共有三行，每一秒打印一行输出</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response <span class="number">1</span></span><br><span class="line">response <span class="number">2</span></span><br><span class="line">response <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="5-1、转换操作符"><a href="#5-1、转换操作符" class="headerlink" title="5.1、转换操作符"></a>5.1、转换操作符</h2><p>在流的转换运算符中，最常用的一个称为 <code>transform</code>。它可以用来模拟简单的数据转换（就像 map 和 filter），以及实现更复杂的转换。使用 <code>transform</code> 运算符，我们可以发出任意次数的任意值</p>
<p>例如，通过使用 <code>transform</code>，我们可以在执行长时间运行的异步请求之前发出一个字符串，并在该字符串后面跟随一个响应：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">performRequest</span><span class="params">(request: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// imitate long-running asynchronous work</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;response <span class="variable">$request</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">//sampleStart</span></span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).asFlow() <span class="comment">// a flow of requests</span></span><br><span class="line">        .transform &#123; request -&gt;</span><br><span class="line">            emit(<span class="string">&quot;Making request <span class="variable">$request</span>&quot;</span>)</span><br><span class="line">            emit(performRequest(request))</span><br><span class="line">        &#125;</span><br><span class="line">        .collect &#123; response -&gt; println(response) &#125;</span><br><span class="line">    <span class="comment">//sampleEnd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Making request <span class="number">1</span></span><br><span class="line">response <span class="number">1</span></span><br><span class="line">Making request <span class="number">2</span></span><br><span class="line">response <span class="number">2</span></span><br><span class="line">Making request <span class="number">3</span></span><br><span class="line">response <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="5-2、限长运算符"><a href="#5-2、限长运算符" class="headerlink" title="5.2、限长运算符"></a>5.2、限长运算符</h2><p>限长中间运算符在达到相应限制时取消流的执行。协程中的取消总是通过抛出异常来实现，这样所有的资源管理函数（例如 try { … } finally { … } ）就可以在取消时正常执行</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">numbers</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        emit(<span class="number">1</span>)</span><br><span class="line">        emit(<span class="number">2</span>)</span><br><span class="line">        println(<span class="string">&quot;This line will not execute&quot;</span>)</span><br><span class="line">        emit(<span class="number">3</span>)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Finally in numbers&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    numbers()</span><br><span class="line">        .take(<span class="number">2</span>) <span class="comment">// take only the first two</span></span><br><span class="line">        .collect &#123; value -&gt; println(value) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br></pre></td></tr></table></figure>

<p>这段代码的输出清楚地显示了 numbers() 函数中的 flow{…} 函数体在发出第二个数字后就停止了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Finally <span class="keyword">in</span> numbers</span><br></pre></td></tr></table></figure>

<h1 id="六、流运算符"><a href="#六、流运算符" class="headerlink" title="六、流运算符"></a>六、流运算符</h1><p>终端流运算符是用于启动流的挂起函数。<code>collect</code> 是最基本的终端流运算符，但还有其它终端运算符，可以使得操作更加简便：</p>
<ul>
<li>转换为各种集合，如 toList 和 toSet 函数</li>
<li>first 运算符用于获取第一个值，single 运算符用于确保流发出单个值</li>
<li>使用 reduce 和 fold 将流还原为某个值</li>
</ul>
<p>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line"><span class="comment">//sampleStart         </span></span><br><span class="line">    <span class="keyword">val</span> sum = (<span class="number">1.</span><span class="number">.5</span>).asFlow()</span><br><span class="line">        .map &#123; it * it &#125; <span class="comment">// squares of numbers from 1 to 5                           </span></span><br><span class="line">        .reduce &#123; a, b -&gt; a + b &#125; <span class="comment">// sum them (terminal operator)</span></span><br><span class="line">    println(sum)</span><br><span class="line"><span class="comment">//sampleEnd     </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出单个值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">55</span></span><br></pre></td></tr></table></figure>

<h1 id="七、流是连续的"><a href="#七、流是连续的" class="headerlink" title="七、流是连续的"></a>七、流是连续的</h1><p>除非使用对多个流进行操作的特殊运算符，否则每个流的单独集合都是按顺序执行的。集合直接在调用终端运算符的协程中工作，默认情况下不会启动新的协程。每个发出的值都由所有中间运算符从上游到下游进行处理，然后在之后传递给终端运算符</p>
<p>请参阅以下示例，该示例过滤偶数并将其映射到字符串：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line"><span class="comment">//sampleStart         </span></span><br><span class="line">    (<span class="number">1.</span><span class="number">.5</span>).asFlow()</span><br><span class="line">        .filter &#123;</span><br><span class="line">            println(<span class="string">&quot;Filter <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            it % <span class="number">2</span> == <span class="number">0</span>              </span><br><span class="line">        &#125;              </span><br><span class="line">        .map &#123; </span><br><span class="line">            println(<span class="string">&quot;Map <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            <span class="string">&quot;string <span class="variable">$it</span>&quot;</span></span><br><span class="line">        &#125;.collect &#123; </span><br><span class="line">            println(<span class="string">&quot;Collect <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;    </span><br><span class="line"><span class="comment">//sampleEnd                  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Filter <span class="number">1</span></span><br><span class="line">Filter <span class="number">2</span></span><br><span class="line">Map <span class="number">2</span></span><br><span class="line">Collect string <span class="number">2</span></span><br><span class="line">Filter <span class="number">3</span></span><br><span class="line">Filter <span class="number">4</span></span><br><span class="line">Map <span class="number">4</span></span><br><span class="line">Collect string <span class="number">4</span></span><br><span class="line">Filter <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h1 id="八、流上下文"><a href="#八、流上下文" class="headerlink" title="八、流上下文"></a>八、流上下文</h1><p>流的收集总是在调用协程的上下文中执行。例如，如果存在 foo 流，则无论 foo 流的实现详细信息如何，以下代码都将在该开发者指定的上下文中执行：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">withContext(context) &#123;</span><br><span class="line">    foo.collect &#123; value -&gt;</span><br><span class="line">        println(value) <span class="comment">// run in the specified context </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流的这个特性称为上下文保留</p>
<p>所以，默认情况下，flow{…} 中的代码在相应流的收集器提供的上下文中运行。例如，观察 foo 的实现，它打印调用它的线程并发出三个数字：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">String</span>)</span></span> = println(<span class="string">&quot;[<span class="subst">$&#123;Thread.currentThread().name&#125;</span>] <span class="variable">$msg</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    log(<span class="string">&quot;Started foo flow&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        emit(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    foo().collect &#123; value -&gt; log(<span class="string">&quot;Collected <span class="variable">$value</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[main <span class="meta">@coroutine</span>#<span class="number">1</span>] Started foo flow</span><br><span class="line">[main <span class="meta">@coroutine</span>#<span class="number">1</span>] Collected <span class="number">1</span></span><br><span class="line">[main <span class="meta">@coroutine</span>#<span class="number">1</span>] Collected <span class="number">2</span></span><br><span class="line">[main <span class="meta">@coroutine</span>#<span class="number">1</span>] Collected <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>由于 <code>foo().collect</code> 是在主线程调用的，所以 foo 流也是在主线程中调用。对于不关心执行上下文且不阻塞调用方的快速返回代码或者异步代码，这是完美的默认设置</p>
<h2 id="8-1、错误地使用-withContext"><a href="#8-1、错误地使用-withContext" class="headerlink" title="8.1、错误地使用 withContext"></a>8.1、错误地使用 withContext</h2><p>但是，可能需要在 Dispatchers 的上下文中执行长时间运行的占用 CPU 的代码，可能需要在 Dispatchers.Main 的上下文中执行默认代码和 UI 更新。通常，withContext 用于在使用 kotlin 协程时更改代码中的上下文，但 <code>fow&#123;...&#125;</code> 中的代码必须遵守上下文本保留属性，并且不允许从其它上下文中触发</p>
<p>尝试运行以下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line">                      </span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="comment">// The WRONG way to change context for CPU-consuming code in flow builder</span></span><br><span class="line">    kotlinx.coroutines.withContext(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>) <span class="comment">// pretend we are computing it in CPU-consuming way</span></span><br><span class="line">            emit(i) <span class="comment">// emit next value</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    foo().collect &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;            </span><br><span class="line"><span class="comment">//sampleEnd</span></span><br></pre></td></tr></table></figure>

<p>代码会生成以下异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalStateException: Flow invariant is violated:</span><br><span class="line">		Flow was collected in [CoroutineId(1), &quot;coroutine#1&quot;:BlockingCoroutine&#123;Active&#125;@5511c7f8, BlockingEventLoop@2eac3323],</span><br><span class="line">		but emission happened in [CoroutineId(1), &quot;coroutine#1&quot;:DispatchedCoroutine&#123;Active&#125;@2dae0000, DefaultDispatcher].</span><br><span class="line">		Please refer to &#x27;flow&#x27; documentation or use &#x27;flowOn&#x27; instead</span><br><span class="line">	at ...</span><br></pre></td></tr></table></figure>

<h2 id="8-2、flowOn-运算符"><a href="#8-2、flowOn-运算符" class="headerlink" title="8.2、flowOn 运算符"></a>8.2、flowOn 运算符</h2><p>有个例外情况，flowOn 函数能用于改变流发送值时的上下文。改变流上下文的正确方式如下面的示例所示，该示例还打印了相应线程的名称，以显示所有线程的工作方式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">String</span>)</span></span> = println(<span class="string">&quot;[<span class="subst">$&#123;Thread.currentThread().name&#125;</span>] <span class="variable">$msg</span>&quot;</span>)</span><br><span class="line">           </span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>) <span class="comment">// pretend we are computing it in CPU-consuming way</span></span><br><span class="line">        log(<span class="string">&quot;Emitting <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        emit(i) <span class="comment">// emit next value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.flowOn(Dispatchers.Default) <span class="comment">// RIGHT way to change context for CPU-consuming code in flow builder</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    foo().collect &#123; value -&gt;</span><br><span class="line">        log(<span class="string">&quot;Collected <span class="variable">$value</span>&quot;</span>) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;            </span><br><span class="line"><span class="comment">//sampleEnd</span></span><br></pre></td></tr></table></figure>

<p>注意，flow{…} 在后台线程中工作，而在主线程中进行取值</p>
<p>这里要注意的另一件事是 flowOn 操作符改变了流的默认顺序性质。现在取值操作发生在协程 “coroutine#1” 中，而发射值的操作同时运行在另一个线程中的协程 “coroutine#2” 上。当必须在上游流的上下文中更改 CoroutineDispatcher 时，flowOn 运算符将为该上游流创建另一个协程</p>
<h1 id="九、缓冲"><a href="#九、缓冲" class="headerlink" title="九、缓冲"></a>九、缓冲</h1><p>从收集流所需的总时间的角度来看，在不同的协程中运行流的不同部分可能会有所帮助，特别是当涉及到长时间运行的异步操作时。例如，假设 foo() 流的发射很慢，生成元素需要100毫秒；收集器也很慢，处理元素需要300毫秒。让我们看看用三个数字收集这样的流需要多长时间：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"><span class="keyword">import</span> kotlin.system.*</span><br><span class="line"></span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// pretend we are asynchronously waiting 100 ms</span></span><br><span class="line">        emit(i) <span class="comment">// emit next value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        foo().collect &#123; value -&gt; </span><br><span class="line">            delay(<span class="number">300</span>) <span class="comment">// pretend we are processing it for 300 ms</span></span><br><span class="line">            println(value) </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;   </span><br><span class="line">    println(<span class="string">&quot;Collected in <span class="variable">$time</span> ms&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br></pre></td></tr></table></figure>

<p>以上代码会产生如下类似的结果，整个收集过程大约需要1200毫秒（三个数字，每个400毫秒）</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">Collected <span class="keyword">in</span> <span class="number">1220</span> ms</span><br></pre></td></tr></table></figure>

<p>我们可以在流上使用 buffer 运算符，在运行取集代码的同时运行 foo() 的发值代码，而不是按顺序运行它们</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"><span class="keyword">import</span> kotlin.system.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// pretend we are asynchronously waiting 100 ms</span></span><br><span class="line">        emit(i) <span class="comment">// emit next value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        foo()</span><br><span class="line">            .buffer() <span class="comment">// buffer emissions, don&#x27;t wait</span></span><br><span class="line">            .collect &#123; value -&gt; </span><br><span class="line">                delay(<span class="number">300</span>) <span class="comment">// pretend we are processing it for 300 ms</span></span><br><span class="line">                println(value) </span><br><span class="line">            &#125; </span><br><span class="line">    &#125;   </span><br><span class="line">    println(<span class="string">&quot;Collected in <span class="variable">$time</span> ms&quot;</span>)</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这可以得到相同的输出结果但运行速度更快，因为我们已经有效地创建了一个处理管道，第一个数字只需要等待100毫秒，然后只需要花费300毫秒来处理每个数字。这样运行大约需要1000毫秒：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">Collected <span class="keyword">in</span> <span class="number">1071</span> ms</span><br></pre></td></tr></table></figure>

<p>请注意，flowOn 运算符在必须更改 CoroutineDispatcher 时使用相同的缓冲机制，但这里我们显示地请求缓冲而不更改执行上下文</p>
<h2 id="9-1、合并"><a href="#9-1、合并" class="headerlink" title="9.1、合并"></a>9.1、合并</h2><p>当流用于表示操作或操作状态更新的部分结果时，可能不需要处理每个值，而是只处理最近的值。在这种情况下，当取值器处理中间值太慢时，可以使用合并运算符跳过中间值。在前面的例子的基础上再来修改下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"><span class="keyword">import</span> kotlin.system.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// pretend we are asynchronously waiting 100 ms</span></span><br><span class="line">        emit(i) <span class="comment">// emit next value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        foo()</span><br><span class="line">            .conflate() <span class="comment">// conflate emissions, don&#x27;t process each one</span></span><br><span class="line">            .collect &#123; value -&gt; </span><br><span class="line">                delay(<span class="number">300</span>) <span class="comment">// pretend we are processing it for 300 ms</span></span><br><span class="line">                println(value) </span><br><span class="line">            &#125; </span><br><span class="line">    &#125;   </span><br><span class="line">    println(<span class="string">&quot;Collected in <span class="variable">$time</span> ms&quot;</span>)</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，虽然第一个数字仍在处理中，但第二个数字和第三个数字已经生成，因此第二个数字被合并（丢弃），只有最近的一个数字（第三个）被交付给取值器：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">Collected <span class="keyword">in</span> <span class="number">758</span> ms</span><br></pre></td></tr></table></figure>

<h2 id="9-2、处理最新值"><a href="#9-2、处理最新值" class="headerlink" title="9.2、处理最新值"></a>9.2、处理最新值</h2><p>在发射端和处理端都很慢的情况下，合并是加快处理速度的一种方法。它通过丢弃发射的值来实现。另一种方法是取消慢速收集器，并在每次发出新值时重新启动它。有一系列 xxxLatest 运算符与 xxx 运算符执行相同的基本逻辑，但是在新值产生的时候取消执行其块中的代码。在前面的示例中，我们尝试将 conflate 更改为 collectLatest：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"><span class="keyword">import</span> kotlin.system.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// pretend we are asynchronously waiting 100 ms</span></span><br><span class="line">        emit(i) <span class="comment">// emit next value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        foo()</span><br><span class="line">            .collectLatest &#123; value -&gt; <span class="comment">// cancel &amp; restart on the latest value</span></span><br><span class="line">                println(<span class="string">&quot;Collecting <span class="variable">$value</span>&quot;</span>) </span><br><span class="line">                delay(<span class="number">300</span>) <span class="comment">// pretend we are processing it for 300 ms</span></span><br><span class="line">                println(<span class="string">&quot;Done <span class="variable">$value</span>&quot;</span>) </span><br><span class="line">            &#125; </span><br><span class="line">    &#125;   </span><br><span class="line">    println(<span class="string">&quot;Collected in <span class="variable">$time</span> ms&quot;</span>)</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 collectLatest 的主体需要延迟300毫秒，而每100毫秒会发出一个新值，因此我们可以看到 collectLatest 代码块得到了每一个发射值，但最终只完成了最后一个值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collecting <span class="number">1</span></span><br><span class="line">Collecting <span class="number">2</span></span><br><span class="line">Collecting <span class="number">3</span></span><br><span class="line">Done <span class="number">3</span></span><br><span class="line">Collected <span class="keyword">in</span> <span class="number">741</span> ms</span><br></pre></td></tr></table></figure>

<h1 id="十、组合多个流"><a href="#十、组合多个流" class="headerlink" title="十、组合多个流"></a>十、组合多个流</h1><p>有许多方法可以组合多个流</p>
<h2 id="10-1、zip"><a href="#10-1、zip" class="headerlink" title="10.1、zip"></a>10.1、zip</h2><p>与 Kotlin 标准库中的 Sequence.zip 扩展函数一样，流有一个 zip 运算符，用于组合两个流的相应值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line"><span class="comment">//sampleStart                                                                           </span></span><br><span class="line">    <span class="keyword">val</span> nums = (<span class="number">1.</span><span class="number">.3</span>).asFlow() <span class="comment">// numbers 1..3</span></span><br><span class="line">    <span class="keyword">val</span> strs = flowOf(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>) <span class="comment">// strings </span></span><br><span class="line">    nums.zip(strs) &#123; a, b -&gt; <span class="string">&quot;<span class="variable">$a</span> -&gt; <span class="variable">$b</span>&quot;</span> &#125; <span class="comment">// compose a single string</span></span><br><span class="line">        .collect &#123; println(it) &#125; <span class="comment">// collect and print</span></span><br><span class="line"><span class="comment">//sampleEnd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> -&gt; one</span><br><span class="line"><span class="number">2</span> -&gt; two</span><br><span class="line"><span class="number">3</span> -&gt; three</span><br></pre></td></tr></table></figure>

<h2 id="10-2、Combine"><a href="#10-2、Combine" class="headerlink" title="10.2、Combine"></a>10.2、Combine</h2><p>当 flow 表示变量或操作的最新值时（参阅有关 conflation 的相关章节），可能需要执行依赖于相应流的最新值的计算，并在任何上游流发出值时重新计算它。相应的运算符族称为 combine</p>
<p>例如，如果上例中的数字每300毫秒更新一次，但字符串每400毫秒更新一次，则使用 zip 运算符压缩它们仍会产生相同的结果，尽管结果是每400毫秒打印一次</p>
<blockquote>
<p>在本例中，我们使用中间运算符 onEach 来延迟每个元素，并使发出样本流的代码更具声明性，更加简短</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line"><span class="comment">//sampleStart                                                                           </span></span><br><span class="line">    <span class="keyword">val</span> nums = (<span class="number">1.</span><span class="number">.3</span>).asFlow().onEach &#123; delay(<span class="number">300</span>) &#125; <span class="comment">// numbers 1..3 every 300 ms</span></span><br><span class="line">    <span class="keyword">val</span> strs = flowOf(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>).onEach &#123; delay(<span class="number">400</span>) &#125; <span class="comment">// strings every 400 ms</span></span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// remember the start time </span></span><br><span class="line">    nums.zip(strs) &#123; a, b -&gt; <span class="string">&quot;<span class="variable">$a</span> -&gt; <span class="variable">$b</span>&quot;</span> &#125; <span class="comment">// compose a single string with &quot;zip&quot;</span></span><br><span class="line">        .collect &#123; value -&gt; <span class="comment">// collect and print </span></span><br><span class="line">            println(<span class="string">&quot;<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start&quot;</span>) </span><br><span class="line">        &#125; </span><br><span class="line"><span class="comment">//sampleEnd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，如果在此处使用 combine 运算符而不是 zip 时：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line"><span class="comment">//sampleStart                                                                           </span></span><br><span class="line">    <span class="keyword">val</span> nums = (<span class="number">1.</span><span class="number">.3</span>).asFlow().onEach &#123; delay(<span class="number">300</span>) &#125; <span class="comment">// numbers 1..3 every 300 ms</span></span><br><span class="line">    <span class="keyword">val</span> strs = flowOf(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>).onEach &#123; delay(<span class="number">400</span>) &#125; <span class="comment">// strings every 400 ms          </span></span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// remember the start time </span></span><br><span class="line">    nums.combine(strs) &#123; a, b -&gt; <span class="string">&quot;<span class="variable">$a</span> -&gt; <span class="variable">$b</span>&quot;</span> &#125; <span class="comment">// compose a single string with &quot;combine&quot;</span></span><br><span class="line">        .collect &#123; value -&gt; <span class="comment">// collect and print </span></span><br><span class="line">            println(<span class="string">&quot;<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start&quot;</span>) </span><br><span class="line">        &#125; </span><br><span class="line"><span class="comment">//sampleEnd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们得到了完全不同的输出：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> -&gt; one at <span class="number">452</span> ms from start</span><br><span class="line"><span class="number">2</span> -&gt; one at <span class="number">651</span> ms from start</span><br><span class="line"><span class="number">2</span> -&gt; two at <span class="number">854</span> ms from start</span><br><span class="line"><span class="number">3</span> -&gt; two at <span class="number">952</span> ms from start</span><br><span class="line"><span class="number">3</span> -&gt; three at <span class="number">1256</span> ms from start</span><br></pre></td></tr></table></figure>

<h1 id="十一、展平流"><a href="#十一、展平流" class="headerlink" title="十一、展平流"></a>十一、展平流</h1><p>流表示异步接收的值序列，因此在每个值触发对另一个值序列的请求的情况下很容易获取新值。例如，我们可以使用以下函数，该函数返回相隔500毫秒的两个字符串流：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">requestFlow</span><span class="params">(i: <span class="type">Int</span>)</span></span>: Flow&lt;String&gt; = flow &#123;</span><br><span class="line">    emit(<span class="string">&quot;<span class="variable">$i</span>: First&quot;</span>) </span><br><span class="line">    delay(<span class="number">500</span>) <span class="comment">// wait 500 ms</span></span><br><span class="line">    emit(<span class="string">&quot;<span class="variable">$i</span>: Second&quot;</span>)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，如果我们有一个包含三个整数的流，并为每个整数调用 requestFlow，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1.</span><span class="number">.3</span>).asFlow().map &#123; requestFlow(it) &#125;</span><br></pre></td></tr></table></figure>

<p>然后我们最终得到一个流（flow&lt; flow&lt; String &gt;&gt;），需要将其展平为单独一个流以进行进一步处理。集合和序列对此提供了 flatten 和 flatMap 运算符。然而，由于流的异步特性，它们需要不同的展开模式，因此流上有一系列 flattening 运算符</p>
<h2 id="11-1、flatMapConcat"><a href="#11-1、flatMapConcat" class="headerlink" title="11.1、flatMapConcat"></a>11.1、flatMapConcat</h2><p>flatMapConcat 和 flattencat 运算符实现了 Concatenating 模式，它们是与序列运算符最直接的类比。它们等待内部流完成，然后开始收集下一个流，如下例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">requestFlow</span><span class="params">(i: <span class="type">Int</span>)</span></span>: Flow&lt;String&gt; = flow &#123;</span><br><span class="line">    emit(<span class="string">&quot;<span class="variable">$i</span>: First&quot;</span>)</span><br><span class="line">    delay(<span class="number">500</span>) <span class="comment">// wait 500 ms</span></span><br><span class="line">    emit(<span class="string">&quot;<span class="variable">$i</span>: Second&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">//sampleStart</span></span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// remember the start time</span></span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).asFlow().onEach &#123; delay(<span class="number">100</span>) &#125; <span class="comment">// a number every 100 ms</span></span><br><span class="line">        .flatMapConcat &#123; requestFlow(it) &#125;</span><br><span class="line">        .collect &#123; value -&gt;</span><br><span class="line">            <span class="comment">// collect and print</span></span><br><span class="line">            println(<span class="string">&quot;<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>flatMapConcat 的顺序特性在输出结果中清晰可见：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: First at <span class="number">121</span> ms from start</span><br><span class="line"><span class="number">1</span>: Second at <span class="number">622</span> ms from start</span><br><span class="line"><span class="number">2</span>: First at <span class="number">727</span> ms from start</span><br><span class="line"><span class="number">2</span>: Second at <span class="number">1227</span> ms from start</span><br><span class="line"><span class="number">3</span>: First at <span class="number">1328</span> ms from start</span><br><span class="line"><span class="number">3</span>: Second at <span class="number">1829</span> ms from start</span><br></pre></td></tr></table></figure>

<h2 id="11-2、flatMapMerge"><a href="#11-2、flatMapMerge" class="headerlink" title="11.2、flatMapMerge"></a>11.2、flatMapMerge</h2><p>另一种 flattening 模式是同时收集所有传入流并将其值合并到单个流中，以便尽快发出值。它由 flatMapMerge  和 flattenMerge 运算符实现。它们都接受一个可选的并发参数，该参数用于限制同时收集的并发流的数量（默认情况下等于 DEFAULT_CONCURRENCY）</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">requestFlow</span><span class="params">(i: <span class="type">Int</span>)</span></span>: Flow&lt;String&gt; = flow &#123;</span><br><span class="line">    emit(<span class="string">&quot;<span class="variable">$i</span>: First&quot;</span>) </span><br><span class="line">    delay(<span class="number">500</span>) <span class="comment">// wait 500 ms</span></span><br><span class="line">    emit(<span class="string">&quot;<span class="variable">$i</span>: Second&quot;</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// remember the start time </span></span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).asFlow().onEach &#123; delay(<span class="number">100</span>) &#125; <span class="comment">// a number every 100 ms </span></span><br><span class="line">        .flatMapMerge &#123; requestFlow(it) &#125;                                                                           </span><br><span class="line">        .collect &#123; value -&gt; <span class="comment">// collect and print </span></span><br><span class="line">            println(<span class="string">&quot;<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start&quot;</span>) </span><br><span class="line">        &#125; </span><br><span class="line"><span class="comment">//sampleEnd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>flatMapMerge 的并发性是显而易见的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: First at <span class="number">136</span> ms from start</span><br><span class="line"><span class="number">2</span>: First at <span class="number">231</span> ms from start</span><br><span class="line"><span class="number">3</span>: First at <span class="number">333</span> ms from start</span><br><span class="line"><span class="number">1</span>: Second at <span class="number">639</span> ms from start</span><br><span class="line"><span class="number">2</span>: Second at <span class="number">732</span> ms from start</span><br><span class="line"><span class="number">3</span>: Second at <span class="number">833</span> ms from start</span><br></pre></td></tr></table></figure>

<p>请注意，flatMapMerge 按顺序调用其代码块（{requestFlow(it)}），但同时收集结果流，这相当于先执行序列 map{requestFlow(it)}，然后对返回值调用 flattenMerge</p>
<h2 id="11-3、flatMapLatest"><a href="#11-3、flatMapLatest" class="headerlink" title="11.3、flatMapLatest"></a>11.3、flatMapLatest</h2><p>与“Processing the latest value（处理最新值）”章节介绍的 collectLatest 操作符类似，存在相应的 “Latest” flattening 模式。在该模式下，一旦发出新流，将取消先前已发出的流。这通过 flatMapLatest 运算符实现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">requestFlow</span><span class="params">(i: <span class="type">Int</span>)</span></span>: Flow&lt;String&gt; = flow &#123;</span><br><span class="line">    emit(<span class="string">&quot;<span class="variable">$i</span>: First&quot;</span>) </span><br><span class="line">    delay(<span class="number">500</span>) <span class="comment">// wait 500 ms</span></span><br><span class="line">    emit(<span class="string">&quot;<span class="variable">$i</span>: Second&quot;</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// remember the start time </span></span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).asFlow().onEach &#123; delay(<span class="number">100</span>) &#125; <span class="comment">// a number every 100 ms </span></span><br><span class="line">        .flatMapLatest &#123; requestFlow(it) &#125;                                                                           </span><br><span class="line">        .collect &#123; value -&gt; <span class="comment">// collect and print </span></span><br><span class="line">            println(<span class="string">&quot;<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start&quot;</span>) </span><br><span class="line">        &#125; </span><br><span class="line"><span class="comment">//sampleEnd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本例中的输出很好的演示了 flatMapLatest 的工作原理</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: First at <span class="number">142</span> ms from start</span><br><span class="line"><span class="number">2</span>: First at <span class="number">322</span> ms from start</span><br><span class="line"><span class="number">3</span>: First at <span class="number">425</span> ms from start</span><br><span class="line"><span class="number">3</span>: Second at <span class="number">931</span> ms from start</span><br></pre></td></tr></table></figure>

<p>请注意，当新值到来时，flatMapLatest 将取消其块中的所有代码（{requestFlow(it)}）。requestFlow 函数本身的调用是很快速的，并非挂起函数，如果其内部不包含额外的挂起点，那么它就不能被取消，所以此处就在其内部使用了 delay 函数，使其可以达到被取消的目的</p>
<h1 id="十二、流异常"><a href="#十二、流异常" class="headerlink" title="十二、流异常"></a>十二、流异常</h1><p>当发射器或运算符内部的代码引发异常时，流收集器可以结束运行，但会出现异常。有几种方法可以处理这些异常</p>
<h2 id="12-1、收集器-try-与-catch"><a href="#12-1、收集器-try-与-catch" class="headerlink" title="12.1、收集器 try 与 catch"></a>12.1、收集器 try 与 catch</h2><p>收集器可以使用 kotlin 的 try&#x2F;catch 代码块来处理异常</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;Emitting <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        emit(i) <span class="comment">// emit next value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        foo().collect &#123; value -&gt;         </span><br><span class="line">            println(value)</span><br><span class="line">            check(value &lt;= <span class="number">1</span>) &#123; <span class="string">&quot;Collected <span class="variable">$value</span>&quot;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">        println(<span class="string">&quot;Caught <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;            </span><br><span class="line"><span class="comment">//sampleEnd</span></span><br></pre></td></tr></table></figure>

<p>此代码成功捕获 collect 运算符中的异常，如我们所见，在此之后不再发出任何值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Emitting <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">Emitting <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Caught java.lang.IllegalStateException: Collected <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="12-2、一切都已捕获"><a href="#12-2、一切都已捕获" class="headerlink" title="12.2、一切都已捕获"></a>12.2、一切都已捕获</h2><p>前面的示例实际上捕获了发射器或任何中间或终端运算符中发生的任何异常。例如，让我们更改代码，以便将发出的值映射到字符串，但相应的代码会产生异常：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;String&gt; = </span><br><span class="line">    flow &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;Emitting <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            emit(i) <span class="comment">// emit next value</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .map &#123; value -&gt;</span><br><span class="line">        check(value &lt;= <span class="number">1</span>) &#123; <span class="string">&quot;Crashed on <span class="variable">$value</span>&quot;</span> &#125;                 </span><br><span class="line">        <span class="string">&quot;string <span class="variable">$value</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        foo().collect &#123; value -&gt; println(value) &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">        println(<span class="string">&quot;Caught <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;            </span><br><span class="line"><span class="comment">//sampleEnd</span></span><br></pre></td></tr></table></figure>

<p>仍捕获此异常并停止收集：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Emitting <span class="number">1</span></span><br><span class="line">string <span class="number">1</span></span><br><span class="line">Emitting <span class="number">2</span></span><br><span class="line">Caught java.lang.IllegalStateException: Crashed on <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h1 id="十三、异常透明性"><a href="#十三、异常透明性" class="headerlink" title="十三、异常透明性"></a>十三、异常透明性</h1><p>但是发射器的代码如何封装其异常处理行为呢？</p>
<p>flows 对于异常必须是透明的，并且在 flow{…} 构建器中发射值有可能抛出异常时，异常必须显式地从 try&#x2F;catch 块内部抛出。这保证了抛出异常的收集器始终可以使用 try&#x2F;catch 来捕获异常，如前一个示例所示</p>
<p>发射器可以使用 catch 运算符来保持此异常的透明性，并允许封装其异常处理行为。catch 运算符可以分析异常并根据捕获到的异常以不同的方式对其作出反应：</p>
<ul>
<li>可以使用 throw 重新引发异常</li>
<li>使用 catch 的 emit 可以将异常转换为值的 emission</li>
<li>异常可以被其他代码忽略、记录或处理</li>
</ul>
<p>例如，让我们在捕获异常时发出一段文本：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;String&gt; = </span><br><span class="line">    flow &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;Emitting <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            emit(i) <span class="comment">// emit next value</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .map &#123; value -&gt;</span><br><span class="line">        check(value &lt;= <span class="number">1</span>) &#123; <span class="string">&quot;Crashed on <span class="variable">$value</span>&quot;</span> &#125;                 </span><br><span class="line">        <span class="string">&quot;string <span class="variable">$value</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line">    foo()</span><br><span class="line">        .<span class="keyword">catch</span> &#123; e -&gt; emit(<span class="string">&quot;Caught <span class="variable">$e</span>&quot;</span>) &#125; <span class="comment">// emit on exception</span></span><br><span class="line">        .collect &#123; value -&gt; println(value) &#125;</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure>

<p>示例代码的输出结果是与之前相同的，即使我们不再在代码周围使用 try&#x2F;catch</p>
<h2 id="13-1、透明捕获"><a href="#13-1、透明捕获" class="headerlink" title="13.1、透明捕获"></a>13.1、透明捕获</h2><p>catch 中间运算符遵循异常透明性，只捕获上游异常（即 catch 上所有运算符的异常，而不是 catch 下所有运算符的异常）。如果 collect{…}（放在 catch 下面）抛出异常，程序将退出：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;Emitting <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        emit(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    foo()</span><br><span class="line">        .<span class="keyword">catch</span> &#123; e -&gt; println(<span class="string">&quot;Caught <span class="variable">$e</span>&quot;</span>) &#125; <span class="comment">// does not catch downstream exceptions</span></span><br><span class="line">        .collect &#123; value -&gt;</span><br><span class="line">            check(value &lt;= <span class="number">1</span>) &#123; <span class="string">&quot;Collected <span class="variable">$value</span>&quot;</span> &#125;                 </span><br><span class="line">            println(value) </span><br><span class="line">        &#125;</span><br><span class="line">&#125;            </span><br><span class="line"><span class="comment">//sampleEnd</span></span><br></pre></td></tr></table></figure>

<p>尽管存在 catch 运算符，但不会打印 “Caught …” 日志</p>
<h2 id="13-2、声明式捕获"><a href="#13-2、声明式捕获" class="headerlink" title="13.2、声明式捕获"></a>13.2、声明式捕获</h2><p>我们可以将 catch 运算符的声明性与处理所有异常的愿望结合起来，方法是将 collect 运算符原先所要做的操作移动到 onEach 中，并将其放在 catch 运算符之前。此流的取值操作必须由不带参数的 collect() 函数来调用触发：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;Emitting <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        emit(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line">    foo()</span><br><span class="line">        .onEach &#123; value -&gt;</span><br><span class="line">            check(value &lt;= <span class="number">1</span>) &#123; <span class="string">&quot;Collected <span class="variable">$value</span>&quot;</span> &#125;                 </span><br><span class="line">            println(value) </span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="keyword">catch</span> &#123; e -&gt; println(<span class="string">&quot;Caught <span class="variable">$e</span>&quot;</span>) &#125;</span><br><span class="line">        .collect()</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure>

<p>现在我们可以看到打印了一条 “Caught …” 消息，至此我们捕获了所有异常，而无需显式使用 try&#x2F;catch </p>
<h1 id="十四、流完成"><a href="#十四、流完成" class="headerlink" title="十四、流完成"></a>十四、流完成</h1><p>当流收集完成时（正常或异常），它可能需要执行一个操作。正如你可能已经注意到的，它可以通过两种方式完成：命令式或声明式</p>
<h2 id="14-1、命令式-finally-块"><a href="#14-1、命令式-finally-块" class="headerlink" title="14.1、命令式 finally 块"></a>14.1、命令式 finally 块</h2><p>除了 try&#x2F;catch 外，收集器还可以使用 finally 在收集完成时执行操作</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = (<span class="number">1.</span><span class="number">.3</span>).asFlow()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        foo().collect &#123; value -&gt; println(value) &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;            </span><br><span class="line"><span class="comment">//sampleEnd</span></span><br></pre></td></tr></table></figure>

<p>此代码打印 fon() 流生成的三个数字，之后跟随 “Done” 字符串</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">Done</span><br></pre></td></tr></table></figure>

<h2 id="14-2、声明式处理"><a href="#14-2、声明式处理" class="headerlink" title="14.2、声明式处理"></a>14.2、声明式处理</h2><p>对于声明性方法，flow 有一个 onCompletion 中间运算符，该运算符在流完全收集后调用</p>
<p>前面的示例可以使用 onCompletion 运算符重写，并生成相同的输出：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = (<span class="number">1.</span><span class="number">.3</span>).asFlow()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line">    foo()</span><br><span class="line">        .onCompletion &#123; println(<span class="string">&quot;Done&quot;</span>) &#125;</span><br><span class="line">        .collect &#123; value -&gt; println(value) &#125;</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure>

<p>onCompletion 的主要优点是包含一个 lambda 参数，该 lambda 包含一个可空的 Throwable 参数，该 Throwable 参数可用于确定流收集是正常完成还是异常完成。在以下示例中，foo() 流在发出数字1后引发异常：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    emit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">throw</span> RuntimeException()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    foo()</span><br><span class="line">        .onCompletion &#123; cause -&gt; <span class="keyword">if</span> (cause != <span class="literal">null</span>) println(<span class="string">&quot;Flow completed exceptionally&quot;</span>) &#125;</span><br><span class="line">        .<span class="keyword">catch</span> &#123; cause -&gt; println(<span class="string">&quot;Caught exception&quot;</span>) &#125;</span><br><span class="line">        .collect &#123; value -&gt; println(value) &#125;</span><br><span class="line">&#125;            </span><br><span class="line"><span class="comment">//sampleEnd</span></span><br></pre></td></tr></table></figure>

<p>如你所料，将打印：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">Flow completed exceptionally</span><br><span class="line">Caught exception</span><br></pre></td></tr></table></figure>

<p>与 catch 运算符不同，onCompletion 运算符不处理异常。正如我们从上面的示例代码中看到的，异常仍然会流向下游。它将被传递给其他完成 onCompletion 运算符，并可以使用 catch 运算符进行处理</p>
<h2 id="14-3、仅限上游异常"><a href="#14-3、仅限上游异常" class="headerlink" title="14.3、仅限上游异常"></a>14.3、仅限上游异常</h2><p>就像 catch 操作符一样，onCompletion 只看到来自上游的异常，而看不到下游的异常。例如，运行以下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = (<span class="number">1.</span><span class="number">.3</span>).asFlow()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    foo()</span><br><span class="line">        .onCompletion &#123; cause -&gt; println(<span class="string">&quot;Flow completed with <span class="variable">$cause</span>&quot;</span>) &#125;</span><br><span class="line">        .collect &#123; value -&gt;</span><br><span class="line">            check(value &lt;= <span class="number">1</span>) &#123; <span class="string">&quot;Collected <span class="variable">$value</span>&quot;</span> &#125;                 </span><br><span class="line">            println(value) </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到  completion cause 为空，但流收集失败并抛出异常:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">Flow completed with <span class="literal">null</span></span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.IllegalStateException: Collected <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h1 id="十五、命令式还是声明式"><a href="#十五、命令式还是声明式" class="headerlink" title="十五、命令式还是声明式"></a>十五、命令式还是声明式</h1><p>现在我们知道如何收集流，并以命令式和声明式的方式处理它的完成和异常。这里很自然的就有了个问题，应该首选哪种方法呢？为什么？作为一个库，我们不提倡任何特定的方法，并且相信这两种方式都是有效的，应该根据你自己的偏好和代码风格来选择</p>
<h1 id="十六、启动流"><a href="#十六、启动流" class="headerlink" title="十六、启动流"></a>十六、启动流</h1><p>很容易使用流来表示来自某个数据源的异步事件。在这种情况下，我们需要一个模拟的 addEventListener 函数，该函数将一段代码注册为对传入事件的响应，并继续进一步工作。onEach 运算符可以担任此角色。然而，onEach 是一个中间运算符。我们还需要一个终端运算符来收集数据。否则，只注册 onEach 是没有效果的</p>
<p>如果在 onEach 之后使用 collect 终端运算符，则在 collect 之后的代码将等待流被收集完成后再运行：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line"><span class="comment">// Imitate a flow of events</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">events</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = (<span class="number">1.</span><span class="number">.3</span>).asFlow().onEach &#123; delay(<span class="number">100</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    events()</span><br><span class="line">        .onEach &#123; event -&gt; println(<span class="string">&quot;Event: <span class="variable">$event</span>&quot;</span>) &#125;</span><br><span class="line">        .collect() <span class="comment">// &lt;--- Collecting the flow waits</span></span><br><span class="line">    println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;            </span><br><span class="line"><span class="comment">//sampleEnd</span></span><br></pre></td></tr></table></figure>

<p>如你所见，将打印</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Event: <span class="number">1</span></span><br><span class="line">Event: <span class="number">2</span></span><br><span class="line">Event: <span class="number">3</span></span><br><span class="line">Done</span><br></pre></td></tr></table></figure>

<p>launchIn 终端运算符在这里是很实用的。通过将 collect 替换为 launchIn，我们可以在单独的协程中启动收集流数据的操作，以便立即继续执行下一步的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="comment">// Imitate a flow of events</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">events</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = (<span class="number">1.</span><span class="number">.3</span>).asFlow().onEach &#123; delay(<span class="number">100</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    events()</span><br><span class="line">        .onEach &#123; event -&gt; println(<span class="string">&quot;Event: <span class="variable">$event</span>&quot;</span>) &#125;</span><br><span class="line">        .launchIn(<span class="keyword">this</span>) <span class="comment">// &lt;--- Launching the flow in a separate coroutine</span></span><br><span class="line">    println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;            </span><br><span class="line"><span class="comment">//sampleEnd</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Done</span><br><span class="line">Event: <span class="number">1</span></span><br><span class="line">Event: <span class="number">2</span></span><br><span class="line">Event: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>launchIn 所需的参数用于指定启动用于收集流的协程的作用域。在上面的示例中，此作用域来自 runBlocking，因此当流运行时，runBlocking 作用域等待其子协程完成，并阻止主函数返回和终止此示例代码</p>
<p>在实际应用程序中，作用域将来自生命周期是有限的实体。一旦此实体的生命周期终止，相应的作用域将被取消，从而取消相应流的收集。onEach { … }.launchIn(scope) 的工作方式与 addEventListener 类似。但是，不需要相应的 removeEventListener 函数，因为 cancellation 和结构化并发可以达到这个目的</p>
<p>请注意，launchIn 还返回一个 Job 对象，该 Job 仅可用于取消相应的流数据收集协程，而不取消整个作用域或加入它</p>
<h1 id="十七、Flow-and-Reactive-Streams"><a href="#十七、Flow-and-Reactive-Streams" class="headerlink" title="十七、Flow and Reactive Streams"></a>十七、Flow and Reactive Streams</h1><p>For those who are familiar with Reactive Streams or reactive frameworks such as RxJava and project Reactor, design of the Flow may look very familiar.</p>
<p>Indeed, its design was inspired by Reactive Streams and its various implementations. But Flow main goal is to have as simple design as possible, be Kotlin and suspension friendly and respect structured concurrency. Achieving this goal would be impossible without reactive pioneers and their tremendous work. You can read the complete story in Reactive Streams and Kotlin Flows article.</p>
<p>While being different, conceptually, Flow is a reactive stream and it is possible to convert it to the reactive (spec and TCK compliant) Publisher and vice versa. Such converters are provided by kotlinx.coroutines out-of-the-box and can be found in corresponding reactive modules (kotlinx-coroutines-reactive for Reactive Streams, kotlinx-coroutines-reactor for Project Reactor and kotlinx-coroutines-rx2 for RxJava2). Integration modules include conversions from and to Flow, integration with Reactor’s Context and suspension-friendly ways to work with various reactive entities.</p>

  </article>
  <!-- tag -->
  <div class="mt-12 pt-6 border-t border-gray-200">
    
  </div>
  <!-- prev and next -->
  <div class="flex justify-between mt-12 pt-6 border-t border-gray-200">
    <div>
      
        <a href="/hexo-blog/public/2025/03/02/md/kotlin/Kotlin%20%E5%8D%8F%E7%A8%8B%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%882%EF%BC%89%E5%8F%96%E6%B6%88%E5%92%8C%E8%B6%85%E6%97%B6/" class="text-sm text-gray-400 hover:text-gray-500 flex justify-center">
          <iconify-icon width="20" icon="ri:arrow-left-s-line" data-inline="false"></iconify-icon>
          Kotlin 协程官方文档（2）取消和超时
        </a>
      
    </div>
    <div>
      
        <a href="/hexo-blog/public/2025/03/02/md/kotlin/Kotlin%20%E5%8D%8F%E7%A8%8B%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%884%EF%BC%89%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E8%B0%83%E5%BA%A6%E5%99%A8/" class="text-sm text-gray-400 hover:text-gray-500 flex justify-center">
          Kotlin 协程官方文档（4）协程上下文和调度器
          <iconify-icon width="20" icon="ri:arrow-right-s-line" data-inline="false"></iconify-icon>
        </a>
      
    </div>
  </div>
  <!-- comment -->
  <div class="article-comments mt-12">
    
<script
  src="https://giscus.app/client.js"
  data-repo="hqqich/giscus"
  data-repo-id="R_kgDOOCZUBA"
  data-category="General"
  data-category-id="DIC_kwDOOCZUBM4Cng1l"
  data-mapping="pathname"
  data-strict="0"
  data-reactions-enabled="1"
  data-emit-metadata="0"
  data-input-position="bottom"
  data-theme="preferred_color_scheme"
  data-lang="zh-CN"
  crossorigin="anonymous"
  async
></script>
<script>
  window.onload = function () {
    console.log("giscus loaded");
    const isDark = document.documentElement.classList.contains("dark");
    const giscusFrame = document.querySelector("iframe.giscus-frame");
    giscusFrame.contentWindow.postMessage(
      {
        giscus: {
          setConfig: {
            theme: isDark ? "dark" : "light",
          },
        },
      },
      "https://giscus.app"
    );
  };
</script>


  </div>
</section>
<!-- js inspect -->

<script src="/hexo-blog/public/lib/clipboard.min.js"></script>


<script async src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
  });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>



<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
  $(document).ready(() => {
    const maraidConfig = {
      theme: "default",
      logLevel: 3,
      flowchart: { curve: "linear" },
      gantt: { axisFormat: "%m/%d/%Y" },
      sequence: { actorMargin: 50 },
    };
    mermaid.initialize(maraidConfig);
  });
</script>



<script src="/hexo-blog/public/lib/fancybox/fancybox.umd.min.js"></script>

<script>
  $(document).ready(() => {
    $('.post-content').each(function(i){
      $(this).find('img').each(function(){
        if ($(this).parent().hasClass('fancybox') || $(this).parent().is('a')) return;
        var alt = this.alt;
        if (alt) $(this).after('<span class="fancybox-alt">' + alt + '</span>');
        $(this).wrap('<a class="fancybox-img" href="' + this.src + '" data-fancybox=\"gallery\" data-caption="' + alt + '"></a>')
      });
      $(this).find('.fancybox').each(function(){
        $(this).attr('rel', 'article' + i);
      });
    });

    Fancybox.bind('[data-fancybox="gallery"]', {
        // options
    })
  })
</script>

<!-- tocbot begin -->

<script src="/hexo-blog/public/lib/tocbot/tocbot.min.js"></script>

<script>
  $(document).ready(() => {
      tocbot.init({
        // Where to render the table of contents.
        tocSelector: '.post-toc',
        // Where to grab the headings to build the table of contents.
        contentSelector: '.post-content',
        // Which headings to grab inside of the contentSelector element.
        headingSelector: 'h1, h2, h3',
        // For headings inside relative or absolute positioned containers within content.
        hasInnerContainers: true,
    });
  })
</script>
<!-- tocbot end -->


  </main>
  <footer class="flex flex-col h-40 items-center justify-center text-gray-400 text-sm">
  <!-- busuanzi -->
  
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- Busuanzi Analytics -->
<div class="flex items-center gap-2">
  <span>Visitors</span>
  <span id="busuanzi_value_site_uv"></span>
  <span>Page Views</span>
  <span id="busuanzi_value_site_pv"></span>
</div>
<!-- End Busuanzi Analytics -->


  <!-- copyright -->
  <div class="flex items-center gap-2">
    <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" style="color: inherit;">CC BY-NC-SA 4.0</a>
    <span>© 2022</span>
    <iconify-icon width="18" icon="emojione-monotone:maple-leaf" ></iconify-icon>
    <a href="https://github.com/xbmlz" target="_blank" rel="noopener noreferrer">xbmlz</a>
  </div>
  <!-- powered by -->
  <div class="flex items-center gap-2">
    <span>Powered by</span>
    <a href="https://hexo.io/" target="_blank" rel="noopener noreferrer">Hexo</a>
    <span>&</span>
    <a href="https://github.com/xbmlz/hexo-theme-maple" target="_blank" rel="noopener noreferrer">Maple</a>
  </div>

</footer>

  <div class="back-to-top box-border fixed right-6 z-1024 -bottom-20 rounded py-1 px-1 bg-slate-900 opacity-60 text-white cursor-pointer text-center dark:bg-slate-600">
    <span class="flex justify-center items-center text-sm">
      <iconify-icon width="18" icon="ion:arrow-up-c" id="go-top"></iconify-icon>
      <span id="scrollpercent"><span>0</span> %</span>
    </span>
  </div>
  
<script src="/hexo-blog/public/js/main.js"></script>


  <script>
    $(document).ready(function () {
      const mapleCount = "10";
      const speed = "0.5";
      const mapleEl = document.getElementById("maple");
      const maples = Array.from({ length: mapleCount }).map(() => {
        const maple = document.createElement("div");
        const scale = Math.random() * 0.5 + 0.5;
        const offset = Math.random() * 2 - 1;
        const x = Math.random() * mapleEl.clientWidth;
        const y = -Math.random() * mapleEl.clientHeight;
        const duration = 10 / speed;
        const delay = -duration;
        maple.className = "maple";
        maple.style.width = `${24 * scale}px`;
        maple.style.height = `${24 * scale}px`;
        maple.style.left = `${x}px`;
        maple.style.top = `${y}px`;
        maple.style.setProperty("--maple-fall-offset", offset);
        maple.style.setProperty("--maple-fall-height", `${Math.abs(y) + mapleEl.clientHeight}px`);
        maple.style.animation = `fall ${duration}s linear infinite`;
        maple.style.animationDelay = `${delay}s`;
        mapleEl.appendChild(maple)
        return maple
      })
    });
  </script>
  


  <div class="fixed top-0 bottom-0 left-0 right-0 pointer-events-none print:hidden" id="maple"></div>
</body>

</html>

<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-EHXM4GYP5W"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-EHXM4GYP5W');
</script>
<!-- End Google Analytics -->



<!-- Baidu Analytics -->
<script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?0a6515fb9c839d6a56d4cfd8b7d243d4";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>
<!-- End Baidu Analytics -->


<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

  <meta name="author" content="hqqich">


  <meta name="subtitle" content="忙碌把时光缩短, 苦难把岁月拉长">




<title>两万六千字带你 Kotlin 入门 | Hexo-blog</title>



<link rel="icon" href="/hexo-blog/public/favicon.ico">



<link rel="stylesheet" href="/hexo-blog/public/css/main.css">


<link rel="stylesheet" href="/hexo-blog/public/lib/nprogress/nprogress.css">



<script src="/hexo-blog/public/lib/jquery.min.js"></script>


<script src="/hexo-blog/public/lib/iconify-icon.min.js"></script>


<script src="https://cdn.tailwindcss.com?plugins=typography"></script>
<script>
  tailwind.config = {
    darkMode: "class",
  };
</script>


<script src="/hexo-blog/public/lib/nprogress/nprogress.js"></script>

<script>
  $(document).ready(() => {
    NProgress.configure({
      showSpinner: false,
    });
    NProgress.start();
    $("#nprogress .bar").css({
      background: "#de7441",
    });
    $("#nprogress .peg").css({
      "box-shadow": "0 0 2px #de7441, 0 0 4px #de7441",
    });
    $("#nprogress .spinner-icon").css({
      "border-top-color": "#de7441",
      "border-left-color": "#de7441",
    });
    setTimeout(function () {
      NProgress.done();
      $(".fade").removeClass("out");
    }, 800);
  });
</script>

<script>
  (function () {
    const prefersDark =
      window.matchMedia &&
      window.matchMedia("(prefers-color-scheme: dark)").matches;
    const setting = localStorage.getItem("hexo-color-scheme") || "auto";
    if (setting === "dark" || (prefersDark && setting !== "light"))
      document.documentElement.classList.toggle("dark", true);
    let isDark = document.documentElement.classList.contains("dark");
  })();

  $(document).ready(function () {
    // init icon
    const prefersDark =
      window.matchMedia &&
      window.matchMedia("(prefers-color-scheme: dark)").matches;
    const isDark = document.documentElement.classList.contains("dark");
    $("#theme-icon").attr("icon", isDark ? "ri:moon-line" : "ri:sun-line");

    function toggleGiscusTheme() {
      const isDark = document.documentElement.classList.contains("dark");
      const giscusFrame = document.querySelector("iframe.giscus-frame");
      if (giscusFrame) {
        giscusFrame.contentWindow.postMessage(
          {
            giscus: {
              setConfig: {
                theme: isDark ? "dark" : "light",
              },
            },
          },
          "https://giscus.app"
        );
      }
    }

    // toggle dark mode
    function toggleDark() {
      let isDark = document.documentElement.classList.contains("dark");
      const setting = localStorage.getItem("hexo-color-scheme") || "auto";
      isDark = !isDark;
      document.documentElement.classList.toggle("dark", isDark);
      $("#theme-icon").attr("icon", isDark ? "ri:moon-line" : "ri:sun-line");
      if (prefersDark === isDark) {
        localStorage.setItem("hexo-color-scheme", "auto");
      } else {
        localStorage.setItem("hexo-color-scheme", isDark ? "dark" : "light");
      }
      toggleGiscusTheme();
    }

    // listen dark mode change
    window
      .matchMedia("(prefers-color-scheme: dark)")
      .addEventListener("change", (e) => {
        const setting = localStorage.getItem("hexo-color-scheme") || "auto";
        if (setting === "auto") {
          document.documentElement.classList.toggle("dark", e.matches);
          $("#theme-icon").attr(
            "icon",
            e.matches ? "ri:moon-line" : "ri:sun-line"
          );
          toggleGiscusTheme();
        }
      });

    $("#toggle-dark").click((event) => {
      const isAppearanceTransition = document.startViewTransition && !window.matchMedia('(prefers-reduced-motion: reduce)').matches
      if (!isAppearanceTransition) {
        toggleDark()
        return
      }
      const x = event.clientX
      const y = event.clientY
      const endRadius = Math.hypot(
        Math.max(x, innerWidth - x),
        Math.max(y, innerHeight - y),
      )
      const transition = document.startViewTransition(async () => {
        toggleDark()
      })

      transition.ready
        .then(() => {
          const isDark = document.documentElement.classList.contains("dark")
          const clipPath = [
            `circle(0px at ${x}px ${y}px)`,
            `circle(${endRadius}px at ${x}px ${y}px)`,
          ]
          document.documentElement.animate(
            {
              clipPath: isDark
                ? [...clipPath].reverse()
                : clipPath,
            },
            {
              duration: 400,
              easing: 'ease-out',
              pseudoElement: isDark
                ? '::view-transition-old(root)'
                : '::view-transition-new(root)',
            },
          )
        })
    });
  });
</script>




<meta name="generator" content="Hexo 7.3.0"></head>
<body class="font-sans bg-white dark:bg-zinc-900 text-gray-700 dark:text-gray-200 relative">
  <header class="fixed w-full px-5 py-1 z-10 backdrop-blur-xl backdrop-saturate-150 border-b border-black/5">
  <div class="max-auto">
    <nav class="flex items-center text-base">
      <a href="/hexo-blog/public/" class="group">
        <h2 class="font-medium tracking-tighterp text-l p-2">
          <img class="w-5 mr-2 inline-block transition-transform group-hover:rotate-[30deg]" id="logo" src="https://moe-counter-vercel-gamma.vercel.app/a?theme=rule34" alt="Hexo-blog" />
          Hexo-blog
        </h2>
      </a>
      <div id="header-title" class="opacity-0 md:ml-2 md:mt-[0.1rem] text-xs font-medium whitespace-nowrap overflow-hidden overflow-ellipsis">
        两万六千字带你 Kotlin 入门
      </div>
      <div class="flex-1"></div>
      <div class="flex items-center gap-3">
        
          <a class="hidden sm:flex" href="/hexo-blog/public/archives">Posts</a>
        
          <a class="hidden sm:flex" href="/hexo-blog/public/category">Categories</a>
        
          <a class="hidden sm:flex" href="/hexo-blog/public/tag">Tags</a>
        
        
          
            <a class="w-5 h-5 hidden sm:flex" title="Github" target="_blank" rel="noopener" href="https://github.com/hqqich">
              <iconify-icon width="20" icon="ri:github-line"></iconify-icon>
            </a>
          
        
        <a class="w-5 h-5 hidden sm:flex" title="Github" href="rss2.xml">
          <iconify-icon width="20" icon="ri:rss-line"></iconify-icon>
        </a>
        <a class="w-5 h-5" title="toggle theme" id="toggle-dark">
          <iconify-icon width="20" icon="" id="theme-icon"></iconify-icon>
        </a>
      </div>
      <div class="flex items-center justify-center gap-3 ml-3 sm:hidden">
        <span class="w-5 h-5" aria-hidden="true" role="img" id="open-menu">
          <iconify-icon width="20" icon="carbon:menu" ></iconify-icon>
        </span>
        <span class="w-5 h-5 hidden" aria-hidden="true" role="img" id="close-menu">
          <iconify-icon  width="20" icon="carbon:close" ></iconify-icon>
        </span>
      </div>
    </nav>
  </div>
</header>
<div id="menu-panel" class="h-0 overflow-hidden sm:hidden fixed left-0 right-0 top-12 bottom-0 z-10">
  <div id="menu-content" class="relative z-20 bg-white/80 px-6 sm:px-8 py-2 backdrop-blur-xl -translate-y-full transition-transform duration-300">
    <ul class="nav flex flex-col sm:flex-row text-sm font-medium">
      
        <li class="nav-portfolio sm:mx-2 border-b sm:border-0 border-black/5 last:border-0 hover:text-main">
          <a href="/hexo-blog/public/archives" class="flex h-12 sm:h-auto items-center">Posts</a>
        </li>
      
        <li class="nav-portfolio sm:mx-2 border-b sm:border-0 border-black/5 last:border-0 hover:text-main">
          <a href="/hexo-blog/public/category" class="flex h-12 sm:h-auto items-center">Categories</a>
        </li>
      
        <li class="nav-portfolio sm:mx-2 border-b sm:border-0 border-black/5 last:border-0 hover:text-main">
          <a href="/hexo-blog/public/tag" class="flex h-12 sm:h-auto items-center">Tags</a>
        </li>
      
    </ul>
  </div>
  <div class="mask bg-black/20 absolute inset-0"></div>
</div>

  <main class="pt-14">
    <!-- css -->

<link rel="stylesheet" href="/hexo-blog/public/lib/fancybox/fancybox.min.css">


<link rel="stylesheet" href="/hexo-blog/public/lib/tocbot/tocbot.min.css">

<!-- toc -->

  <!-- tocbot -->
<nav class="post-toc toc text-sm w-48 relative top-32 right-0 opacity-70 hidden lg:block" style="position: fixed !important;"></nav>


<section class="px-6 max-w-prose mx-auto md:px-0">
  <!-- header -->
  <header class="overflow-hidden pt-6 pb-6 md:pt-12">
    <div class="pt-4 md:pt-6">
      <h1 id="article-title" class="text-[2rem] font-bold leading-snug mb-4 md:mb-6 md:text-[2.6rem]">
        两万六千字带你 Kotlin 入门
      </h1>
      <div>
        <section class="flex items-center gap-3 text-sm">
          <span class="flex items-center gap-1">
            <iconify-icon width="18" icon="carbon-calendar" ></iconify-icon>
            <time>2025-03-02</time>
          </span>
          <span class="text-gray-400">·</span>
          <span class="flex items-center gap-1">
            <iconify-icon width="18" icon="ic:round-access-alarm" ></iconify-icon>
            <span>120 min</span>
          </span>
          <span class="text-gray-400">·</span>
          <span class="flex items-center gap-1">
            <iconify-icon width="18" icon="icon-park-outline:font-search" ></iconify-icon>
            <span>27.6k words</span>
          </span>
          
            <span class="text-gray-400">·</span>
            <span class="flex items-center gap-1">
              <iconify-icon width="16" icon="icon-park-outline:box" class="mr-2"></iconify-icon>
              <a class="article-category-link" href="/hexo-blog/public/categories/kotlin/">kotlin</a>
            </span>
          
        </section>
      </div>
    </div>
  </header>
  <!-- content -->
  <article class="post-content prose m-auto slide-enter-content dark:prose-invert">
    <blockquote>
<p>公众号：<a target="_blank" rel="noopener" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adbc507fc3704fd8955aae739a433db2~tplv-k3u1fbpfcp-zoom-1.image">字节数组</a></p>
<p>希望对你有所帮助 🤣🤣</p>
</blockquote>
<p>开头先说一下，我不是标题党，本教程真的有两万六千字，以前我也曾写过 Kotlin 的入门教程，但由于隔得比较久了，所以就对原有教程进行了修正，并且补充了 Kotlin 新版本的一些新特性，希望对你有所帮助 🤣🤣</p>
<h1 id="一、Hello-World"><a href="#一、Hello-World" class="headerlink" title="一、Hello World"></a>一、Hello World</h1><p>按照国际惯例，学习一门新的语言通常都是要从打印 Hello World 开始的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> msg: String = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">    println(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个简单的函数就可以列出 kotlin 和 Java 的几个不同点</p>
<ol>
<li>函数可以定义在文件的最外层，不需要把它放在类中</li>
<li>用关键字 <strong>fun</strong> 来声明一个函数</li>
<li>可以省略 <code>main</code> 方法的参数</li>
<li>参数类型写在变量名之后，这有助于在类型自动推导时省略类型声明</li>
<li>使用 <code>println</code> 代替了 <code>System.out.println</code> ，这是 kotlin 标准库提供的对 Java 标准库函数的简易封装</li>
<li>可以省略代码结尾的分号</li>
</ol>
<h1 id="二、Package"><a href="#二、Package" class="headerlink" title="二、Package"></a>二、Package</h1><p>kotlin 文件都以 <strong>package</strong> 开头，同个文件中定义的所有声明（类、函数和属性）都会被放到这个包中。同个包中的声明可以直接使用，不同包的声明需要导入后使用</p>
<p>包的声明要放在文件顶部，import 语句紧随其后</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> base</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat</span><br><span class="line"><span class="keyword">import</span> java.util.*</span><br></pre></td></tr></table></figure>

<p>kotlin 不区分导入的是类还是函数，可以使用 <code>import</code> 关键字导入任何种类的声明。此外也可以在包名称后加上 <strong>.</strong>* 来导入包中定义的所有声明，从而让包中定义的类、顶层函数、和属性都可以直接引用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn.package2</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> index = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Test</span><span class="params">(status: <span class="type">Boolean</span>)</span></span> = println(status)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> isEquals1: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> x == y</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> isEquals2</span><br><span class="line">        <span class="keyword">get</span>() = x == y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> isEquals3 = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">get</span>() = x &gt; y</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = !value</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn.package1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> learn.package2.Point</span><br><span class="line"><span class="keyword">import</span> learn.package2.Test</span><br><span class="line"><span class="keyword">import</span> learn.package2.index</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> point = Point(<span class="number">10</span>, index)</span><br><span class="line">    Test(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 语言规定类要放到和包结构<strong>匹配</strong>的文件夹目录结构中，且文件名必须和类名相同。而 kotlin 允许把多个类放到同一个文件中，文件名也可以任意选择。kotlin 也没有文件夹目录施加任何限制，包层级结构不需要遵循同样的目录层级结构 ,但 kotlin 官方还是建议根据包声明把源码文件放到相应的目录中</p>
<p>如果包名出现命名冲突，可以使用  <strong>as  关键字</strong>在本地重命名冲突项来消歧义</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> learn.package1.Point</span><br><span class="line"><span class="keyword">import</span> learn.package2.Point <span class="keyword">as</span> PointTemp <span class="comment">//PointTemp 可以用来表示 learn.package2.Point 了</span></span><br></pre></td></tr></table></figure>

<p>kotlin 中也有一个类似的概念可以用来重命名现有类型，叫做类型别名。类型别名用于为现有类型提供一个替代名称，如果类型名称比较长，就可以通过引入一个较短或者更为简略的名称来方便记忆</p>
<p>类型别名不会引入新的类型，依然对应其底层类型，所以在下述代码中输出的 class 类型是一致的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> BaseInner = Base.InnerClass</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> baseInner1 = Base.InnerClass()</span><br><span class="line">    <span class="keyword">val</span> baseInner2 = BaseInner()</span><br><span class="line">    println(baseInner1.javaClass) <span class="comment">//class test2.Base$InnerClass</span></span><br><span class="line">    println(baseInner2.javaClass) <span class="comment">//class test2.Base$InnerClass</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、变量与数据类型"><a href="#三、变量与数据类型" class="headerlink" title="三、变量与数据类型"></a>三、变量与数据类型</h1><p>在 Java 中，大部分的变量是可变的（非 final 的），意味着任何可以访问到这个变量的代码都可以去修改它。而在 kotlin 中，变量可以分为 <strong>可变变量(var)</strong> 和 <strong>不可变变量(val)</strong> 两类</p>
<p>声明变量的关键字有两个：</p>
<ul>
<li>val（value &#x2F;  varible+final）——不可变引用。使用 val 声明的变量不能在初始化之后再次赋值，对应的是 Java 中的 final 变量</li>
<li>var（variable）——可变引用。var 变量的值可以被改变，对应的是 Java 中的非 final 变量</li>
</ul>
<p>不可变变量在赋值之后就不能再去改变它的状态了，因此不可变变量可以说是线程安全的，因为它们无法改变，所有线程访问到的对象都是同一个，因此也不需要去做访问控制。开发者应当尽可能地使用不可变变量，这样可以让代码更加接近函数式编程风格</p>
<p>编程领域也推崇一种开发原则：尽可能使用 val，不可变对象及纯函数来设计程序。这样可以尽量避免副作用带来的影响</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//只读变量即赋值后不可以改变值的变量，用 val 声明</span></span><br><span class="line">    <span class="comment">//声明一个整数类型的不可变变量</span></span><br><span class="line">    <span class="keyword">val</span> intValue: <span class="built_in">Int</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明一个双精度类型的可变变量</span></span><br><span class="line">    <span class="keyword">var</span> doubleValue: <span class="built_in">Double</span> = <span class="number">100.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在声明变量时我们通常不需要显式指明变量的类型，这可以由编译器根据上下文自动推导出来。如果只读变量在声明时没有初始的默认值，则必须指明变量类型，且在使用前必须确保在各个分支条件下变量可以被初始化，否则编译器就会报异常</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> intValue = <span class="number">1002222222222</span></span><br><span class="line">    <span class="keyword">val</span> doubleValue = <span class="number">100.0</span></span><br><span class="line">    <span class="keyword">val</span> longValue = <span class="number">100L</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果只读变量在声明时没有初始值，则必须指明变量类型</span></span><br><span class="line">    <span class="keyword">val</span> intValue2: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        intValue2 = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(intValue2) <span class="comment">//error， Variable &#x27;intValue2&#x27; must be initialized</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1、基本数据类型"><a href="#1、基本数据类型" class="headerlink" title="1、基本数据类型"></a>1、基本数据类型</h2><p>与 Java 不同，kotlin 并不区分基本数据类型和它的包装类，在 kotlin 中一切都是对象，可以在任何变量上调用其成员函数和属性。kotlin 没有像 Java 中那样的原始基本类型，但 <strong>byte、char、integer、float 或者 boolean</strong> 等类型仍然有保留，但是全部都作为对象存在</p>
<p>对于基本类型，kotlin 相比 Java 有几点特殊的地方</p>
<ul>
<li>数字、字符和布尔值可以在运行时表示为原生类型值，但对开发者来说，它们看起来就像普通的类</li>
<li>对于数字<strong>没有隐式拓宽转换</strong>，而在 Java 中 int 可以隐式转换为 long</li>
<li>所有未超出 Int 最⼤值的整型值初始化的变量都会自动推断为 Int 类型，如果初始值超过了其最⼤值，则会推断为 Long 类型， 如需显式指定 Long 类型值可在该值后追加 L 后缀</li>
<li>字符不能视为数字</li>
<li>不支持八进制</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 kotlin 中，int、long、float 等类型仍然存在，但是是作为对象存在的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> intIndex: <span class="built_in">Int</span> = <span class="number">100</span></span><br><span class="line"><span class="comment">//等价于，编译器会自动进行类型推导</span></span><br><span class="line"><span class="keyword">val</span> intIndex = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数字类型不会自动转型，必须要进行明确的类型转换</span></span><br><span class="line"><span class="keyword">val</span> doubleIndex: <span class="built_in">Double</span> = intIndex.toDouble()</span><br><span class="line"><span class="comment">//以下代码会提示错误，需要进行明确的类型转换</span></span><br><span class="line"><span class="comment">//val doubleIndex: Double = intIndex</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> intValue: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> longValue: <span class="built_in">Long</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">//以下代码会提示错误，因为两者的数据类型不一致，需要转换为同一类型后才能进行比较</span></span><br><span class="line"><span class="comment">//println(intValue == longValue)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Char 不能直接作为数字来处理，需要主动转换</span></span><br><span class="line"><span class="keyword">val</span> ch: <span class="built_in">Char</span> = <span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="keyword">val</span> charValue: <span class="built_in">Int</span> = ch.toInt()</span><br><span class="line"><span class="comment">//以下代码会提示错误</span></span><br><span class="line"><span class="comment">//val charValue: Int = ch</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制</span></span><br><span class="line"><span class="keyword">val</span> value1 = <span class="number">0b00101</span></span><br><span class="line"><span class="comment">//十六进制</span></span><br><span class="line"><span class="keyword">val</span> value2 = <span class="number">0x123</span></span><br></pre></td></tr></table></figure>

<p>此外，kotlin 的可空类型不能用 Java 的基本数据类型表示，因为 null 只能被存储在 Java 的引用类型的变量中，这意味着只要使用了基本数据类型的可空版本，它就会被编译成对应的包装类型</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本数据类型</span></span><br><span class="line"><span class="keyword">val</span> intValue_1: <span class="built_in">Int</span> = <span class="number">200</span></span><br><span class="line"><span class="comment">//包装类</span></span><br><span class="line"><span class="keyword">val</span> intValue_2: <span class="built_in">Int</span>? = intValue_1</span><br><span class="line"><span class="keyword">val</span> intValue_3: <span class="built_in">Int</span>? = intValue_1</span><br><span class="line"><span class="comment">//== 比较的是数值相等性，因此结果是 true</span></span><br><span class="line">println(intValue_2 == intValue_3)</span><br><span class="line"><span class="comment">//=== 比较的是引用是否相等，因此结果是 false</span></span><br><span class="line">println(intValue_2 === intValue_3)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果 intValue_1 的值是100，就会发现 intValue_2 &#x3D;&#x3D;&#x3D; intValue_3 的比较结果是 true，这就涉及到 Java 对包装类对象的复用问题了</p>
</blockquote>
<h2 id="2、字符串"><a href="#2、字符串" class="headerlink" title="2、字符串"></a>2、字符串</h2><p>kotlin 与 Java 一样用  String  类型来表示字符串，字符串是不可变的，可以使用索引运算符访问<code>[]</code> 来访问包含的单个字符，也可以用  for  循环来迭代字符串，此外也可以用 + 来连接字符串</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str = <span class="string">&quot;leavesCZY&quot;</span></span><br><span class="line">println(str[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">for</span> (c <span class="keyword">in</span> str) &#123;</span><br><span class="line">    println(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> str1 = str + <span class="string">&quot; hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>kotlin 支持在字符串字面值中引用局部变量，只需要在变量名前加上字符 $ 即可，此外还可以包含用花括号括起来的表达式，此时会自动求值并把结果合并到字符串中</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intValue = <span class="number">100</span></span><br><span class="line"><span class="comment">//可以直接包含变量</span></span><br><span class="line">println(<span class="string">&quot;intValue value is <span class="variable">$intValue</span>&quot;</span>) <span class="comment">//intValue value is 100</span></span><br><span class="line"><span class="comment">//也可以包含表达式</span></span><br><span class="line">println(<span class="string">&quot;(intValue + 100) value is <span class="subst">$&#123;intValue + <span class="number">100</span>&#125;</span>&quot;</span>)   <span class="comment">//(intValue + 100) value is 200</span></span><br></pre></td></tr></table></figure>

<p>如果你需要在原始字符串中表示字面值（$）字符（它不支持反斜杠转义），可以用下列语法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> price = <span class="string">&quot;<span class="subst">$&#123;<span class="string">&#x27;$&#x27;</span>&#125;</span>100.99&quot;</span></span><br><span class="line">println(price)  <span class="comment">//$100.99</span></span><br></pre></td></tr></table></figure>

<h2 id="3、数组"><a href="#3、数组" class="headerlink" title="3、数组"></a>3、数组</h2><p>kotlin 中的数组是带有类型参数的类，其元素类型被指定为相应的类型参数，使用  Array  类来表示，  Array  类定义了  get  与  set  函数（按照运算符重载约定这会转变为  [ ]  ）以及  size  属性等</p>
<p>创建数组的方法有以下几种：</p>
<ol>
<li>用 arrayOf 函数创建一个数组，包含的元素是指定为该函数的实参</li>
<li>用 arrayOfNulls 创建一个给定大小的数组，包含的元素均为 null，只能用来创建包含元素类型可空的数组</li>
<li>调用 Array 类的构造方法，传递数组的大小和一个 lambda 表达式，调用 lambda 表达式来创建每一个数组元素</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包含给定元素的字符串数组</span></span><br><span class="line"><span class="keyword">val</span> array1 = arrayOf(<span class="string">&quot;leavesCZY&quot;</span>, <span class="string">&quot;叶&quot;</span>, <span class="string">&quot;https://github.com/leavesCZY&quot;</span>)</span><br><span class="line"></span><br><span class="line">array1[<span class="number">0</span>] = <span class="string">&quot;leavesCZY&quot;</span></span><br><span class="line">println(array1[<span class="number">1</span>])</span><br><span class="line">println(array1.size)</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始元素均为 null ，大小为 10 的字符数组</span></span><br><span class="line"><span class="keyword">val</span> array2 = arrayOfNulls&lt;String&gt;(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建从 “a” 到 “z” 的字符串数组</span></span><br><span class="line"><span class="keyword">val</span> array3 = Array(<span class="number">26</span>) &#123; i -&gt; (<span class="string">&#x27;a&#x27;</span> + i).toString() &#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，数组类型的类型参数始终会变成对象类型，因此声明 <strong>Array&lt; Int &gt;</strong> 将是一个包含装箱类型（java.lang.Integer）的数组。如果想要创建没有装箱的基本数据类型的数组，必须使用一个基本数据类型数组的特殊类</p>
<p>为了表示基本数据类型的数组，kotlin 为每一种基本数据类型都提供了若干相应的类并做了特殊的优化。例如，有 <strong>IntArray、ByteArray、BooleanArray</strong> 等类型，这些类型都会被编译成普通的 Java 基本数据类型数组，比如 <strong>int[]、byte[]、boolean[]</strong> 等，这些数组中的值存储时没有进行装箱，而是使用了可能的最高效的方式。需要注意，IntArray 等并不是 Array 的子类</p>
<p>要创建一个基本数据类型的数组，有以下几种方式：</p>
<ol>
<li>向对应类型的类（如 IntArray）的构造函数传递数组大小，这将返回一个使用对应基本数据类型默认值初始化好的数组</li>
<li>向对应类型的类（如 IntArray）的构造函数传递数组大小以及用来初始化每个元素的 lambda</li>
<li>向工厂函数（如 charArrayOf）传递变长参数的值，从而得到指定元素值的数组</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定数组大小，包含的元素将是对应基本数据类型的默认值(int 的默认值是 0)</span></span><br><span class="line"><span class="keyword">val</span> intArray = IntArray(<span class="number">5</span>)</span><br><span class="line"><span class="comment">//指定数组大小以及用于初始化每个元素的 lambda</span></span><br><span class="line"><span class="keyword">val</span> doubleArray = DoubleArray(<span class="number">5</span>) &#123; Random().nextDouble() &#125;</span><br><span class="line"><span class="comment">//接收变长参数的值来创建存储这些值的数组</span></span><br><span class="line"><span class="keyword">val</span> charArray = charArrayOf(<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="4、Any-和-Any"><a href="#4、Any-和-Any" class="headerlink" title="4、Any 和 Any?"></a>4、Any 和 Any?</h2><p>Any 类型是 kotlin 所有非空类型的超类型，包括像 Int 这样的基本数据类型</p>
<p>如果把基本数据类型的值赋给 Any 类型的变量，则会自动装箱</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> any: Any = <span class="number">100</span></span><br><span class="line">println(any.javaClass) <span class="comment">//class java.lang.Integer</span></span><br></pre></td></tr></table></figure>

<p>如果想要使变量可以存储包括 null 在内的所有可能的值，则需要使用 Any?</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> any: Any? = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h2 id="5、Unit"><a href="#5、Unit" class="headerlink" title="5、Unit"></a>5、Unit</h2><p>kotlin 中的 Unit 类型类似于 Java 中的 void，可以用于函数没有返回值时的情况</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">()</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果返回值为 Unit，则可以省略该声明</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Unit 是一个完备的类型，可以作为类型参数，但 void 不行</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Test</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoResultClass</span> : <span class="type">Test</span>&lt;<span class="type">Unit</span>&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回 Unit，但可以省略类型说明，函数也不需要显式地 return </span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、Nothing"><a href="#6、Nothing" class="headerlink" title="6、Nothing"></a>6、Nothing</h2><p>Nothing 类型没有任何值，只有被当做函数返回值使用，或者被当做泛型函数返回值的类型参数使用时才会有意义，可以用 Nothing 来表示一个函数不会被正常终止，从而帮助编译器对代码进行诊断</p>
<p>编译器知道返回值为 Nothing 类型的函数从不会正常终止，所以编译器会把 name1 的类型推断为非空，因为 name1 在为 null 时的分支处理会始终抛出异常</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> name: String?)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fail</span><span class="params">(message: <span class="type">String</span>)</span></span>: <span class="built_in">Nothing</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> IllegalStateException(message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = User(<span class="string">&quot;leavesC&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> name = user.name ?: fail(<span class="string">&quot;no name&quot;</span>)</span><br><span class="line">    println(name) <span class="comment">//leavesC</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> user1 = User(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">val</span> name1 = user1.name ?: fail(<span class="string">&quot;no name&quot;</span>)</span><br><span class="line">    println(name1.length) <span class="comment">//IllegalStateException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、函数"><a href="#四、函数" class="headerlink" title="四、函数"></a>四、函数</h1><p>kotlin 中的函数以关键字 fun 作为开头，函数名称紧随其后，再之后是用括号包裹起来的参数列表，如果函数有返回值，则再加上返回值类型，用一个冒号与参数列表隔开</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fun 用于表示声明一个函数，getNameLastChar 是函数名</span></span><br><span class="line"><span class="comment">//空括号表示该函数无传入参数，Char 表示函数的返回值类型是字符</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getNameLastChar</span><span class="params">()</span></span>: <span class="built_in">Char</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name.<span class="keyword">get</span>(name.length - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带有两个不同类型的参数，一个是 String 类型，一个是 Int 类型</span></span><br><span class="line"><span class="comment">//返回值为 Int 类型</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test1</span><span class="params">(str: <span class="type">String</span>, int: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> str.length + int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，表达式函数体的返回值类型可以省略，返回值类型可以自动推断，这种用单行表达式与等号定义的函数叫做<strong>表达式函数体</strong>。但对于一般情况下的有返回值的<strong>代码块函数体</strong>，<strong>必须显式地</strong>写出返回类型和 return 语句</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getNameLastChar 函数的返回值类型以及 return 关键字是可以省略的</span></span><br><span class="line"><span class="comment">//返回值类型可以由编译器根据上下文进行推导</span></span><br><span class="line"><span class="comment">//因此，函数可以简写为以下形式</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getNameLastChar</span><span class="params">()</span></span> = name.<span class="keyword">get</span>(name.length - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>如果函数没有有意义的返回值，则可以声明为 Unit ，也可以省略 Unit</p>
<p>以下三种写法都是等价的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(str: <span class="type">String</span>, int: <span class="type">Int</span>)</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    println(str.length + int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(str: <span class="type">String</span>, int: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    println(str.length + int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(str: <span class="type">String</span>, int: <span class="type">Int</span>)</span></span> = println(str.length + int)</span><br></pre></td></tr></table></figure>

<h2 id="1、命名参数"><a href="#1、命名参数" class="headerlink" title="1、命名参数"></a>1、命名参数</h2><p>为了增强代码的可读性，kotlin 允许我们使用命名参数，即在调用某函数的时候，可以将函数参数名一起标明，从而明确地表达该参数的含义与作用，但是在指定了一个参数的名称后，之后的所有参数都需要标明名称</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//错误，在指定了一个参数的名称后，之后的所有参数都需要标明名称</span></span><br><span class="line">    <span class="comment">//compute(index = 110, &quot;leavesC&quot;)</span></span><br><span class="line">    compute(index = <span class="number">120</span>, value = <span class="string">&quot;leavesC&quot;</span>)</span><br><span class="line">    compute(<span class="number">130</span>, value = <span class="string">&quot;leavesC&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compute</span><span class="params">(index: <span class="type">Int</span>, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、默认参数值"><a href="#2、默认参数值" class="headerlink" title="2、默认参数值"></a>2、默认参数值</h2><p>可以在声明函数的时候指定参数的默认值，从而避免创建重载的函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    compute(<span class="number">24</span>)</span><br><span class="line">    compute(<span class="number">24</span>, <span class="string">&quot;leavesC&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compute</span><span class="params">(age: <span class="type">Int</span>, name: <span class="type">String</span> = <span class="string">&quot;leavesC&quot;</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于以上这个例子，如果按照常规的调用语法时，必须按照函数声明定义的参数顺序来给定参数，可以省略的只有排在末尾的参数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//错误，不能省略参数 name</span></span><br><span class="line">    <span class="comment">// compute(24)</span></span><br><span class="line">    <span class="comment">// compute(24,100)</span></span><br><span class="line">    <span class="comment">//可以省略参数 value</span></span><br><span class="line">    compute(<span class="string">&quot;leavesC&quot;</span>, <span class="number">24</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compute</span><span class="params">(name: <span class="type">String</span> = <span class="string">&quot;leavesC&quot;</span>, age: <span class="type">Int</span>, value: <span class="type">Int</span> = <span class="number">100</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用命名参数，可以省略任何有默认值的参数，而且也可以按照任意顺序传入需要的参数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    compute(age = <span class="number">24</span>)</span><br><span class="line">    compute(age = <span class="number">24</span>, name = <span class="string">&quot;leavesC&quot;</span>)</span><br><span class="line">    compute(age = <span class="number">24</span>, value = <span class="number">90</span>, name = <span class="string">&quot;leavesC&quot;</span>)</span><br><span class="line">    compute(value = <span class="number">90</span>, age = <span class="number">24</span>, name = <span class="string">&quot;leavesC&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compute</span><span class="params">(name: <span class="type">String</span> = <span class="string">&quot;leavesC&quot;</span>, age: <span class="type">Int</span>, value: <span class="type">Int</span> = <span class="number">100</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、可变参数"><a href="#3、可变参数" class="headerlink" title="3、可变参数"></a>3、可变参数</h2><p>可变参数可以让我们把任意个数的参数打包到数组中传给函数，kotlin 的语法相比 Java 有所不同，改为通过使用 vararg 关键字声明可变参数</p>
<p>例如，以下的几种函数调用方式都是正确的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    compute()</span><br><span class="line">    compute(<span class="string">&quot;leavesC&quot;</span>)</span><br><span class="line">    compute(<span class="string">&quot;leavesC&quot;</span>, <span class="string">&quot;leavesc&quot;</span>)</span><br><span class="line">    compute(<span class="string">&quot;leavesC&quot;</span>, <span class="string">&quot;leavesc&quot;</span>, <span class="string">&quot;叶&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compute</span><span class="params">(<span class="keyword">vararg</span> name: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    name.forEach &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 中，可以直接将数组传递给可变参数，而 kotlin 要求显式地解包数组，以便每个数组元素在函数中能够作为单独的参数来调用，这个功能被称为展开运算符，使用方式就是在数组参数前加一个 *</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> names = arrayOf(<span class="string">&quot;leavesC&quot;</span>, <span class="string">&quot;leavesc&quot;</span>, <span class="string">&quot;叶&quot;</span>)</span><br><span class="line">    compute(* names)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compute</span><span class="params">(<span class="keyword">vararg</span> name: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    name.forEach &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、局部函数"><a href="#4、局部函数" class="headerlink" title="4、局部函数"></a>4、局部函数</h2><p>kotlin 支持在函数中嵌套函数，被嵌套的函数称为局部函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    compute(<span class="string">&quot;leavesC&quot;</span>, <span class="string">&quot;country&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compute</span><span class="params">(name: <span class="type">String</span>, country: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(string: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (string.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;参数错误&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    check(name)</span><br><span class="line">    check(country)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、表达式和条件循环"><a href="#五、表达式和条件循环" class="headerlink" title="五、表达式和条件循环"></a>五、表达式和条件循环</h1><h2 id="1、语句和表达式"><a href="#1、语句和表达式" class="headerlink" title="1、语句和表达式"></a>1、语句和表达式</h2><p>这里需要先区分“语句”和“表达式”这两个概念。语句是可以单独执行，能够产生实际效果的代码，表现为赋值逻辑、打印操作、流程控制等形式，Java 中的流程控制（if，while，for）等都是语句。表达式可以是一个值、变量、常量、操作符、或它们之间的组合，表达式可以看做是包含返回值的语句</p>
<p>例如，以下的赋值操作、流程控制、打印输出都是语句，其是作为一个整体存在的，且不包含返回值</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.a step <span class="number">2</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看几个表达式的例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>       <span class="comment">//字面表达式，返回 1</span></span><br><span class="line"></span><br><span class="line">++<span class="number">1</span>     <span class="comment">//也属于表达式，自增会返回 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//与 Java 不同，kotlin 中的 if 是作为表达式存在的，其可以拥有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getLength</span><span class="params">(str: <span class="type">String</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (str.isNullOrBlank()) <span class="number">0</span> <span class="keyword">else</span> str.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、If-表达式"><a href="#2、If-表达式" class="headerlink" title="2、If 表达式"></a>2、If 表达式</h2><p>if 的分支可以是代码块，最后的表达式作为该块的返回值</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> maxValue = <span class="keyword">if</span> (<span class="number">20</span> &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    println(<span class="string">&quot;maxValue is 20&quot;</span>)</span><br><span class="line">    <span class="number">20</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;maxValue is 10&quot;</span>)</span><br><span class="line">    <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">println(maxValue) <span class="comment">//20</span></span><br></pre></td></tr></table></figure>

<p>以下代码可以显示地看出 if 的返回值，完全可以用来替代 Java 中的<strong>三元运算符</strong>，因此 kotlin 并没有<strong>三元运算符</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">30</span>)</span><br><span class="line"><span class="keyword">val</span> value = <span class="keyword">if</span> (list.size &gt; <span class="number">0</span>) list.size <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">println(value)  <span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<p>如果 if 表达式分支是用于执行某个命令，那么此时的返回值类型就是 Unit ，此时的 if 语句就看起来和 Java 的一样了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> value1 = <span class="keyword">if</span> (list.size &gt; <span class="number">0</span>) println(<span class="string">&quot;1&quot;</span>) <span class="keyword">else</span> println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">println(value1.javaClass)   <span class="comment">//class kotlin.Unit</span></span><br></pre></td></tr></table></figure>

<p>如果将 if 作为表达式而不是语句（例如：返回它的值或者把它赋给变量），该表达式需要有 else 分支</p>
<h2 id="3、when-表达式"><a href="#3、when-表达式" class="headerlink" title="3、when 表达式"></a>3、when 表达式</h2><p>when 表达式与 Java 中的 <strong>switch&#x2F;case</strong> 类似，但是要强大得多。when 既可以被当做表达式使用也可以被当做语句使用，when 将参数和所有的分支条件顺序比较直到某个分支满足条件，然后它会运行右边的表达式。如果 when 被当做表达式来使用，符合条件的分支的值就是整个表达式的值，如果当做语句使用， 则忽略个别分支的值。与 Java 的 switch&#x2F;case 不同之处是 when 表达式的参数可以是任何类型，并且分支也可以是一个条件</p>
<p>和 if 一样，when 表达式每一个分支可以是一个代码块，它的值是代码块中最后的表达式的值，如果其它分支都不满足条件将会求值于 else 分支</p>
<p>如果 when 作为一个表达式使用，则必须有 else 分支， 除非编译器能够检测出所有的可能情况都已经覆盖了。如果很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> value = <span class="number">2</span></span><br><span class="line"><span class="keyword">when</span> (value) &#123;</span><br><span class="line">    <span class="keyword">in</span> <span class="number">4.</span><span class="number">.9</span> -&gt; println(<span class="string">&quot;in 4..9&quot;</span>) <span class="comment">//区间判断</span></span><br><span class="line">    <span class="number">3</span> -&gt; println(<span class="string">&quot;value is 3&quot;</span>)    <span class="comment">//相等性判断</span></span><br><span class="line">    <span class="number">2</span>, <span class="number">6</span> -&gt; println(<span class="string">&quot;value is 2 or 6&quot;</span>)    <span class="comment">//多值相等性判断</span></span><br><span class="line">    <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; println(<span class="string">&quot;is Int&quot;</span>)   <span class="comment">//类型判断</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; println(<span class="string">&quot;else&quot;</span>)       <span class="comment">//如果以上条件都不满足，则执行 else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//返回 when 表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">parser</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: String =</span><br><span class="line">            <span class="keyword">when</span> (obj) &#123;</span><br><span class="line">                <span class="number">1</span> -&gt; <span class="string">&quot;value is 1&quot;</span></span><br><span class="line">                <span class="string">&quot;4&quot;</span> -&gt; <span class="string">&quot;value is string 4&quot;</span></span><br><span class="line">                <span class="keyword">is</span> <span class="built_in">Long</span> -&gt; <span class="string">&quot;value type is long&quot;</span></span><br><span class="line">                <span class="keyword">else</span> -&gt; <span class="string">&quot;unknown&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">    println(parser(<span class="number">1</span>))</span><br><span class="line">    println(parser(<span class="number">1L</span>))</span><br><span class="line">    println(parser(<span class="string">&quot;4&quot;</span>))</span><br><span class="line">    println(parser(<span class="number">100L</span>))</span><br><span class="line">    println(parser(<span class="number">100.0</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">value <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line">value type <span class="keyword">is</span> long</span><br><span class="line">value <span class="keyword">is</span> string <span class="number">4</span></span><br><span class="line">value type <span class="keyword">is</span> long</span><br><span class="line">unknown</span><br></pre></td></tr></table></figure>

<p>此外，when 语句也可以不带参数来使用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> &#123;</span><br><span class="line">    <span class="number">1</span> &gt; <span class="number">5</span> -&gt; println(<span class="string">&quot;1 &gt; 5&quot;</span>)</span><br><span class="line">    <span class="number">3</span> &gt; <span class="number">1</span> -&gt; println(<span class="string">&quot;3 &gt; 1&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、for-循环"><a href="#4、for-循环" class="headerlink" title="4、for 循环"></a>4、for 循环</h2><p>和 Java 中的 for 循环最为类似的形式是</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">34</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> (value <span class="keyword">in</span> list) &#123;</span><br><span class="line">    println(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过索引来遍历</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> items = listOf(<span class="string">&quot;H&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;o&quot;</span>)</span><br><span class="line"><span class="comment">//通过索引来遍历List</span></span><br><span class="line"><span class="keyword">for</span> (index <span class="keyword">in</span> items.indices) &#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;index&#125;</span>对应的值是：<span class="subst">$&#123;items[index]&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以在每次循环中获取当前索引和相应的值</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">34</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> ((index, value) <span class="keyword">in</span> list.withIndex()) &#123;</span><br><span class="line">    println(<span class="string">&quot;index : <span class="variable">$index</span> , value :<span class="variable">$value</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以自定义循环区间</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">2.</span><span class="number">.10</span>) &#123;</span><br><span class="line">    println(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、while-和-do-while-循环"><a href="#5、while-和-do-while-循环" class="headerlink" title="5、while 和 do&#x2F;while 循环"></a>5、while 和 do&#x2F;while 循环</h2><p>while 和 do&#x2F;while 与 Java 中的区别不大</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">9</span>)</span><br><span class="line"><span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (index &lt; list.size) &#123;</span><br><span class="line">    println(list[index])</span><br><span class="line">    index++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">9</span>)</span><br><span class="line"><span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    println(list[index])</span><br><span class="line">    index++</span><br><span class="line">&#125; <span class="keyword">while</span> (index &lt; list.size)</span><br></pre></td></tr></table></figure>

<h2 id="6、返回和跳转"><a href="#6、返回和跳转" class="headerlink" title="6、返回和跳转"></a>6、返回和跳转</h2><p>kotlin 有三种结构化跳转表达式：</p>
<ul>
<li>return 默认从最直接包围它的函数或者匿名函数返回</li>
<li>break  终止最直接包围它的循环</li>
<li>continue  继续下一次最直接包围它的循环</li>
</ul>
<p>在 kotlin 中任何表达式都可以用标签（label）来标记，标签的格式为标识符后跟 @ 符号，例如：<strong>abc@ 、fooBar@</strong> 都是有效的标签</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fun1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">40</span>)</span><br><span class="line">    <span class="symbol">loop@</span> <span class="keyword">for</span> (it <span class="keyword">in</span> list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">23</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span><span class="symbol">@loop</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;value is <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;function end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">value <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line">value <span class="keyword">is</span> <span class="number">4</span></span><br><span class="line">value <span class="keyword">is</span> <span class="number">6</span></span><br><span class="line">value <span class="keyword">is</span> <span class="number">12</span></span><br><span class="line">function end</span><br></pre></td></tr></table></figure>

<p>kotlin 有函数字面量、局部函数和对象表达式。因此 kotlin 的函数可以被嵌套</p>
<p>标签限制的 return 允许我们从外层函数返回，最重要的一个用途就是从 lambda 表达式中返回。通常情况下使用隐式标签更方便，该标签与接受该 lambda 的函数同名</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fun1()</span><br><span class="line">    fun2()</span><br><span class="line">    fun3()</span><br><span class="line">    fun4()</span><br><span class="line">    fun5()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">40</span>)</span><br><span class="line">    list.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;value is <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;function end&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//    value is 1</span></span><br><span class="line"><span class="comment">//    value is 4</span></span><br><span class="line"><span class="comment">//    value is 6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fun2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">40</span>)</span><br><span class="line">    list.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@fun2</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;value is <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;function end&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//    value is 1</span></span><br><span class="line"><span class="comment">//    value is 4</span></span><br><span class="line"><span class="comment">//    value is 6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fun3() 和 fun4() 中使用的局部返回类似于在常规循环中使用 continue</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fun3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">40</span>)</span><br><span class="line">    list.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@forEach</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;value is <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;function end&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    value is 1</span></span><br><span class="line"><span class="comment">//    value is 4</span></span><br><span class="line"><span class="comment">//    value is 6</span></span><br><span class="line"><span class="comment">//    value is 12</span></span><br><span class="line"><span class="comment">//    value is 23</span></span><br><span class="line"><span class="comment">//    value is 40</span></span><br><span class="line"><span class="comment">//    function end</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fun4</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">40</span>)</span><br><span class="line">    list.forEach <span class="symbol">loop@</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@loop</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;value is <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;function end&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//    value is 1</span></span><br><span class="line"><span class="comment">//    value is 4</span></span><br><span class="line"><span class="comment">//    value is 6</span></span><br><span class="line"><span class="comment">//    value is 12</span></span><br><span class="line"><span class="comment">//    value is 23</span></span><br><span class="line"><span class="comment">//    value is 40</span></span><br><span class="line"><span class="comment">//    function end</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fun5</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).forEach(<span class="function"><span class="title">fun</span><span class="params">(value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">//局部返回到匿名函数的调用者，即 forEach 循环</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;value is <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    println(<span class="string">&quot;function end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、区间"><a href="#六、区间" class="headerlink" title="六、区间"></a>六、区间</h1><p>Ranges 表达式使用一个 <strong>..</strong>  操作符来声明一个闭区间，它被用于定义实现一个 RangTo 方法</p>
<p>以下三种声明方式都是等价的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> index = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="number">10</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index <span class="keyword">in</span> <span class="number">0.</span><span class="number">.10</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index <span class="keyword">in</span> <span class="number">0.</span>rangeTo(<span class="number">10</span>)) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数字类型的 ranges 在被迭代时，编译器会将它们转换为与 Java 中使用 index 的 for 循环的相同字节码的方式来进行优化</p>
<p>Ranges 默认会自增长，所以像以下的代码就不会被执行</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">10.</span><span class="number">.0</span>) &#123;</span><br><span class="line">    println(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以改用 downTo 函数来将之改为递减</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">10</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">    println(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在 ranges 中使用 step 来定义每次循环递增或递增的长度：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">1.</span><span class="number">.8</span> step <span class="number">2</span>)&#123;</span><br><span class="line">    println(index)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">8</span> downTo <span class="number">1</span> step <span class="number">2</span>) &#123;</span><br><span class="line">    println(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上声明的都是闭区间，如果想声明的是开区间，可以使用 until 函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">0</span> until <span class="number">4</span>)&#123;</span><br><span class="line">    println(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展函数 <code>reversed()</code> 可用于返回将区间反转后的序列</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rangeTo = <span class="number">1.</span>rangeTo(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> rangeTo) &#123;</span><br><span class="line">    println(i) <span class="comment">//1  2  3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> rangeTo.reversed()) &#123;</span><br><span class="line">    println(i) <span class="comment">//3  2  1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七、修饰符"><a href="#七、修饰符" class="headerlink" title="七、修饰符"></a>七、修饰符</h1><h2 id="1、final-和-open"><a href="#1、final-和-open" class="headerlink" title="1、final 和  open"></a>1、final 和  open</h2><p>kotlin 中的类和方法默认都是 final 的，即不可继承的，如果想允许创建一个类的子类，需要使用 open 修饰符来标识这个类，此外，也需要为每一个希望被重写的属性和方法添加 open 修饰符</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//不能在子类中被重写</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longClick</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span> : <span class="type">View</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.click()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果重写了一个基类或者接口的成员，重写了的成员同样默认是 open 的。例如，如果 Button 类是 open 的，则其子类也可以重写其 click() 方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Button</span> : <span class="type">View</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.click()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompatButton</span> : <span class="type">Button</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.click()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要类的子类重写该方法的实现，可以显式地将重写的成员标记为 final</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Button</span> : <span class="type">View</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">final</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.click()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、public"><a href="#2、public" class="headerlink" title="2、public"></a>2、public</h2><p>public 修饰符是限制级最低的修饰符，是默认的修饰符。如果一个定义为 public  的成员被包含在一个 private  修饰的类中，那么这个成员在这个类以外也是不可见的</p>
<h2 id="3、protected"><a href="#3、protected" class="headerlink" title="3、protected"></a>3、protected</h2><p>protected 修饰符只能被用在类或者接口中的成员上。在 Java 中，可以从同一个包中访问一个 protected 的成员，但对于 kotlin 来说，protected 成员只在该类和它的子类中可见。此外，protected 不适用于顶层声明</p>
<h2 id="4、internal"><a href="#4、internal" class="headerlink" title="4、internal"></a>4、internal</h2><p>一个定义为 internal 的包成员，对其所在的整个 module 可见，但对于其它 module 而言就是不可见的了。例如，假设我们想要发布一个开源库，库中包含某个类，我们希望这个类对于库本身是全局可见的，但对于外部使用者来说它不能被引用到，此时就可以选择将其声明为 internal 的来实现这个目的</p>
<blockquote>
<p>根据 Jetbrains 的定义，一个 module  应该是一个单独的功能性的单位，可以看做是一起编译的 kotlin 文件的集合，它应该是可以被单独编译、运行、测试、debug 的。相当于在 Android Studio 中主工程引用的 module，Eclipse 中在一个 workspace 中的不同的 project</p>
</blockquote>
<h2 id="5、private"><a href="#5、private" class="headerlink" title="5、private"></a>5、private</h2><p>private  修饰符是限制级最高的修饰符，kotlin 允许在顶层声明中使用 private 可见性，包括类、函数和属性，这表示只在自己所在的文件中可见，所以如果将一个类声明为 private，就不能在定义这个类之外的地方中使用它。此外，如果在一个类里面使用了 private  修饰符，那访问权限就被限制在这个类里面，继承这个类的子类也不能使用它。所以如果类、对象、接口等被定义为 private，那么它们只对被定义所在的文件可见。如果被定义在了类或者接口中，那它们只对这个类或者接口可见</p>
<h2 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h2><table>
<thead>
<tr>
<th>修饰符</th>
<th>类成员</th>
<th>顶层声明</th>
</tr>
</thead>
<tbody><tr>
<td>public（默认）</td>
<td>所有地方可见</td>
<td>所有地方可见</td>
</tr>
<tr>
<td>internal</td>
<td>模块中可见</td>
<td>模块中可见</td>
</tr>
<tr>
<td>protected</td>
<td>子类中可见</td>
<td></td>
</tr>
<tr>
<td>private</td>
<td>类中可见</td>
<td>文件中可见</td>
</tr>
</tbody></table>
<h1 id="八、空安全"><a href="#八、空安全" class="headerlink" title="八、空安全"></a>八、空安全</h1><h2 id="1、可空性"><a href="#1、可空性" class="headerlink" title="1、可空性"></a>1、可空性</h2><p>在 kotlin 中，类型系统将一个引用分为可以容纳  null （可空引用）或者不能容纳 null（非空引用）两种类型。 例如，String 类型的常规变量不能指向 null </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name: String = <span class="string">&quot;leavesC&quot;</span></span><br><span class="line"><span class="comment">//编译错误</span></span><br><span class="line"><span class="comment">//name = null</span></span><br></pre></td></tr></table></figure>

<p>如果希望一个变量可以储存 null 引用，需要显式地在类型名称后面加上问号</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name: String? = <span class="string">&quot;leavesC&quot;</span></span><br><span class="line">name = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>问号可以加在任何类型的后面来表示这个类型的变量可以存储 null 引用：<code>Int?、Doubld? 、Long?</code> 等</p>
<p>kotlin 对可空类型的显式支持有助于防止 <strong>NullPointerException</strong> 导致的异常问题，编译器不允许不对可空变量做 null 检查就直接调用其属性。这个强制规定使得开发者必须在编码初期就考虑好变量的可赋值范围并为其各个情况做好分支处理</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(name: <span class="type">String</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">//error，编译器不允许不对 name 做 null 检查就直接调用其属性</span></span><br><span class="line">    <span class="keyword">return</span> name.isNotEmpty()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确的做法是显式地进行 null 检查</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(name: <span class="type">String</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> name.isNotEmpty()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、安全调用运算符："><a href="#2、安全调用运算符：" class="headerlink" title="2、安全调用运算符：?."></a>2、安全调用运算符：?.</h2><p>安全调用运算符：<code>?.</code> 允许把一次 null 检查和一次方法调用合并为一个操作，如果变量值非空，则方法或属性会被调用，否则直接返回 null</p>
<p>例如，以下两种写法是完全等同的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(name: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">null</span>) &#123;</span><br><span class="line">        println(name.toUpperCase())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(name: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">    println(name?.toUpperCase())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、Elvis-运算符："><a href="#3、Elvis-运算符：" class="headerlink" title="3、Elvis 运算符：?:"></a>3、Elvis 运算符：?:</h2><p>Elvis 运算符：<code>?:</code> 用于替代 <code>?.</code> 直接返回默认值 null 的情况，Elvis 运算符接收两个运算数，如果第一个运算数不为 null ，运算结果就是其运算结果值，如果第一个运算数为 null ，运算结果就是第二个运算数</p>
<p>例如，以下两种写法是完全等同的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(name: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">null</span>) &#123;</span><br><span class="line">        println(name)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(name: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">    println(name ?: <span class="string">&quot;default&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、安全转换运算符：as"><a href="#4、安全转换运算符：as" class="headerlink" title="4、安全转换运算符：as?"></a>4、安全转换运算符：as?</h2><p>安全转换运算符：<code>as?</code> 用于把值转换为指定的类型，如果值不适合该类型则返回 null</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(any: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = any <span class="keyword">as</span>? String</span><br><span class="line">    println(result ?: println(<span class="string">&quot;is not String&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、非空断言："><a href="#5、非空断言：" class="headerlink" title="5、非空断言：!!"></a>5、非空断言：!!</h2><p>非空断言用于把任何值转换为非空类型，如果对 null 值做非空断言，则会抛出异常</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String? = <span class="string">&quot;leavesC&quot;</span></span><br><span class="line">    check(name) <span class="comment">//7</span></span><br><span class="line"></span><br><span class="line">    name = <span class="literal">null</span></span><br><span class="line">    check(name) <span class="comment">//kotlinNullPointerException</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(name: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">    println(name!!.length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、可空类型的扩展"><a href="#6、可空类型的扩展" class="headerlink" title="6、可空类型的扩展"></a>6、可空类型的扩展</h2><p>为可空类型定义扩展函数是一种更强大的处理 null 值的方式，可以允许接收者为 null 的调用，并在该函数中处理 null ，而不是在确保变量不为 null 之后再调用它的方法</p>
<p>例如，如下方法可以被正常调用而不会发生空指针异常</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name: String? = <span class="literal">null</span></span><br><span class="line">println(name.isNullOrEmpty()) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><code>isNullOrEmpty()</code> 的方法签名如下所示，可以看到这是为可空类型 <strong>CharSequence?</strong> 定义的扩展函数，方法中已经处理了方法调用者为 null 的情况</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> CharSequence?.<span class="title">isNullOrEmpty</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        returns(<span class="literal">false</span>) implies (<span class="keyword">this</span><span class="symbol">@isNullOrEmpty</span> != <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> == <span class="literal">null</span> || <span class="keyword">this</span>.length == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、平台类型"><a href="#7、平台类型" class="headerlink" title="7、平台类型"></a>7、平台类型</h2><p>平台类型是 kotlin 对 java 所作的一种平衡性设计。kotlin 将对象的类型分为了可空类型和不可空类型两种，但 java 平台的一切对象类型均为可空的，当在 kotlin 中引用 java 变量时，如果将所有变量均归为可空类型，最终将多出许多 null 检查；如果均看成不可空类型，那么就很容易就写出忽略了NPE 风险的代码。为了平衡两者，kotlin 引入了平台类型，即当在 kotlin 中引用 java 变量值时，既可以将之看成可空类型，也可以将之看成不可空类型，由开发者自己来决定是否进行 null 检查</p>
<h1 id="九、类型的检查与转换"><a href="#九、类型的检查与转换" class="headerlink" title="九、类型的检查与转换"></a>九、类型的检查与转换</h1><h2 id="1、类型检查"><a href="#1、类型检查" class="headerlink" title="1、类型检查"></a>1、类型检查</h2><p><strong>is 与 !is</strong> 操作符用于在运行时检查对象是否符合给定类型：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> strValue = <span class="string">&quot;leavesC&quot;</span></span><br><span class="line">    parserType(strValue) <span class="comment">//value is String , length : 7</span></span><br><span class="line">    <span class="keyword">val</span> intValue = <span class="number">100</span></span><br><span class="line">    parserType(intValue) <span class="comment">//value is Int , toLong : 100</span></span><br><span class="line">    <span class="keyword">val</span> doubleValue = <span class="number">100.22</span></span><br><span class="line">    parserType(doubleValue) <span class="comment">//value !is Long</span></span><br><span class="line">    <span class="keyword">val</span> longValue = <span class="number">200L</span></span><br><span class="line">    parserType(longValue) <span class="comment">//unknown</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">parserType</span><span class="params">(value: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">when</span> (value) &#123;</span><br><span class="line">        <span class="keyword">is</span> String -&gt; println(<span class="string">&quot;value is String , length : <span class="subst">$&#123;value.length&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; println(<span class="string">&quot;value is Int , toLong : <span class="subst">$&#123;value.toLong()&#125;</span>&quot;</span>)</span><br><span class="line">        !<span class="keyword">is</span> <span class="built_in">Long</span> -&gt; println(<span class="string">&quot;value !is Long&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">&quot;unknown&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，is 操作符也附带了一个智能转换功能。在许多情况下，不需要在 kotlin 中使用显式转换操作符，因为编译器跟踪不可变值的 is 检查以及显式转换，并在需要时自动插入安全的转换</p>
<p>例如，在上面的例子中，当判断 value 为 String 类型通过时，就可以直接将 value 当做 String 类型变量并调用其内部属性，这个过程就叫做智能转换</p>
<p>编译器会指定根据上下文环境，将变量智能转换为合适的类型</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value !<span class="keyword">is</span> String) <span class="keyword">return</span></span><br><span class="line"><span class="comment">//如果 value 非 String 类型时直接被 return 了，所以此处可以直接访问其 length 属性</span></span><br><span class="line">println(value.length)</span><br><span class="line"></span><br><span class="line"><span class="comment">// || 右侧的 value 被自动隐式转换为字符串，所以可以直接访问其 length 属性</span></span><br><span class="line"><span class="keyword">if</span> (value !<span class="keyword">is</span> String || value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp;&amp; 右侧的 value 被自动隐式转换为字符串，所以可以直接访问其 length 属性</span></span><br><span class="line"><span class="keyword">if</span> (value <span class="keyword">is</span> String &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、不安全的转换操作符"><a href="#2、不安全的转换操作符" class="headerlink" title="2、不安全的转换操作符"></a>2、不安全的转换操作符</h2><p>如果转换是不可能的，转换操作符 <code>as</code> 会抛出一个异常。因此，我们称之为不安全的转换操作符</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    parserType(<span class="string">&quot;leavesC&quot;</span>) <span class="comment">//value is String , length is 7</span></span><br><span class="line">    parserType(<span class="number">10</span>) <span class="comment">//会抛出异常 ClassCastException</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">parserType</span><span class="params">(value: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> tempValue = value <span class="keyword">as</span> String</span><br><span class="line">    println(<span class="string">&quot;value is String , length is <span class="subst">$&#123;tempValue.length&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，null 不能转换为 String 变量，因为该类型<strong>不是可空的</strong></p>
<p>因此如下转换会抛出异常</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="literal">null</span></span><br><span class="line"><span class="keyword">val</span> y: String = x <span class="keyword">as</span> String <span class="comment">//会抛出异常 TypeCastException</span></span><br></pre></td></tr></table></figure>

<p>为了匹配安全，可以转换的类型声明为可空类型</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="literal">null</span></span><br><span class="line"><span class="keyword">val</span> y: String? = x <span class="keyword">as</span> String?</span><br></pre></td></tr></table></figure>

<h2 id="3、安全的转换操作符"><a href="#3、安全的转换操作符" class="headerlink" title="3、安全的转换操作符"></a>3、安全的转换操作符</h2><p>可以使用安全转换操作符 as? 来避免在转换时抛出异常，它在失败时返回 null</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="literal">null</span></span><br><span class="line"><span class="keyword">val</span> y: String? = x <span class="keyword">as</span>? String</span><br></pre></td></tr></table></figure>

<p>尽管以上例子 as? 的右边是一个非空类型的 String，但是其转换的结果是可空的</p>
<h1 id="十、类"><a href="#十、类" class="headerlink" title="十、类"></a>十、类</h1><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><p>类的概念就是把数据和处理数据的代码封装成一个单一的实体。在 Java 中，数据存储在一个私有字段中，通过提供访问器方法：<strong>getter 和 setter</strong> 来访问或者修改数据</p>
<p>在 Java 中以下的示例代码是很常见的，Point 类包含很多重复的代码：通过构造函数把参数赋值给有着相同名称的字段，通过 getter 来获取属性值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.x = x;</span><br><span class="line">      <span class="built_in">this</span>.y = y;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.y;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 kotlin 来声明 Point 类则只需要一行代码，两者完全等同</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>

<p>kotlin 也使用关键字 <strong>class</strong> 来声明类，类声明由类名、类头（指定其类型参数、主构造函数等）以及由花括号包围的类体构成，类头与类体都是可选的，如果一个类没有类体，可以省略花括号。此外，kotlin 中类默认是 <strong>publish（公有的） 且 final （不可继承）的</strong></p>
<p>kotlin 区分了<strong>主构造方法（在类体外部声明）和次构造方法（在类体内部声明）</strong>，一个类可以有一个主构造函数和多个次构造函数，此外也允许在初始化代码块中 <code>init</code> 添加额外的初始化逻辑</p>
<h2 id="2、主构造函数"><a href="#2、主构造函数" class="headerlink" title="2、主构造函数"></a>2、主构造函数</h2><p>主构造函数是类头的一部分，跟在类名（和可选的类型参数）后，主构造函数的参数可以是可变的（var）或只读的（val）</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> <span class="keyword">constructor</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果主构造函数没有任何注解或者可见性修饰符，可以省略 constructor 关键字</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不包含类体，则可以省略花括号</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>

<p>如果构造函数有注解或可见性修饰符，则 constructor 关键字是必需的，并且这些修饰符在它前面</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> <span class="keyword">public</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主构造函数不能包含任何的代码，初始化的代码可以放到以 init 关键字作为前缀的初始化块（initializer blocks）中，初始化块包含了在类被创建时执行的代码，主构造函数的参数可以在初始化块中使用。如果需要的话，也可以在一个类中声明多个初始化语句块。需要注意的是，构造函数的参数如果用 val&#x2F;var 进行修饰，则相当于在类内部声明了一个同名的全局属性。如果不加 val&#x2F;var 进行修饰，则构造函数只能在 init 函数块和全局属性初始化时进行引用</p>
<p>此外，要创建一个类的实例不需要使用 Java 中的 new 关键字，像普通函数一样调用构造函数即可</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;initializer blocks , x value is: <span class="variable">$x</span> , y value is: <span class="variable">$y</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Point(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// initializer blocks , x value is: 1 , y value is: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主构造函数的参数也可以在类体内声明的属性初始化器中使用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> localX = x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> localY = y + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;initializer blocks , x value is: <span class="variable">$x</span> , y value is: <span class="variable">$y</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;initializer blocks , localX value is: <span class="variable">$localX</span> , localY value is: <span class="variable">$localY</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">//initializer blocks , x value is: 1 , y value is: 2</span></span><br><span class="line">    <span class="comment">//initializer blocks , localX value is: 2 , localY value is: 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、次构造函数"><a href="#3、次构造函数" class="headerlink" title="3、次构造函数"></a>3、次构造函数</h2><p>类也可以声明包含前缀 constructor 的次构造函数。如果类有一个主构造函数，每个次构造函数都需要直接委托给主构造函数或者委托给另一个次构造函数以此进行间接委托，用 this 关键字来进行指定即可</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> localX = x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> localY = y + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;initializer blocks , x value is: <span class="variable">$x</span> , y value is: <span class="variable">$y</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;initializer blocks , localX value is: <span class="variable">$localX</span> , localY value is: <span class="variable">$localY</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(base: <span class="built_in">Int</span>) : <span class="keyword">this</span>(base + <span class="number">1</span>, base + <span class="number">1</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;constructor(base: Int)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(base: <span class="built_in">Long</span>) : <span class="keyword">this</span>(base.toInt()) &#123;</span><br><span class="line">        println(<span class="string">&quot;constructor(base: Long)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Point(<span class="number">100</span>)</span><br><span class="line">    <span class="comment">//initializer blocks , x value is: 101 , y value is: 101</span></span><br><span class="line">    <span class="comment">//initializer blocks , localX value is: 102 , localY value is: 102</span></span><br><span class="line">    <span class="comment">//constructor(base: Int)</span></span><br><span class="line">    Point(<span class="number">100L</span>)</span><br><span class="line">    <span class="comment">//initializer blocks , x value is: 101 , y value is: 101</span></span><br><span class="line">    <span class="comment">//initializer blocks , localX value is: 102 , localY value is: 102</span></span><br><span class="line">    <span class="comment">//constructor(base: Int)</span></span><br><span class="line">    <span class="comment">//constructor(base: Long)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化块中的代码实际上会成为主构造函数的一部分，委托给主构造函数会作为次构造函数的第一条语句，因此所有初始化块中的代码都会在次构造函数体之前执行。即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块。如果一个非抽象类没有声明任何（主或次）构造函数，会默认生成一个不带参数的公有主构造函数</p>
<h2 id="4、属性"><a href="#4、属性" class="headerlink" title="4、属性"></a>4、属性</h2><p>在 Java 中，字段和其访问器的组合被称作属性。在 kotlin 中，属性是头等的语言特性，完全替代了字段和访问器方法。在类中声明一个属性和声明一个变量一样是使用 val 和 var 关键字。val 变量只有一个 getter ，var 变量既有 getter 也有 setter</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = User()</span><br><span class="line">    println(user.name)</span><br><span class="line">    user.age = <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> name: String = <span class="string">&quot;leavesC&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">25</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、自定义访问器"><a href="#5、自定义访问器" class="headerlink" title="5、自定义访问器"></a>5、自定义访问器</h2><p>访问器的默认实现逻辑很简单：创建一个存储值的字段，以及返回属性值的 getter 和更新属性值的 setter。如果需要的话，也可以自定义访问器</p>
<p>例如，以下就声明了三个带自定义访问器的属性</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> isEquals1: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> x == y</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> isEquals2</span><br><span class="line">        <span class="keyword">get</span>() = x == y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> isEquals3 = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">get</span>() = x &gt; y</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = !value</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果仅需要改变一个访问器的可见性或者为其添加注解，那么可以定义访问器而不定义其实现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> point = Point(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">    println(point.isEquals1)</span><br><span class="line">    <span class="comment">//以下代码会报错</span></span><br><span class="line">    <span class="comment">//point.isEquals1 = true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> isEquals1: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> x == y</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、延迟初始化"><a href="#6、延迟初始化" class="headerlink" title="6、延迟初始化"></a>6、延迟初始化</h2><p>一般地，非空类型的属性必须在构造函数中初始化，但像使用了 Dagger2 这种依赖注入框架的项目来说就十分的不方便了，为了应对这种情况，可以用 lateinit 修饰符来标记该属性，用于告诉编译器该属性会在稍后的时间被初始化</p>
<p>用 lateinit 修饰的属性或变量必须为非空类型，并且不能是原生类型</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> point: Point</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> point2: Point</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        point2 = Point(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果访问了一个未经过初始化的 lateinit 变量，则会抛出一个包含具体原因（该变量未初始化）的异常信息</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> kotlin.UninitializedPropertyAccessException: <span class="keyword">lateinit</span> property point has not been initialized</span><br></pre></td></tr></table></figure>

<h1 id="十一、类的分类"><a href="#十一、类的分类" class="headerlink" title="十一、类的分类"></a>十一、类的分类</h1><h2 id="1、抽象类"><a href="#1、抽象类" class="headerlink" title="1、抽象类"></a>1、抽象类</h2><p>声明为 abstract 的类内部可以包含没有实现体的成员方法，且该成员方法也用 abstract 标记，这种类称为抽象类，没有实现体的方法就称为抽象方法</p>
<p>此外，我们并不需要用 open 标注一个抽象类或者抽象方法，因为这是默认声明的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="type">BaseClass</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、数据类"><a href="#2、数据类" class="headerlink" title="2、数据类"></a>2、数据类</h2><p>数据类是一种非常强大的类，可以避免重复创建 Java 中的用于保存状态但又操作非常简单的 POJO 的模版代码，它们通常只提供了用于访问它们属性的简单的 getter 和 setter</p>
<p>定义一个新的数据类非常简单，例如</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Point</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>

<p>数据类默认地为主构造函数中声明的所有属性生成了如下几个方法</p>
<ul>
<li>getter、setter（需要是 var）</li>
<li>componentN()。按主构造函数的属性声明顺序进行对应</li>
<li>copy() </li>
<li>toString()</li>
<li>hashCode()</li>
<li>equals()</li>
</ul>
<p>为了确保生成的代码的一致性以及有意义的行为，数据类必须满足以下要求：</p>
<ul>
<li>主构造函数需要包含一个参数</li>
<li>主构造函数的所有参数需要标记为 val 或 var</li>
<li>数据类不能是抽象、开放、密封或者内部的</li>
</ul>
<p>可以利用 IDEA 来反编译查看 Point 类的 Java 实现，了解其内部实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.y;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.x = x;</span><br><span class="line">      <span class="built_in">this</span>.y = y;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">component1</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">component2</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.y;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> Point <span class="title function_">copy</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Point</span>(x, y);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="comment">// $FF: bridge method</span></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Point copy$<span class="keyword">default</span>(Point var0, <span class="type">int</span> var1, <span class="type">int</span> var2, <span class="type">int</span> var3, Object var4) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((var3 &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">         var1 = var0.x;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((var3 &amp; <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">         var2 = var0.y;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> var0.copy(var1, var2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Point(x=&quot;</span> + <span class="built_in">this</span>.x + <span class="string">&quot;, y=&quot;</span> + <span class="built_in">this</span>.y + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.x * <span class="number">31</span> + <span class="built_in">this</span>.y;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object var1)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span> != var1) &#123;</span><br><span class="line">         <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> Point) &#123;</span><br><span class="line">            <span class="type">Point</span> <span class="variable">var2</span> <span class="operator">=</span> (Point)var1;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.x == var2.x &amp;&amp; <span class="built_in">this</span>.y == var2.y) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过数据类可以简化很多的通用操作，可以很方便地进行：格式化输出变量值、映射对象到变量、对比变量之间的相等性、复制变量等操作</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> point1 = Point(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">val</span> point2 = Point(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">    println(<span class="string">&quot;point1 toString() : <span class="variable">$point1</span>&quot;</span>) <span class="comment">//point1 toString() : Point(x=10, y=20)</span></span><br><span class="line">    println(<span class="string">&quot;point2 toString() : <span class="variable">$point2</span>&quot;</span>) <span class="comment">//point2 toString() : Point(x=10, y=20)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> (x, y) = point1</span><br><span class="line">    println(<span class="string">&quot;point1 x is <span class="variable">$x</span>,point1 y is <span class="variable">$y</span>&quot;</span>) <span class="comment">//point1 x is 10,point1 y is 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在 kotlin 中，“ == ” 相当于 Java 的 equals 方法</span></span><br><span class="line">    <span class="comment">//而 “ === ” 相当于 Java 的 “ == ” 方法</span></span><br><span class="line">    println(<span class="string">&quot;point1 == point2 : <span class="subst">$&#123;point1 == point2&#125;</span>&quot;</span>) <span class="comment">//point1 == point2 : true</span></span><br><span class="line">    println(<span class="string">&quot;point1 === point2 : <span class="subst">$&#123;point1 === point2&#125;</span>&quot;</span>) <span class="comment">//point1 === point2 : false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> point3 = point1.copy(y = <span class="number">30</span>)</span><br><span class="line">    println(<span class="string">&quot;point3 toString() : <span class="variable">$point3</span>&quot;</span>) <span class="comment">//point3 toString() : Point(x=10, y=30)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，数据类的 <code>toString()、equals()、hashCode()、copy()</code> 等方法只考虑主构造函数中声明的属性，因此在比较两个数据类对象的时候可能会有一些意想不到的结果</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Point</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> y: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> point1 = Point(<span class="number">10</span>)</span><br><span class="line">    point1.y = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> point2 = Point(<span class="number">10</span>)</span><br><span class="line">    point2.y = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;point1 == point2 : <span class="subst">$&#123;point1 == point2&#125;</span>&quot;</span>) <span class="comment">//point1 == point2 : true</span></span><br><span class="line">    println(<span class="string">&quot;point1 === point2 : <span class="subst">$&#123;point1 === point2&#125;</span>&quot;</span>) <span class="comment">//point1 === point2 : false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、密封类"><a href="#3、密封类" class="headerlink" title="3、密封类"></a>3、密封类</h2><p>Sealed 类（密封类）用于对类可能创建的子类进行限制，用 Sealed 修饰的类的<strong>直接子类</strong>只允许被定义在 Sealed 类所在的文件中（密封类的间接继承者可以定义在其他文件中），这有助于帮助开发者掌握父类与子类之间的变动关系，避免由于代码更迭导致的潜在 bug，且密封类的构造函数只能是 private 的</p>
<p>例如，对于 View 类，其子类只能定义在与之同一个文件里，Sealed 修饰符修饰的类也隐含表示该类为 open 类，因此无需再显式地添加 open 修饰符</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">View</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span> : <span class="type">View</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextView</span> : <span class="type">View</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 Sealed 类的子类对于编译器来说是可控的，所以如果在 when 表达式中处理了所有 Sealed 类的子类，那就不需要再提供 else 默认分支。即使以后由于业务变动又新增了 View 子类，编译器也会检测到 check 方法缺少分支检查后报错，所以说 check 方法是类型安全的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(view: <span class="type">View</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">when</span> (view) &#123;</span><br><span class="line">        <span class="keyword">is</span> Button -&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;is Button&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">is</span> TextView -&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;is TextView&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、枚举类"><a href="#4、枚举类" class="headerlink" title="4、枚举类"></a>4、枚举类</h2><p>kotlin 也提供了枚举的实现，相比 Java 需要多使用 class 关键字来声明枚举</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">    SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举可以声明一些参数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Day</span>(<span class="keyword">val</span> index: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    SUNDAY(<span class="number">0</span>), MONDAY(<span class="number">1</span>), TUESDAY(<span class="number">2</span>), WEDNESDAY(<span class="number">3</span>), THURSDAY(<span class="number">4</span>), FRIDAY(<span class="number">5</span>), SATURDAY(<span class="number">6</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，枚举也可以实现接口</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">OnChangedListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onChanged</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Day</span>(<span class="keyword">val</span> index: <span class="built_in">Int</span>) : OnChangedListener &#123;</span><br><span class="line">    SUNDAY(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onChanged</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MONDAY(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onChanged</span><span class="params">()</span></span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举也包含有一些共有函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> day = Day.FRIDAY</span><br><span class="line">    <span class="comment">//获取值</span></span><br><span class="line">    <span class="keyword">val</span> value = day.index  <span class="comment">//5</span></span><br><span class="line">    <span class="comment">//通过 String 获取相应的枚举值</span></span><br><span class="line">    <span class="keyword">val</span> value1 = Day.valueOf(<span class="string">&quot;SUNDAY&quot;</span>) <span class="comment">//SUNDAY</span></span><br><span class="line">    <span class="comment">//获取包含所有枚举值的数组</span></span><br><span class="line">    <span class="keyword">val</span> value2 = Day.values()</span><br><span class="line">    <span class="comment">//获取枚举名</span></span><br><span class="line">    <span class="keyword">val</span> value3 = Day.SUNDAY.name <span class="comment">//SUNDAY</span></span><br><span class="line">    <span class="comment">//获取枚举声明的位置</span></span><br><span class="line">    <span class="keyword">val</span> value4 = Day.TUESDAY.ordinal <span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、嵌套类"><a href="#5、嵌套类" class="headerlink" title="5、嵌套类"></a>5、嵌套类</h2><p>在 kotlin 中在类里面再定义的类默认是嵌套类，此时嵌套类不会包含对外部类的隐式引用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Nested</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo1</span><span class="params">()</span></span> = <span class="number">2</span></span><br><span class="line">        <span class="comment">//错误</span></span><br><span class="line">        <span class="comment">//fun foo2() = bar</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Outer.Nested().foo1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码通过 IDEA 反编译后可以看到其内部的 Java 实现方式</p>
<p>可以看到 Nested 其实就是一个静态类，因此 foo2() 不能访问外部类的非静态成员，也不用先声明 Outer 变量再指向 Nested 类，而是直接通过 Outer  类指向 Nested 类</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> int bar = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Nested</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> int foo1() &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MainkotlinKt</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> void main(<span class="meta">@NotNull</span> String[] args) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, <span class="string">&quot;args&quot;</span>);</span><br><span class="line">      int demo = (new Outer.Nested()).foo1();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、内部类"><a href="#6、内部类" class="headerlink" title="6、内部类"></a>6、内部类</h2><p>如果需要去访问外部类的成员，需要用 inner 修饰符来标注被嵌套的类，这称为内部类。内部类会隐式持有对外部类的引用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">Nested</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo1</span><span class="params">()</span></span> = <span class="number">2</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo2</span><span class="params">()</span></span> = bar</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Outer().Nested().foo2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看其内部的 Java 实现方式</p>
<p>使用 inner 来声明 Nested 类后，就相当于将之声明为非静态内部类，因此 foo2() 能访问其外部类的非静态成员，在声明 Nested 变量前也需要通过 Outer 变量来指向其内部的 Nested 类</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> int bar = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Nested</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> int foo1() &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> int foo2() &#123;</span><br><span class="line">         <span class="keyword">return</span> Outer.<span class="keyword">this</span>.bar;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MainkotlinKt</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> void main(<span class="meta">@NotNull</span> String[] args) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, <span class="string">&quot;args&quot;</span>);</span><br><span class="line">      int demo = (new Outer().new Nested()).foo2();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>类A在类B中声明</th>
<th>在Java中</th>
<th>在kotlin中</th>
</tr>
</thead>
<tbody><tr>
<td>嵌套类（不存储外部类的引用）</td>
<td>static class A</td>
<td>class A</td>
</tr>
<tr>
<td>内部类（存储外部类的引用）</td>
<td>class A</td>
<td>inner class A</td>
</tr>
</tbody></table>
<h2 id="7、匿名内部类"><a href="#7、匿名内部类" class="headerlink" title="7、匿名内部类"></a>7、匿名内部类</h2><p>可以使用<strong>对象表达式</strong>来创建匿名内部类实例</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">OnClickListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">View</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setClickListener</span><span class="params">(clickListener: <span class="type">OnClickListener</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> view = View()</span><br><span class="line">    view.setClickListener(<span class="keyword">object</span> : OnClickListener &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8、内联类"><a href="#8、内联类" class="headerlink" title="8、内联类"></a>8、内联类</h2><p>在有些时候，我们需要对原生类型进行包装以便提升程序的健壮性。例如，对于 <code>sendEmail</code> 方法的入参参数而言，我们无法严格限制入参参数的含义类型，有的开发者可能会将 delay 理解为以毫秒为单位，有的开发者可能又会理解为以分钟为单位</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sendEmail</span><span class="params">(delay: <span class="type">Long</span>)</span></span> &#123;</span><br><span class="line">    println(delay)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了提升程序的健壮性，我们可以通过声明一个包装类来作为参数类型：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sendEmail</span><span class="params">(delay: <span class="type">Time</span>)</span></span> &#123;</span><br><span class="line">    println(delay.second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span>(<span class="keyword">val</span> second: <span class="built_in">Long</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Minute</span>(<span class="keyword">private</span> <span class="keyword">val</span> count: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">toTime</span><span class="params">()</span></span>: Time &#123;</span><br><span class="line">        <span class="keyword">return</span> Time(count * <span class="number">60L</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sendEmail(Minute(<span class="number">10</span>).toTime())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，在代码源头上就限制了开发者能够传入的参数类型，开发者通过类名就能直接表达出自己希望的时间大小。然而这种方式由于额外的堆内存分配问题，就引入了运行时的性能开销，新的包装类相对原生类型所需要的性能消耗要大得多，可是此时又需要考虑程序的健壮性和可读性，所以包装类也是需要的</p>
<p>内联类（InlineClass）就是为了解决这两者的矛盾而诞生的。上述代码可以改为以下方式来实现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sendEmail</span><span class="params">(delay: <span class="type">Time</span>)</span></span> &#123;</span><br><span class="line">    println(delay.second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">Time</span>(<span class="keyword">val</span> second: <span class="built_in">Long</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">Minute</span>(<span class="keyword">private</span> <span class="keyword">val</span> count: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">toTime</span><span class="params">()</span></span>: Time &#123;</span><br><span class="line">        <span class="keyword">return</span> Time(count * <span class="number">60L</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sendEmail(Minute(<span class="number">10</span>).toTime())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 inline 修饰的类就称为内联类，内联类必须含有唯一的一个属性在主构造函数中初始化，在运行时将使用这个唯一属性来表示内联类的实例，从而避免了包装类在运行时的额外开销</p>
<p>例如，通过查看字节码可以看到<code>sendEmail</code> 方法会被解释为一个以 long 类型作为入参类型的函数，并不包含任何对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> sendEmail_G1aXmDY<span class="comment">/* $FF was: sendEmail-G1aXmDY*/</span>(<span class="type">long</span> delay) &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  System.out.println(delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十二、接口"><a href="#十二、接口" class="headerlink" title="十二、接口"></a>十二、接口</h1><h2 id="1、抽象方法与默认方法"><a href="#1、抽象方法与默认方法" class="headerlink" title="1、抽象方法与默认方法"></a>1、抽象方法与默认方法</h2><p>kotlin 中的接口与 Java 8 中的类似，可以包含抽象方法的定义以及非抽象方法的实现，不需要使用 default 关键字来标注有默认实现的非抽象方法，但在实现接口的抽象方法时需要使用 override 进行标注</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> view = View()</span><br><span class="line">    view.click()</span><br><span class="line">    view.longClick()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">View</span> : <span class="type">Clickable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;clicked&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Clickable</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longClick</span><span class="params">()</span></span> = println(<span class="string">&quot;longClicked&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个类实现了多个接口，而接口包含带有默认实现且签名相同的方法，此时编译器就会要求开发者必须显式地实现该方法，可以选择在该方法中调用不同接口的相应实现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">View</span> : <span class="type">Clickable</span>, <span class="type">Clickable2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;clicked&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">longClick</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;Clickable&gt;.longClick()</span><br><span class="line">        <span class="keyword">super</span>&lt;Clickable2&gt;.longClick()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Clickable</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longClick</span><span class="params">()</span></span> = println(<span class="string">&quot;longClicked&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Clickable2</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">longClick</span><span class="params">()</span></span> = println(<span class="string">&quot;longClicked2&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、抽象属性"><a href="#2、抽象属性" class="headerlink" title="2、抽象属性"></a>2、抽象属性</h2><p>接口中可以包含抽象属性声明，接口不定义该抽象属性是应该存储到一个支持字段还是通过 getter 来获取，接口本身并不包含任何状态，因此只有实现这个接口的类在需要的情况下会存储这个值</p>
<p>看以下例子，Button 类和 TextView 类都实现了 Clickable 接口，并都提供了取得 statusValue 值的方式</p>
<p>Button 类提供了一个自定义的 getter 用于在每次访问时重新获取 statusValue 值，因此在多次获取属性值时其值可能都会不一致，因为每次 getRandom() 方法都会被调用</p>
<p>TextView 类中的 statusValue 属性有一个支持字段来存储在类初始化时得到的数据，因此其值在初始化后是不会再次获取值，即 TextView 类中的 getRandom() 只会被调用一次</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> button = Button()</span><br><span class="line">    println(button.statusValue)</span><br><span class="line">    <span class="keyword">val</span> textView = TextView()</span><br><span class="line">    println(textView.statusValue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span> : <span class="type">Clickable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> statusValue: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = getRandom()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getRandom</span><span class="params">()</span></span> = Random().nextInt(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextView</span> : <span class="type">Clickable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> statusValue: <span class="built_in">Int</span> = getRandom()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getRandom</span><span class="params">()</span></span> = Random().nextInt(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Clickable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> statusValue: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了可以声明抽象属性外，接口还可以包含具有 getter 和 setter 的属性，只要它们没有引用一个支持字段（支持字段需要在接口中存储状态，而这是不允许的）</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Clickable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> statusValue: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> check: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = statusValue &gt; <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十三、SAM-接口"><a href="#十三、SAM-接口" class="headerlink" title="十三、SAM 接口"></a>十三、SAM 接口</h1><p>对于以下例子，在 Kotlin 1.4 之前第二种写法是不支持的，我们必须完全实现 SelfRunnable 才可以调用 <code>setRunnable</code> 方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: leavesCZY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Github</span>：https://github.com/leavesCZY</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SelfRunnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setRunnable</span><span class="params">(selfRunnable: <span class="type">SelfRunnable</span>)</span></span> &#123;</span><br><span class="line">    selfRunnable.run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    setRunnable(<span class="keyword">object</span> : SelfRunnable &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;hello,leavesC&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//错误，Kotlin 1.4 之前不支持</span></span><br><span class="line"><span class="comment">//    setRunnable &#123;</span></span><br><span class="line"><span class="comment">//        println(&quot;hello,leavesC&quot;)</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在 Kotlin 1.4 之后，Kotlin 开始支持 <strong>SAM 转换</strong>。只有一个抽象方法的接口称为<strong>函数式接口</strong>或 <strong>SAM（单一抽象方法）接口</strong>，函数式接口可以有多个非抽象成员，但只能有一个抽象成员。SAM 转换即 <code>Single Abstract Method Conversions</code>，对于只有单个非默认抽象方法的接口，可以直接用 Lambda 来表示，前提是 Lambda 所表示的函数类型能够跟接口中的方法签名相匹配</p>
<p>所以，在 Kotlin 1.4 之后，就支持直接以 Lambda 的方式来声明 SelfRunnable 的实现类，从而使得在方法调用上可以更加简洁，但这也要求 interface 同时使用 fun 关键字修饰</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: leavesCZY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Github</span>：https://github.com/leavesCZY</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> SelfRunnable &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setRunnable</span><span class="params">(selfRunnable: <span class="type">SelfRunnable</span>)</span></span> &#123;</span><br><span class="line">    selfRunnable.run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    setRunnable &#123;</span><br><span class="line">        println(<span class="string">&quot;hello,leavesC&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十四、继承"><a href="#十四、继承" class="headerlink" title="十四、继承"></a>十四、继承</h1><p>在 kotlin 中所有类都有一个共同的超类 <strong>Any</strong> ，对于没有超类声明的类来说它就是默认超类。需要注意的是， Any  并不是  <strong>java.lang.Object</strong>  ，它除了  <strong>equals()  、 hashCode()  与 toString()</strong>  外没有其他属性或者函数</p>
<p>要声明一个显式的超类，需要把父类名放到类头的冒号之后</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Base</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span>() : Base()</span><br></pre></td></tr></table></figure>

<p>当中，类上的 open 标注与 Java 中的 final 含义相反，用于允许其它类从这个类继承。默认情况下，kotlin 中所有的类都是 final</p>
<p>如果派生类有一个主构造函数，其基类型必须直接或间接调用基类的主构造函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Base</span>(<span class="keyword">val</span> str: String)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span>(<span class="keyword">val</span> strValue: String) : Base(strValue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass2</span> : <span class="type">Base</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(strValue: String) : <span class="keyword">super</span>(strValue)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(intValue: <span class="built_in">Int</span>) : <span class="keyword">super</span>(intValue.toString())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(doubValue: <span class="built_in">Double</span>) : <span class="keyword">this</span>(doubValue.toString())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1、覆盖方法"><a href="#1、覆盖方法" class="headerlink" title="1、覆盖方法"></a>1、覆盖方法</h2><p>与 Java 不同，kotlin 需要显式标注可覆盖的成员和覆盖后的成员：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Base</span>() &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fun2</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span>() : Base() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.fun1()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 open 标注的函数才可以被子类重载，子类用 override 表示该函数是要对父类的同签名函数进行覆盖。标记为 override 的成员本身也是开放的，也就是说，它可以被子类覆盖。如果想禁止再次覆盖，可以使用 final 关键字标记<br>如果父类没有使用 open 对函数进行标注，则子类不允许定义相同签名的函数。对于一个 final 类（没有用 open 标注的类）来说，使用 open 标记属性和方法是无意义的</p>
<h2 id="2、属性覆盖"><a href="#2、属性覆盖" class="headerlink" title="2、属性覆盖"></a>2、属性覆盖</h2><p>属性覆盖与方法覆盖类似。在超类中声明为 open 的属性，如果要进行覆盖则必须在派生类中重新声明且以 override 开头，并且它们必须具有兼容的类型</p>
<p>每个声明的属性可以由具有初始化器的属性或者具有 getter 方法的属性覆盖</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> x = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> y: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> : <span class="type">Base</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> x = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> y = <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> base = Base()</span><br><span class="line">    println(base.x) <span class="comment">//10</span></span><br><span class="line">    println(base.y) <span class="comment">//100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> base1: Base = SubClass()</span><br><span class="line">    println(base1.x) <span class="comment">//100</span></span><br><span class="line">    println(base1.y) <span class="comment">//200</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> subClass = SubClass()</span><br><span class="line">    println(subClass.x) <span class="comment">//100</span></span><br><span class="line">    println(subClass.y) <span class="comment">//200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，也可以用一个 var 属性覆盖一个 val 属性，但反之则不行。因为一个 val 属性本质上声明了一个 getter 方法，而将其覆盖为 var 只是在子类中额外声明一个 setter 方法</p>
<p>可以在主构造函数中使用  override  关键字作为属性声明的一部分</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> str: String = <span class="string">&quot;Base&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span>(<span class="keyword">override</span> <span class="keyword">val</span> str: String) : Base()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> base = Base()</span><br><span class="line">    println(base.str) <span class="comment">//Base</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> subClass = SubClass(<span class="string">&quot;leavesC&quot;</span>)</span><br><span class="line">    println(subClass.str) <span class="comment">//leavesC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、调用超类实现"><a href="#3、调用超类实现" class="headerlink" title="3、调用超类实现"></a>3、调用超类实现</h2><p>派生类可以通过 super 关键字调用其超类的函数与属性访问器的实现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;BaseClass fun1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> : <span class="type">BaseClass</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.fun1()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于内部类来说，其本身就可以直接调用调用外部类的函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">BaseClass2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;BaseClass fun1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">fun2</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fun1()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但如果想要在一个内部类中访问外部类的超类，则需要通过由外部类名限定的 super 关键字来实现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;BaseClass fun1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> : <span class="type">BaseClass</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;SubClass fun1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">fun2</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="symbol">super@</span>SubClass.fun1()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> subClass = SubClass()</span><br><span class="line">    <span class="keyword">val</span> innerClass = subClass.InnerClass()</span><br><span class="line">    <span class="comment">//BaseClass fun1</span></span><br><span class="line">    innerClass.fun2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个类从它的直接超类和实现的接口中继承了相同成员的多个实现， 则必须覆盖这个成员并提供其自己的实现来消除歧义</p>
<p>为了表示采用从哪个超类型继承的实现，使用由尖括号中超类型名限定的 super 来指定，如  super&lt; BaseClass &gt;</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;BaseClass fun1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">BaseInterface</span> &#123;</span><br><span class="line">    <span class="comment">//接口成员默认就是 open 的</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;BaseInterface fun1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span>() : BaseClass(), BaseInterface &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//调用 SubClass 的 fun1() 函数</span></span><br><span class="line">        <span class="keyword">super</span>&lt;BaseClass&gt;.fun1()</span><br><span class="line">        <span class="comment">//调用 BaseInterface 的 fun1() 函数</span></span><br><span class="line">        <span class="keyword">super</span>&lt;BaseInterface&gt;.fun1()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十五、集合"><a href="#十五、集合" class="headerlink" title="十五、集合"></a>十五、集合</h1><h2 id="1、只读集合与可变集合"><a href="#1、只读集合与可变集合" class="headerlink" title="1、只读集合与可变集合"></a>1、只读集合与可变集合</h2><p>kotlin 的集合设计和 Java 不同的另一项特性是：kotlin 把访问数据的接口和修改集合数据的接口分开了，<code>kotlin.collections.Collection</code> 接口提供了<strong>遍历集合元素、获取集合大小、判断集合是否包含某元素</strong>等操作，但这个接口没有提供<strong>添加和移除元素</strong>的方法。<code>kotlin.collections.MutableCollection</code> 接口继承于 <code>kotlin.collections.Collection</code> 接口，扩展出了用于<strong>添加、移除、清空元素</strong>的方法</p>
<p>就像 kotlin 对 <code>val</code> 和 <code>var</code> 的区分一样，只读集合接口与可变集合接口的分离能提高对代码的可控性，如果函数接收 <code>Collection</code> 作为形参，那么就可以知道该函数不会修改集合，而只是对数据进行读取</p>
<p>以下是用来创建不同类型集合的函数</p>
<table>
<thead>
<tr>
<th>集合元素</th>
<th>只读</th>
<th>可变</th>
</tr>
</thead>
<tbody><tr>
<td>List</td>
<td>listOf</td>
<td>mutableListOf、arrayListOf</td>
</tr>
<tr>
<td>Set</td>
<td>setOf</td>
<td>mutableSetOf、hashSetOf、linkedSetOf、sortedSetOf</td>
</tr>
<tr>
<td>Map</td>
<td>mapOf</td>
<td>mutableMapOf、hashMapOf、linkedMapOf、sortedMapOf</td>
</tr>
</tbody></table>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line"><span class="comment">//不包含 add 方法</span></span><br><span class="line"><span class="comment">//list.add(100)</span></span><br><span class="line">println(list.size)</span><br><span class="line">println(list.contains(<span class="number">20</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> mutableList = mutableListOf(<span class="string">&quot;leavesC&quot;</span>, <span class="string">&quot;leavesc&quot;</span>, <span class="string">&quot;叶&quot;</span>)</span><br><span class="line">mutableList.add(<span class="string">&quot;Ye&quot;</span>)</span><br><span class="line">println(mutableList.size)</span><br><span class="line">println(mutableList.contains(<span class="string">&quot;leavesC&quot;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="2、集合与-Java"><a href="#2、集合与-Java" class="headerlink" title="2、集合与 Java"></a>2、集合与 Java</h2><p>因为 Java 并不会区分只读集合与可变集合，即使 kotlin 中把集合声明为只读的， Java 代码也可以修改这个集合，而 Java 代码中的集合对 kotlin 来说也是可变性未知的，kotlin 代码可以将之视为只读的或者可变的，包含的元素也是可以为 null 或者不为 null 的</p>
<p>例如，在 Java 代码中 names 这么一个 List&lt; String &gt; 类型的变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        names.add(<span class="string">&quot;leavesC&quot;</span>);</span><br><span class="line">        names.add(<span class="string">&quot;Ye&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 kotlin 中可以用以下四种方式来引用变量 names </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list1: List&lt;String?&gt; = JavaMain.names</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list2: List&lt;String&gt; = JavaMain.names</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list3: MutableList&lt;String&gt; = JavaMain.names</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list4: MutableList&lt;String?&gt; = JavaMain.names</span><br></pre></td></tr></table></figure>

<h2 id="3、只读集合的可变性"><a href="#3、只读集合的可变性" class="headerlink" title="3、只读集合的可变性"></a>3、只读集合的可变性</h2><p>只读集合不一定就是不可变的。例如，假设存在一个拥有只读类型接口的对象，该对象存在两个不同的引用，一个只读，一个可变，当可变引用修改了该对象后，这对只读引用来说就相当于“只读集合被修改了”，因此只读集合并不总是线程安全的。如果需要在多线程环境下处理数据，需要保证正确地同步了对数据的访问，或者使用支持并发访问的数据结构</p>
<p>例如，list1 和 list1 引用到同一个集合对象， list3 对集合的修改同时会影响到 list1</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list1: List&lt;String&gt; = JavaMain.names</span><br><span class="line"><span class="keyword">val</span> list3: MutableList&lt;String&gt; = JavaMain.names</span><br><span class="line">list1.forEach &#123; it -&gt; println(it) &#125; <span class="comment">//leavesC Ye</span></span><br><span class="line">list3.forEach &#123; it -&gt; println(it) &#125; <span class="comment">//leavesC Ye</span></span><br><span class="line"><span class="keyword">for</span> (index <span class="keyword">in</span> list3.indices) &#123;</span><br><span class="line">    list3[index] = list3[index].toUpperCase()</span><br><span class="line">&#125;</span><br><span class="line">list1.forEach &#123; it -&gt; println(it) &#125; <span class="comment">//LEAVESC YE</span></span><br></pre></td></tr></table></figure>

<h2 id="4、集合与可空性"><a href="#4、集合与可空性" class="headerlink" title="4、集合与可空性"></a>4、集合与可空性</h2><p>集合的可空性可以分为三种：</p>
<ol>
<li>可以包含为 null 的集合元素</li>
<li>集合本身可以为 null</li>
<li>集合本身可以为 null，且可以包含为 null 的集合元素</li>
</ol>
<p>例如，intList1 可以包含为 null 的集合元素，但集合本身不能指向 null；intList2 不可以包含为 null 的集合元素，但集合本身可以指向 null；intList3 可以包含为 null 的集合元素，且集合本身能指向 null</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//List&lt;Int?&gt; 是能持有 Int? 类型值的列表</span></span><br><span class="line"><span class="keyword">val</span> intList1: List&lt;<span class="built_in">Int</span>?&gt; = listOf(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="literal">null</span>)</span><br><span class="line"><span class="comment">//List&lt;Int&gt;? 是可以为 null 的列表</span></span><br><span class="line"><span class="keyword">var</span> intList2: List&lt;<span class="built_in">Int</span>&gt;? = listOf(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line">intList2 = <span class="literal">null</span></span><br><span class="line"><span class="comment">//List&lt;Int?&gt;? 是可以为 null 的列表，且能持有 Int? 类型值</span></span><br><span class="line"><span class="keyword">var</span> intList3: List&lt;<span class="built_in">Int</span>?&gt;? = listOf(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="literal">null</span>)</span><br><span class="line">intList3 = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h1 id="十六、扩展函数和扩展属性"><a href="#十六、扩展函数和扩展属性" class="headerlink" title="十六、扩展函数和扩展属性"></a>十六、扩展函数和扩展属性</h1><h2 id="1、扩展函数"><a href="#1、扩展函数" class="headerlink" title="1、扩展函数"></a>1、扩展函数</h2><p>扩展函数用于为一个类增加一种新的行为，这是为缺少有用函数的类进行扩展的途径。扩展函数的用途就类似于在 Java 中实现的静态工具方法。而在 kotlin 中使用扩展函数的一个优势就是我们不需要在调用方法的时候把整个对象当作参数传入，扩展函数表现得就像是属于这个类本身的一样，可以使用 this 关键字并直接调用其所有 public 方法</p>
<p>扩展函数并不允许你打破它的封装性，和在类内部定义的方法不同的是，扩展函数不能访问私有的或是受保护的成员</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为 String 类声明一个扩展函数 lastChar() ，用于返回字符串的最后一个字符</span></span><br><span class="line"><span class="comment">//get方法是 String 类的内部方法，length 是 String 类的内部成员变量，在此处可以直接调用</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastChar</span><span class="params">()</span></span> = <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//为 Int 类声明一个扩展函数 doubleValue() ，用于返回其两倍值</span></span><br><span class="line"><span class="comment">//this 关键字代表了 Int 值本身</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">doubleValue</span><span class="params">()</span></span> = <span class="keyword">this</span> * <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>之后，我们就可以像调用类本身内部声明的方法一样，直接调用扩展函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">&quot;leavesC&quot;</span></span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$name</span> lastChar is: &quot;</span> + name.lastChar())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> age = <span class="number">24</span></span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$age</span> doubleValue is: &quot;</span> + age.doubleValue())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要声明一个静态的扩展函数，则必须将其定义在伴生对象上，这样就可以在没有 Namer 实例的情况下调用其扩展函数，就如同在调用 Java 的静态函数一样</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Namer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> defaultName = <span class="string">&quot;mike&quot;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Namer.Companion.<span class="title">getName</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> defaultName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Namer.getName()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果扩展函数声明于 class 内部，则该扩展函数只能该类和其子类内部调用，因为此时相当于声明了一个非静态函数，外部无法引用到。所以一般都是将扩展函数声明为全局函数</p>
<h2 id="2、扩展属性"><a href="#2、扩展属性" class="headerlink" title="2、扩展属性"></a>2、扩展属性</h2><p>扩展函数也可以用于属性</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩展函数也可以用于属性</span></span><br><span class="line"><span class="comment">//为 String 类新增一个属性值 customLen</span></span><br><span class="line"><span class="keyword">var</span> String.customLen: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = length</span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        println(<span class="string">&quot;set&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">&quot;leavesC&quot;</span></span><br><span class="line">    println(name.customLen)</span><br><span class="line">    name.customLen = <span class="number">10</span></span><br><span class="line">    println(name.customLen)</span><br><span class="line">    <span class="comment">//7</span></span><br><span class="line">    <span class="comment">//set</span></span><br><span class="line">    <span class="comment">//7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、不可重写的扩展函数"><a href="#3、不可重写的扩展函数" class="headerlink" title="3、不可重写的扩展函数"></a>3、不可重写的扩展函数</h2><p>看以下例子，子类 Button 重写了父类 View 的 click() 函数，此时如果声明一个 View 变量，并赋值为 Button 类型的对象，调用的 click() 函数将是 Button 类重写的方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> view: View = Button()</span><br><span class="line">    view.click() <span class="comment">//Button clicked</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> = println(<span class="string">&quot;View clicked&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span> : <span class="type">View</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> = println(<span class="string">&quot;Button clicked&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于扩展函数来说，与以上的例子却不一样。如果基类和子类都分别定义了一个同名的扩展函数，此时要调用哪个扩展函数是由变量的静态类型来决定的，而非这个变量的运行时类型</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> view: View = Button()</span><br><span class="line">    view.longClick() <span class="comment">//View longClicked</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> = println(<span class="string">&quot;View clicked&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span> : <span class="type">View</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> = println(<span class="string">&quot;Button clicked&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">longClick</span><span class="params">()</span></span> = println(<span class="string">&quot;View longClicked&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Button.<span class="title">longClick</span><span class="params">()</span></span> = println(<span class="string">&quot;Button longClicked&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>此外，如果一个类的成员函数和扩展函数有相同的签名，<strong>成员函数会被优先使用</strong></p>
<p>扩展函数并不是真正地修改了原来的类，其底层其实是以静态导入的方式来实现的。扩展函数可以被声明在任何一个文件中，因此有个通用的实践是把一系列有关的函数放在一个新建的文件里</p>
<p>需要注意的是，扩展函数不会自动地在整个项目范围内生效，如果需要使用到扩展函数，需要进行导入</p>
<h2 id="4、可空接收者"><a href="#4、可空接收者" class="headerlink" title="4、可空接收者"></a>4、可空接收者</h2><p>可以为可空的接收者类型定义扩展，即使接受者为 null，使得开发者在调用扩展函数前不必进行判空操作，且可以通过 <code>this == null</code> 来检查接收者是否为空</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String? = <span class="literal">null</span></span><br><span class="line">    name.check() <span class="comment">//this == null</span></span><br><span class="line">    name = <span class="string">&quot;leavesC&quot;</span></span><br><span class="line">    name.check() <span class="comment">//this != null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String?.<span class="title">check</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;this == null&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;this != null&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十七、Lambda-表达式"><a href="#十七、Lambda-表达式" class="headerlink" title="十七、Lambda 表达式"></a>十七、Lambda 表达式</h1><p>Lambda 表达式本质上就是可以传递给其它函数的一小段代码，通过 Lambda 表达式可以把通用的代码结构抽取成库函数，也可以把 Lambda 表达式存储在一个变量中，把这个变量当做普通函数对待</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于存在类型推导，所以以下三种声明方式都是完全相同的</span></span><br><span class="line"><span class="keyword">val</span> plus1: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123; x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; x + y &#125;</span><br><span class="line"><span class="keyword">val</span> plus2: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123; x, y -&gt; x + y &#125;</span><br><span class="line"><span class="keyword">val</span> plus3 = &#123; x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; x + y &#125;</span><br><span class="line">println(plus3(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<ol>
<li>一个 Lambda 表达式始终用花括号包围，通过箭头把实参列表和函数体分开</li>
<li>如果 Lambda 声明了函数类型，那么就可以省略函数体的类型声明</li>
<li>如果 Lambda 声明了参数类型，且返回值支持类型推导，那么就可以省略函数类型声明</li>
</ol>
<p>虽然说倾向于尽量避免让 Lambda 表达式引用外部变量以避免副作用，但有些情况下让 Lambda 引用外部变量也可以简化计算结构。访问了外部环境变量的 Lambda 表达式称之为闭包，闭包可以被当做参数传递或者直接使用。与 Java 不同，kotlin 中的闭包不仅可以访问外部变量也可以对其进行修改</p>
<p>例如，假设我们需要一个计算总和的方法，每次调用函数时都返回当前的总和大小。方法外部不提供保存当前总和的变量，由 Lambda 表达式内部进行存储</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> sum = sumFunc()</span><br><span class="line">    println(sum(<span class="number">10</span>)) <span class="comment">//10</span></span><br><span class="line">    println(sum(<span class="number">20</span>)) <span class="comment">//30</span></span><br><span class="line">    println(sum(<span class="number">30</span>)) <span class="comment">//60</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sumFunc</span><span class="params">()</span></span>: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> base = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="title">fun</span><span class="params">(va: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        base += va</span><br><span class="line">        <span class="keyword">return</span> base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，kotlin 也支持一种自动运行的语法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; va1: <span class="built_in">Int</span>, va2: <span class="built_in">Int</span> -&gt; println(va1 + va2) &#125;(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p>Lambda 表达式最常见的用途就是和集合一起工作，看以下例子</p>
<p>要从一个人员列表中取出年龄最大的一位</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> people = listOf(Person(<span class="string">&quot;leavesC&quot;</span>, <span class="number">24</span>), Person(<span class="string">&quot;Ye&quot;</span>, <span class="number">22</span>))</span><br><span class="line">    println(people.maxBy &#123; it.age &#125;) <span class="comment">//Person(name=leavesC, age=24)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当中，库函数 maxBy 可以在任何集合上调用，其需要一个实参：一个函数，用于指定要用来进行比较的函数。花括号中的代码 <code>&#123; it.age &#125;</code> 就是实现了这个逻辑的 Lambda 表达式</p>
<p>上述 maxBy 函数的实参是简化后的写法，这里来看下 maxBy 函数的简化过程</p>
<p>最原始的语法声明应该是这样的，用括号包裹着 Lambda 表达式</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(people.maxBy(&#123; p: Person -&gt; p.age &#125;))</span><br></pre></td></tr></table></figure>

<p>kotlin 有一种语法约定，如果 Lambda 表达式是函数调用的最后一个实参，可以将之放到括号的外边</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(people.maxBy() &#123; p: Person -&gt; p.age &#125;)</span><br></pre></td></tr></table></figure>

<p>当 Lamdba 表达式是函数唯一的实参时，可以去掉调用代码中的空括号对</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(people.maxBy &#123; p: Person -&gt; p.age &#125;)</span><br></pre></td></tr></table></figure>

<p>当 Lambda 表达式的参数类型是可以被推导出来时就可以省略声明参数类型</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(people.maxBy &#123; p -&gt; p.age &#125;)</span><br></pre></td></tr></table></figure>

<p>如果当前上下文期待的是只有一个参数的 Lambda 表达式且参数类型可以被推断出来，就会为该参数生成一个默认名称：it</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(people.maxBy &#123; it.age &#125;)</span><br></pre></td></tr></table></figure>

<p>kotlin 和 Java 的一个显著区别就是，在 kotlin 中函数内部的 Lambda 表达式不会仅限于访问函数的参数以及 final 变量，在 Lambda 内部也可以访问并修改非 final 变量</p>
<p>从 Lambda 内部访问外部变量，我们称这些变量被 Lambda 捕捉。当捕捉 final 变量时，变量值和使用这个值的 Lambda 代码一起存储，对非 final 变量来说，其值被封装在一个特殊的包装器中，对这个包装器的引用会和 Lambda 代码一起存储</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line">list.forEach &#123;</span><br><span class="line">    <span class="keyword">if</span> (it &gt; <span class="number">20</span>) &#123;</span><br><span class="line">        number++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">println(number) <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>成员引用用于创建一个调用单个方法或者访问单个属性的函数值，通过双冒号把类名称和要引用的成员（一个方法或者一个属性）名称分隔开</p>
<p>成员引用的一个用途就是：如果要当做参数传递的代码块已经被定义成了函数，此时不必专门创建一个调用该函数的 Lambda 表达式，可以直接通过成员引用的方式来传递该函数（也可以传递属性）。此外，成员引用对扩展函数一样适用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> myAge = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getPersonAge</span><span class="params">()</span></span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Person.<span class="title">filterAge</span><span class="params">()</span></span> = age</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> people = listOf(Person(<span class="string">&quot;leavesC&quot;</span>, <span class="number">24</span>), Person(<span class="string">&quot;Ye&quot;</span>, <span class="number">22</span>))</span><br><span class="line">    println(people.maxBy &#123; it.age &#125;)    <span class="comment">//Person(name=leavesC, age=24)</span></span><br><span class="line">    println(people.maxBy(Person::age))  <span class="comment">//Person(name=leavesC, age=24)</span></span><br><span class="line">    println(people.maxBy(Person::myAge))  <span class="comment">//Person(name=leavesC, age=24)</span></span><br><span class="line">    println(people.maxBy(Person::getPersonAge))  <span class="comment">//Person(name=leavesC, age=24)</span></span><br><span class="line">    println(people.maxBy(Person::filterAge))  <span class="comment">//Person(name=leavesC, age=24)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管引用的是函数还是属性，都不要在成员引用的名称后面加括号</p>
<p>此外，还可以引用顶层函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> t = ::test</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以用构造方法引用存储或者延期执行创建类实例的动作</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> createPerson = ::Person</span><br><span class="line">    <span class="keyword">val</span> person = createPerson(<span class="string">&quot;leavesC&quot;</span>, <span class="number">24</span>)</span><br><span class="line">    println(person)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十八、标准库中的扩展函数"><a href="#十八、标准库中的扩展函数" class="headerlink" title="十八、标准库中的扩展函数"></a>十八、标准库中的扩展函数</h1><p>kotlin 标准库中提供了几个比较实用的扩展函数，定义在 Standard 文件下</p>
<h2 id="1、run"><a href="#1、run" class="headerlink" title="1、run"></a>1、run</h2><p>run 函数接收一个函数参数并以该函数的返回值作为 run 函数的返回值</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">run</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用例</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nickName = <span class="string">&quot;leavesC&quot;</span></span><br><span class="line">    nickName = nickName.run &#123;</span><br><span class="line">        <span class="keyword">if</span> (isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(nickName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、with"><a href="#2、with" class="headerlink" title="2、with"></a>2、with</h2><p>with 函数并不是扩展函数，不过由于作用相近，此处就一起介绍了。with 函数的第一个参数是接受者对象 receiver，第二个参数是在 receiver 对象类型上定义的扩展函数，所以可以在函数内部直接调用 receiver 其公开的方法和属性</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">with</span><span class="params">(receiver: <span class="type">T</span>, block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> receiver.block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>with 函数用于对同一个对象执行多次操作而不需要反复把对象的名称写出来</p>
<p>例如，为了构建一个包含指定内容的字符串，需要先后如下调用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder()</span><br><span class="line">    result.append(<span class="string">&quot;leavesC&quot;</span>)</span><br><span class="line">    result.append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">        result.append(letter)</span><br><span class="line">    &#125;</span><br><span class="line">    println(result.toString())</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>改为通过 with 函数来构建的话会代码会简洁许多</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = with(StringBuilder()) &#123;</span><br><span class="line">    append(<span class="string">&quot;leavesC&quot;</span>)</span><br><span class="line">    append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">        append(letter)</span><br><span class="line">    &#125;</span><br><span class="line">    toString()</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure>

<p>with 函数是一个接受两个参数的函数，在这个例子中就是一个 StringBuilder 和一个 Lambda 表达式，这里利用了把 Lambda 表达式放在括号外的约定</p>
<p>with 函数的返回值是执行 Lambda 表达式的结果，该结果就是 Lambda 中的最后一个表达式的返回值，因此如果将代码修改为如下所示的话，因为 println() 方法无返回值，所以打印出来的内容将是 kotlin.Unit</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = with(StringBuilder()) &#123;</span><br><span class="line">    append(<span class="string">&quot;leavesC&quot;</span>)</span><br><span class="line">    append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">        append(letter)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(result)  <span class="comment">//kotin.Unit</span></span><br></pre></td></tr></table></figure>

<h2 id="3、apply"><a href="#3、apply" class="headerlink" title="3、apply"></a>3、apply</h2><p>apply 函数被声明为类型 T 的扩展函数，它的接收者是作为实参的 Lambda 的接受者，最终函数返回 this 即对象本身</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以apply 函数和 with 函数的唯一区别在于：apply 函数始终会返回作为实参传递给它的对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = StringBuilder().apply &#123;</span><br><span class="line">    append(<span class="string">&quot;leavesC&quot;</span>)</span><br><span class="line">    append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">        append(letter)</span><br><span class="line">    &#125;</span><br><span class="line">    toString()</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br><span class="line">println(result.javaClass) <span class="comment">//class java.lang.StringBuilder</span></span><br></pre></td></tr></table></figure>

<h2 id="4、also"><a href="#4、also" class="headerlink" title="4、also"></a>4、also</h2><p>also 函数接收一个函数类型的参数，该参数又以接收者本身作为参数，最终返回接收者对象本身</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.1&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">also</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用例</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> nickName = <span class="string">&quot;leavesC&quot;</span></span><br><span class="line">    <span class="keyword">val</span> also = nickName.also &#123;</span><br><span class="line">        it.length</span><br><span class="line">    &#125;</span><br><span class="line">    println(also) <span class="comment">//leavesC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、let"><a href="#5、let" class="headerlink" title="5、let"></a>5、let</h2><p>let 函数接收一个函数类型的参数，该参数又以接收者本身作为参数，最终返回函数的求值结果</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用例</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> nickName = <span class="string">&quot;leavesC&quot;</span></span><br><span class="line">    <span class="keyword">val</span> also = nickName.let &#123;</span><br><span class="line">        it.length</span><br><span class="line">    &#125;</span><br><span class="line">    println(also) <span class="comment">//7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、takeIf"><a href="#6、takeIf" class="headerlink" title="6、takeIf"></a>6、takeIf</h2><p>takeIf 接收一个返回值类型为 bool 的函数，当该参数返回值为 true 时返回接受者对象本身，否则返回 null</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.1&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">takeIf</span><span class="params">(predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: T? &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (predicate(<span class="keyword">this</span>)) <span class="keyword">this</span> <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用例</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(check(<span class="string">&quot;leavesC&quot;</span>)) <span class="comment">//7</span></span><br><span class="line">    println(check(<span class="literal">null</span>)) <span class="comment">//0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(name: <span class="type">String</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name.takeIf &#123; !it.isNullOrBlank() &#125;?.length ?: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、takeUnless"><a href="#7、takeUnless" class="headerlink" title="7、takeUnless"></a>7、takeUnless</h2><p>takeUnless 的判断条件与 takeIf 相反，这里不再赘述</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.1&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">takeUnless</span><span class="params">(predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: T? &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (!predicate(<span class="keyword">this</span>)) <span class="keyword">this</span> <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十九、函数操作符"><a href="#十九、函数操作符" class="headerlink" title="十九、函数操作符"></a>十九、函数操作符</h1><h2 id="1、总数操作符"><a href="#1、总数操作符" class="headerlink" title="1、总数操作符"></a>1、总数操作符</h2><h3 id="1、any"><a href="#1、any" class="headerlink" title="1、any"></a>1、any</h3><p>如果至少有一个元素符合给出的判断条件，则返回 true</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">println(list.any &#123; it &gt; <span class="number">13</span> &#125;)  <span class="comment">//false</span></span><br><span class="line">println(list.any &#123; it &gt; <span class="number">7</span> &#125;)   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="2、all"><a href="#2、all" class="headerlink" title="2、all"></a>2、all</h3><p>如果全部的元素符合给出的判断条件，则返回 true</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">println(list.all &#123; it &gt; <span class="number">13</span> &#125;)  <span class="comment">//false</span></span><br><span class="line">println(list.all &#123; it &gt; <span class="number">0</span> &#125;)   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="3、count"><a href="#3、count" class="headerlink" title="3、count"></a>3、count</h3><p>返回符合给出判断条件的元素总数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">println(list.count &#123; it &gt; <span class="number">7</span> &#125;)  <span class="comment">//1</span></span><br><span class="line">println(list.count &#123; it &gt; <span class="number">2</span> &#125;)  <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<h3 id="4、fold"><a href="#4、fold" class="headerlink" title="4、fold"></a>4、fold</h3><p>在一个初始值的基础上从第一项到最后一项通过一个函数累计所有的元素</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">    println(list.fold(<span class="number">2</span>) &#123; total, next-&gt;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$next</span> , <span class="variable">$total</span>&quot;</span>)</span><br><span class="line">        next + total</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> , <span class="number">2</span></span><br><span class="line"><span class="number">3</span> , <span class="number">3</span></span><br><span class="line"><span class="number">5</span> , <span class="number">6</span></span><br><span class="line"><span class="number">7</span> , <span class="number">11</span></span><br><span class="line"><span class="number">9</span> , <span class="number">18</span></span><br><span class="line"><span class="number">27</span></span><br></pre></td></tr></table></figure>

<h3 id="5、foldRight"><a href="#5、foldRight" class="headerlink" title="5、foldRight"></a>5、foldRight</h3><p>与 fold  一样，但顺序是从最后一项到第一项</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">println(list.foldRight(<span class="number">2</span>) &#123; next, total-&gt;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$next</span> , <span class="variable">$total</span>&quot;</span>)</span><br><span class="line">    next + total</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> , <span class="number">2</span></span><br><span class="line"><span class="number">7</span> , <span class="number">11</span></span><br><span class="line"><span class="number">5</span> , <span class="number">18</span></span><br><span class="line"><span class="number">3</span> , <span class="number">23</span></span><br><span class="line"><span class="number">1</span> , <span class="number">26</span></span><br><span class="line"><span class="number">27</span></span><br></pre></td></tr></table></figure>

<h3 id="6、forEach"><a href="#6、forEach" class="headerlink" title="6、forEach"></a>6、forEach</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">list.forEach &#123; print(it + <span class="number">1</span>) &#125; <span class="comment">//246810</span></span><br></pre></td></tr></table></figure>

<h3 id="7、forEachIndexed"><a href="#7、forEachIndexed" class="headerlink" title="7、forEachIndexed"></a>7、forEachIndexed</h3><p>类似于 forEach ，同时可以得到元素的索引</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">list.forEachIndexed &#123; index, value -&gt; println(<span class="string">&quot;<span class="variable">$index</span> value is <span class="variable">$value</span>&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> value <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> value <span class="keyword">is</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> value <span class="keyword">is</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> value <span class="keyword">is</span> <span class="number">7</span></span><br><span class="line"><span class="number">4</span> value <span class="keyword">is</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h3 id="8、max"><a href="#8、max" class="headerlink" title="8、max"></a>8、max</h3><p>返回最大的一项，如果没有则返回null</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">println(list.max()) <span class="comment">//9</span></span><br></pre></td></tr></table></figure>

<h3 id="9、maxBy"><a href="#9、maxBy" class="headerlink" title="9、maxBy"></a>9、maxBy</h3><p>根据给定的函数返回最大的一项，如果没有则返回 null</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">println(list.maxBy &#123; -it &#125;) <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h3 id="10、min"><a href="#10、min" class="headerlink" title="10、min"></a>10、min</h3><p>返回最小的一项，如果没有则返回null</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">println(list.min()) <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h3 id="11、minBy"><a href="#11、minBy" class="headerlink" title="11、minBy"></a>11、minBy</h3><p>根据给定的函数返回最小的一项，如果没有则返回null</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">println(list.minBy &#123; -it &#125;) <span class="comment">//9</span></span><br></pre></td></tr></table></figure>

<h3 id="12、none"><a href="#12、none" class="headerlink" title="12、none"></a>12、none</h3><p>如果没有任何元素与给定的函数匹配，则返回true</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">println(list.none &#123; it &gt; <span class="number">10</span> &#125;) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="13、reduce"><a href="#13、reduce" class="headerlink" title="13、reduce"></a>13、reduce</h3><p>与 fold  一样，但是没有一个初始值。通过一个函数从第一项到最后一项进行累计</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">println(list.reduce &#123; total, next -&gt;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$next</span> , <span class="variable">$total</span>&quot;</span>)</span><br><span class="line">    total + next</span><br><span class="line">&#125;)</span><br><span class="line"><span class="number">3</span> , <span class="number">1</span></span><br><span class="line"><span class="number">5</span> , <span class="number">4</span></span><br><span class="line"><span class="number">7</span> , <span class="number">9</span></span><br><span class="line"><span class="number">9</span> , <span class="number">16</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure>

<h3 id="14、reduceRight"><a href="#14、reduceRight" class="headerlink" title="14、reduceRight"></a>14、reduceRight</h3><p>与 reduce  一样，但是顺序是从最后一项到第一项</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">println(list.reduceRight &#123; next, total -&gt;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$next</span> , <span class="variable">$total</span>&quot;</span>)</span><br><span class="line">    total + next</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="number">7</span> , <span class="number">9</span></span><br><span class="line"><span class="number">5</span> , <span class="number">16</span></span><br><span class="line"><span class="number">3</span> , <span class="number">21</span></span><br><span class="line"><span class="number">1</span> , <span class="number">24</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure>

<h3 id="15、sumBy"><a href="#15、sumBy" class="headerlink" title="15、sumBy"></a>15、sumBy</h3><p>返回所有每一项通过函数转换之后的数据的总和</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">println(list.sumBy &#123; it + <span class="number">1</span> &#125;) <span class="comment">//30</span></span><br></pre></td></tr></table></figure>

<h2 id="2、过滤操作符"><a href="#2、过滤操作符" class="headerlink" title="2、过滤操作符"></a>2、过滤操作符</h2><h3 id="1、drop"><a href="#1、drop" class="headerlink" title="1、drop"></a>1、drop</h3><p>返回包含去掉前n个元素的所有元素的列表</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">println(list.drop(<span class="number">2</span>)) <span class="comment">//[5, 7, 9]</span></span><br></pre></td></tr></table></figure>

<h3 id="2、dropWhile"><a href="#2、dropWhile" class="headerlink" title="2、dropWhile"></a>2、dropWhile</h3><p>返回从第一个开始不符合给定函数的元素起之后的列表</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line">println(list.dropWhile &#123; it &lt; <span class="number">4</span> &#125;) <span class="comment">//[5, 7, 9, 2]</span></span><br></pre></td></tr></table></figure>

<h3 id="3、dropLastWhile"><a href="#3、dropLastWhile" class="headerlink" title="3、dropLastWhile"></a>3、dropLastWhile</h3><p>从最后一项开始，返回从开始不符合给定函数的元素起之后的列表</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">println(list.dropLastWhile &#123; it &gt; <span class="number">4</span> &#125;) <span class="comment">//[10, 1, 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="4、filter"><a href="#4、filter" class="headerlink" title="4、filter"></a>4、filter</h3><p>过滤所有符合给定函数条件的元素</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line">println(list.filter &#123; it &lt; <span class="number">4</span> &#125;) <span class="comment">//[1, 3, 2]</span></span><br></pre></td></tr></table></figure>

<h3 id="5、filterNot"><a href="#5、filterNot" class="headerlink" title="5、filterNot"></a>5、filterNot</h3><p>过滤所有不符合给定函数条件的元素</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line">println(list.filterNot &#123; it &lt; <span class="number">4</span> &#125;) <span class="comment">//[5, 7, 9]</span></span><br></pre></td></tr></table></figure>

<h3 id="6、filterNotNull"><a href="#6、filterNotNull" class="headerlink" title="6、filterNotNull"></a>6、filterNotNull</h3><p>过滤所有元素中不是null的元素</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="literal">null</span>)</span><br><span class="line">println(list.filterNotNull()) <span class="comment">//[1, 3, 5, 7, 9, 2]</span></span><br></pre></td></tr></table></figure>

<h3 id="7、slice"><a href="#7、slice" class="headerlink" title="7、slice"></a>7、slice</h3><p>过滤一个list中指定index的元素</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="literal">null</span>)</span><br><span class="line">println(list.slice(listOf(<span class="number">0</span>, <span class="number">3</span>))) <span class="comment">//[1, 7]</span></span><br></pre></td></tr></table></figure>

<h3 id="8、take"><a href="#8、take" class="headerlink" title="8、take"></a>8、take</h3><p>返回从第一个开始的n个元素</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="literal">null</span>)</span><br><span class="line">println(list.take(<span class="number">2</span>)) <span class="comment">//[1, 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="9、takeLast"><a href="#9、takeLast" class="headerlink" title="9、takeLast"></a>9、takeLast</h3><p>返回从最后一个开始的n个元素</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="literal">null</span>)</span><br><span class="line">println(list.takeLast(<span class="number">2</span>)) <span class="comment">//[2, null]</span></span><br></pre></td></tr></table></figure>

<h3 id="10、takeWhile"><a href="#10、takeWhile" class="headerlink" title="10、takeWhile"></a>10、takeWhile</h3><p>返回从第一个开始符合给定函数条件的元素。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line">println(list.takeWhile &#123; it &gt; <span class="number">2</span> &#125;) <span class="comment">//[]</span></span><br><span class="line">println(list.takeWhile &#123; it &gt; <span class="number">0</span> &#125;) <span class="comment">//[1, 3, 5]</span></span><br></pre></td></tr></table></figure>

<h2 id="3、映射操作符"><a href="#3、映射操作符" class="headerlink" title="3、映射操作符"></a>3、映射操作符</h2><h3 id="1、flatMap"><a href="#1、flatMap" class="headerlink" title="1、flatMap"></a>1、flatMap</h3><p>遍历所有的元素，为每一个创建一个集合，最后把所有的集合放在一个集合中</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line">println(list.flatMap &#123; listOf(it, it + <span class="number">1</span>) &#125;) <span class="comment">//[1, 2, 3, 4, 5, 6, -1, 0, 7, 8, 9, 10, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="2、groupBy"><a href="#2、groupBy" class="headerlink" title="2、groupBy"></a>2、groupBy</h3><p>返回一个根据给定函数分组后的map </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line">println(list.groupBy &#123; listOf(it) &#125;) <span class="comment">//&#123;[1]=[1], [3]=[3], [5]=[5], [-1]=[-1], [7]=[7], [9]=[9], [2]=[2]&#125;</span></span><br><span class="line">println(list.groupBy &#123; listOf(it, it + <span class="number">1</span>) &#125;) <span class="comment">//&#123;[1, 2]=[1], [3, 4]=[3], [5, 6]=[5], [-1, 0]=[-1], [7, 8]=[7], [9, 10]=[9], [2, 3]=[2]&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="3、map"><a href="#3、map" class="headerlink" title="3、map"></a>3、map</h3><p>返回一个每一个元素根据给定的函数转换所组成的List。 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line">println(list.map &#123; listOf(it) &#125;) <span class="comment">//[[1], [3], [5], [-1], [7], [9], [2]]</span></span><br><span class="line">println(list.map &#123; listOf(it, it + <span class="number">1</span>) &#125;) <span class="comment">//[[1, 2], [3, 4], [5, 6], [-1, 0], [7, 8], [9, 10], [2, 3]]</span></span><br></pre></td></tr></table></figure>

<h3 id="4、mapIndexed"><a href="#4、mapIndexed" class="headerlink" title="4、mapIndexed"></a>4、mapIndexed</h3><p>返回一个每一个元素根据给定的包含元素index的函数转换所组成的List</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line">println(list.mapIndexed &#123; index, value -&gt; index &#125;) <span class="comment">//[0, 1, 2, 3, 4, 5, 6]</span></span><br><span class="line">println(list.mapIndexed &#123; index, value -&gt; index * value &#125;) <span class="comment">//[0, 3, 10, -3, 28, 45, 12]</span></span><br></pre></td></tr></table></figure>

<h3 id="5、mapNotNull"><a href="#5、mapNotNull" class="headerlink" title="5、mapNotNull"></a>5、mapNotNull</h3><p>返回一个每一个非null元素根据给定的函数转换所组成的List</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line">println(list.mapNotNull &#123; it &#125;) <span class="comment">//[1, 3, 5, -1, 7, 9, 2]</span></span><br></pre></td></tr></table></figure>

<h2 id="4、元素操作符"><a href="#4、元素操作符" class="headerlink" title="4、元素操作符"></a>4、元素操作符</h2><h3 id="1、contains"><a href="#1、contains" class="headerlink" title="1、contains"></a>1、contains</h3><p>如果指定元素可以在集合中找到，则返回true</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line">println(list.contains(<span class="number">3</span>)) <span class="comment">//true</span></span><br><span class="line">println(list.contains(<span class="number">13</span>)) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="2、elementAt"><a href="#2、elementAt" class="headerlink" title="2、elementAt"></a>2、elementAt</h3><p>返回给定index对应的元素，如果index数组越界则会抛出 IndexOutOfBoundsException</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line">println(list.elementAt(<span class="number">3</span>)) <span class="comment">//-1</span></span><br><span class="line">println(list.elementAt(<span class="number">6</span>)) <span class="comment">//null</span></span><br></pre></td></tr></table></figure>

<h3 id="3、elementAtOrElse"><a href="#3、elementAtOrElse" class="headerlink" title="3、elementAtOrElse"></a>3、elementAtOrElse</h3><p>返回给定index对应的元素，如果index数组越界则会根据给定函数返回默认值</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line">println(list.elementAtOrElse(<span class="number">3</span>, &#123; it * <span class="number">2</span> &#125;))  <span class="comment">//-1</span></span><br><span class="line">println(list.elementAtOrElse(<span class="number">16</span>, &#123; it * <span class="number">2</span> &#125;)) <span class="comment">//32</span></span><br></pre></td></tr></table></figure>

<h3 id="4、elementAtOrNull"><a href="#4、elementAtOrNull" class="headerlink" title="4、elementAtOrNull"></a>4、elementAtOrNull</h3><p>返回给定index对应的元素，如果index数组越界则会返回null</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line">println(list.elementAtOrNull(<span class="number">3</span>))  <span class="comment">//-1</span></span><br><span class="line">println(list.elementAtOrNull(<span class="number">16</span>)) <span class="comment">//null</span></span><br></pre></td></tr></table></figure>

<h3 id="5、first"><a href="#5、first" class="headerlink" title="5、first"></a>5、first</h3><p>返回符合给定函数条件的第一个元素</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line">println(list.first &#123; it % <span class="number">3</span> == <span class="number">0</span> &#125;)  <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<h3 id="6、firstOrNull"><a href="#6、firstOrNull" class="headerlink" title="6、firstOrNull"></a>6、firstOrNull</h3><p>返回符合给定函数条件的第一个元素，如果没有符合则返回null</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line">println(list.firstOrNull &#123; it % <span class="number">3</span> == <span class="number">0</span> &#125;)  <span class="comment">//3</span></span><br><span class="line">println(list.firstOrNull &#123; it % <span class="number">8</span> == <span class="number">0</span> &#125;)  <span class="comment">//null</span></span><br></pre></td></tr></table></figure>

<h3 id="7、indexOf"><a href="#7、indexOf" class="headerlink" title="7、indexOf"></a>7、indexOf</h3><p>返回指定元素的第一个index，如果不存在，则返回 -1</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line">println(list.indexOf(<span class="number">5</span>))  <span class="comment">//2</span></span><br><span class="line">println(list.indexOf(<span class="number">12</span>)) <span class="comment">//-1</span></span><br></pre></td></tr></table></figure>

<h3 id="8、indexOfFirst"><a href="#8、indexOfFirst" class="headerlink" title="8、indexOfFirst"></a>8、indexOfFirst</h3><p>返回第一个符合给定函数条件的元素的index，如果没有符合则返回 -1</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line">println(list.indexOfFirst &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;)   <span class="comment">//6</span></span><br><span class="line">println(list.indexOfFirst &#123; it % <span class="number">12</span> == <span class="number">0</span> &#125;)  <span class="comment">//-1</span></span><br></pre></td></tr></table></figure>

<h3 id="9、indexOfLast"><a href="#9、indexOfLast" class="headerlink" title="9、indexOfLast"></a>9、indexOfLast</h3><p>返回最后一个符合给定函数条件的元素的index，如果没有符合则返回 -1</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line">println(list.indexOfLast &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;)   <span class="comment">//6</span></span><br><span class="line">println(list.indexOfLast &#123; it % <span class="number">12</span> == <span class="number">0</span> &#125;)  <span class="comment">//-1</span></span><br></pre></td></tr></table></figure>

<h3 id="10、last"><a href="#10、last" class="headerlink" title="10、last"></a>10、last</h3><p>返回符合给定函数条件的最后一个元素</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line">println(list.last &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;)   <span class="comment">//2</span></span><br><span class="line">println(list.last &#123; it % <span class="number">3</span> == <span class="number">0</span> &#125;)   <span class="comment">//9</span></span><br></pre></td></tr></table></figure>

<h3 id="11、lastIndexOf"><a href="#11、lastIndexOf" class="headerlink" title="11、lastIndexOf"></a>11、lastIndexOf</h3><p>返回指定元素的最后一个index，如果不存在，则返回 -1</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line">println(list.lastIndexOf(<span class="number">2</span>))    <span class="comment">//6</span></span><br><span class="line">println(list.lastIndexOf(<span class="number">12</span>))   <span class="comment">//-1</span></span><br></pre></td></tr></table></figure>

<h3 id="12、lastOrNull"><a href="#12、lastOrNull" class="headerlink" title="12、lastOrNull"></a>12、lastOrNull</h3><p>返回符合给定函数条件的最后一个元素，如果没有符合则返回null</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line">println(list.lastOrNull &#123; it / <span class="number">3</span> == <span class="number">3</span> &#125;)    <span class="comment">//9</span></span><br><span class="line">println(list.lastOrNull &#123; it == <span class="number">10</span> &#125;)       <span class="comment">//null</span></span><br></pre></td></tr></table></figure>

<h3 id="13、single"><a href="#13、single" class="headerlink" title="13、single"></a>13、single</h3><p>返回符合给定函数的单个元素，如果没有符合或者超过一个，则抛出异常</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line">println(list.single &#123; it % <span class="number">7</span> == <span class="number">0</span> &#125;)  <span class="comment">//7</span></span><br><span class="line">println(list.single &#123; it == <span class="number">2</span> &#125;)      <span class="comment">//IllegalArgumentException</span></span><br></pre></td></tr></table></figure>

<h3 id="14、singleOrNull"><a href="#14、singleOrNull" class="headerlink" title="14、singleOrNull"></a>14、singleOrNull</h3><p>返回符合给定函数的单个元素，如果没有符合或者超过一个，则返回null</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line">println(list.singleOrNull &#123; it % <span class="number">7</span> == <span class="number">0</span> &#125;)  <span class="comment">//7</span></span><br><span class="line">println(list.singleOrNull &#123; it == <span class="number">2</span> &#125;)      <span class="comment">//null</span></span><br></pre></td></tr></table></figure>

<h2 id="5、生产操作符"><a href="#5、生产操作符" class="headerlink" title="5、生产操作符"></a>5、生产操作符</h2><h3 id="1、partition"><a href="#1、partition" class="headerlink" title="1、partition"></a>1、partition</h3><p>把一个给定的集合分割成两个，第一个集合是由原集合每一项元素匹配给定函数条 件返回 true 的元素组成，第二个集合是由原集合每一项元素匹配给定函数条件返回 false 的元素组成</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> (list1, list2) = list.partition &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line">println(list1)  <span class="comment">//[2, 6, 2]</span></span><br><span class="line">println(list2)  <span class="comment">//[1, 9, 7, 9]</span></span><br></pre></td></tr></table></figure>

<h3 id="2、plus"><a href="#2、plus" class="headerlink" title="2、plus"></a>2、plus</h3><p>返回一个包含原集合和给定集合中所有元素的集合，因为函数的名字原因，我们可以使用 + 操作符</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list1 = listOf(<span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> list2 = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>)</span><br><span class="line">println(list1.plus(list2)) <span class="comment">//[1, 9, 2, 6, 7, 9, 2, 1, 2, 4, 6, 8, 10]</span></span><br><span class="line">println(list1 + list2)  <span class="comment">//[1, 9, 2, 6, 7, 9, 2, 1, 2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>

<h3 id="3、zip"><a href="#3、zip" class="headerlink" title="3、zip"></a>3、zip</h3><p>返回由 pair 组成的List，每个 pair 由两个集合中相同index的元素组成。这个返回的List的大小由最小的那个集合决定</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list1 = listOf(<span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> list2 = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">val</span> list3 = list1.zip(list2)</span><br><span class="line">println(list3.javaClass)</span><br><span class="line">println(list3.<span class="keyword">get</span>(<span class="number">0</span>).javaClass)</span><br><span class="line">println(<span class="string">&quot;<span class="subst">$&#123;list3.get(<span class="number">0</span>).first&#125;</span> , <span class="subst">$&#123;list3.get(<span class="number">0</span>).second&#125;</span>&quot;</span>)</span><br><span class="line">list3.forEach &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.<span class="title">util</span>.<span class="title">ArrayList</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">kotlin</span>.<span class="title">Pair</span></span><br><span class="line"><span class="number">1</span> , <span class="number">1</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">6</span>, <span class="number">6</span>)</span><br><span class="line">(<span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">(<span class="number">9</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4、unzip"><a href="#4、unzip" class="headerlink" title="4、unzip"></a>4、unzip</h3><p>从包含pair的List中生成包含List的Pair</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list1 = listOf(Pair(<span class="string">&quot;leavesC&quot;</span>, <span class="number">1</span>), Pair(<span class="string">&quot;leavesC_2&quot;</span>, <span class="number">2</span>), Pair(<span class="string">&quot;leavesC_3&quot;</span>, <span class="number">3</span>))</span><br><span class="line"><span class="keyword">val</span> list2 = list1.unzip()</span><br><span class="line">println(list2.javaClass)</span><br><span class="line">println(list2.first)</span><br><span class="line">println(list2.second)</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">kotlin</span>.<span class="title">Pair</span></span><br><span class="line">[leavesC, leavesC_2, leavesC_3]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h2 id="6、顺序操作符"><a href="#6、顺序操作符" class="headerlink" title="6、顺序操作符"></a>6、顺序操作符</h2><h3 id="1、reverse"><a href="#1、reverse" class="headerlink" title="1、reverse"></a>1、reverse</h3><p>返回一个与指定list相反顺序的list</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list1 = listOf(Pair(<span class="string">&quot;leavesC&quot;</span>, <span class="number">1</span>), Pair(<span class="string">&quot;leavesC_2&quot;</span>, <span class="number">2</span>), Pair(<span class="string">&quot;leavesC_3&quot;</span>, <span class="number">3</span>))</span><br><span class="line"><span class="keyword">val</span> list2 = list1.reversed()</span><br><span class="line">println(list2)      <span class="comment">//[(leavesC_3, 3), (leavesC_2, 2), (leavesC, 1)]</span></span><br></pre></td></tr></table></figure>

<h3 id="2、sort"><a href="#2、sort" class="headerlink" title="2、sort"></a>2、sort</h3><p>返回一个自然排序后的list</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list1 = listOf(<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">val</span> list2 = list1.sorted()</span><br><span class="line">println(list2) <span class="comment">//[1, 2, 4, 5, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list3 = listOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;ab&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;cdd&quot;</span>, <span class="string">&quot;cda&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> list4 = list3.sorted()</span><br><span class="line">println(list4) <span class="comment">//[a, ab, b, c, cda, cdd]</span></span><br></pre></td></tr></table></figure>

<h3 id="3、sortBy"><a href="#3、sortBy" class="headerlink" title="3、sortBy"></a>3、sortBy</h3><p>返回一个根据指定函数排序后的list </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list1 = listOf(<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">val</span> list2 = list1.sortedBy &#123; it - <span class="number">3</span> &#125;</span><br><span class="line">println(list2) <span class="comment">//[1, 2, 4, 5, 9, 10]</span></span><br></pre></td></tr></table></figure>

<h3 id="4、sortDescending"><a href="#4、sortDescending" class="headerlink" title="4、sortDescending"></a>4、sortDescending</h3><p>返回一个降序排序后的List</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list1 = listOf(<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">val</span> list2 = list1.sortedDescending()</span><br><span class="line">println(list2) <span class="comment">//[10, 9, 5, 4, 2, 1]</span></span><br></pre></td></tr></table></figure>

<h3 id="5、sortDescendingBy"><a href="#5、sortDescendingBy" class="headerlink" title="5、sortDescendingBy"></a>5、sortDescendingBy</h3><p>返回一个根据指定函数降序排序后的list</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list1 = listOf(<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">val</span> list2 = list1.sortedByDescending &#123; it % <span class="number">2</span> &#125;</span><br><span class="line">println(list2) <span class="comment">//[1, 9, 5, 2, 4, 10]</span></span><br></pre></td></tr></table></figure>

<h1 id="二十、异常"><a href="#二十、异常" class="headerlink" title="二十、异常"></a>二十、异常</h1><p>kotlin 中异常处理的基本形式和 Java 类似</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compute</span><span class="params">(index: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index !<span class="keyword">in</span> <span class="number">0.</span><span class="number">.10</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;参数错误&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和 Java 不同的是，kotlin 中 throw 结构是一个表达式，可以作为另一个表达式的一部分来使用</p>
<p>例如下面这个例子，如果条件不满足，则将抛出异常，从而导致 status 变量也不会初始化</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> status = <span class="keyword">if</span> (index <span class="keyword">in</span> <span class="number">0.</span><span class="number">.10</span>) index <span class="keyword">else</span> <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;参数错误&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>此外，在 Java 中对于受检异常必须显式地处理，通过 try&#x2F;catch 语句捕获异常或者是抛给其调用者来处理。而 kotlin 不区分受检异常和未受检异常，不用指定函数抛出的异常，可以处理也可以不处理异常</p>
<p>在 kotlin 中 ，try 关键字引入了一个表达式，从而可以把表达式的值赋给一个变量。如果一个 try 代码块执行正常，代码块中最后一个表达式就是结果，如果捕获到了一个异常，则相应 catch 代码块中最后一个表达式就是结果</p>
<p>看以下例子，如果 try 表达式包裹的表达式会抛出异常，则返回值为 null ，否则为 true </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    compute(<span class="number">5</span>)   <span class="comment">//fun end : true</span></span><br><span class="line">    compute(<span class="number">100</span>) <span class="comment">//fun end : null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compute</span><span class="params">(index: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> status = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index <span class="keyword">in</span> <span class="number">0.</span><span class="number">.10</span>) <span class="literal">true</span> <span class="keyword">else</span> <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;参数错误&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;fun end : &quot;</span> + status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，如果在 catch 语句中使用 return 结束了 compute 函数，则没有任何输出</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    compute(<span class="number">5</span>)   <span class="comment">//fun end : true</span></span><br><span class="line">    compute(<span class="number">100</span>) <span class="comment">//没有任何输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compute</span><span class="params">(index: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> status = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index <span class="keyword">in</span> <span class="number">0.</span><span class="number">.10</span>) <span class="literal">true</span> <span class="keyword">else</span> <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;参数错误&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;fun end : &quot;</span> + status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二十一、运算符重载"><a href="#二十一、运算符重载" class="headerlink" title="二十一、运算符重载"></a>二十一、运算符重载</h1><p>kotlin 允许为类型提供预定义的操作符实现，这些操作符具有固定的符号表示（例如 + 和 * ）和固定的优先级，通过操作符重载可以将操作符的行为映射到指定的方法。为实现这样的操作符，需要为类提供一个固定名字的成员函数或扩展函数，相应的重载操作符的函数需要用 operator 修饰符标记</p>
<h2 id="1、一元操作符"><a href="#1、一元操作符" class="headerlink" title="1、一元操作符"></a>1、一元操作符</h2><table>
<thead>
<tr>
<th>操作符</th>
<th align="center">函数</th>
</tr>
</thead>
<tbody><tr>
<td>+a</td>
<td align="center">a.unaryPlus()</td>
</tr>
<tr>
<td>-a</td>
<td align="center">a.unaryMinus()</td>
</tr>
<tr>
<td>!a</td>
<td align="center">a.not()</td>
</tr>
<tr>
<td>a++</td>
<td align="center">a.inc()</td>
</tr>
<tr>
<td>a–</td>
<td align="center">a.dec()</td>
</tr>
</tbody></table>
<h2 id="2、二元操作符"><a href="#2、二元操作符" class="headerlink" title="2、二元操作符"></a>2、二元操作符</h2><table>
<thead>
<tr>
<th>操作符</th>
<th align="center">函数</th>
</tr>
</thead>
<tbody><tr>
<td>a + b</td>
<td align="center">a.plus(b)</td>
</tr>
<tr>
<td>a - b</td>
<td align="center">a.minus(b)</td>
</tr>
<tr>
<td>a * b</td>
<td align="center">a.times(b)</td>
</tr>
<tr>
<td>a &#x2F; b</td>
<td align="center">a.div(b)</td>
</tr>
<tr>
<td>a % b</td>
<td align="center">a.rem(b)</td>
</tr>
<tr>
<td>a..b</td>
<td align="center">a.rangeTo(b)</td>
</tr>
<tr>
<td>a in b</td>
<td align="center">b.contains(a)</td>
</tr>
<tr>
<td>a !in b</td>
<td align="center">!b.contains(a)</td>
</tr>
<tr>
<td>a +&#x3D; b</td>
<td align="center">a.plusAssign(b)</td>
</tr>
<tr>
<td>a -&#x3D; b</td>
<td align="center">a.minusAssign(b)</td>
</tr>
<tr>
<td>a *&#x3D; b</td>
<td align="center">a.timesAssign(b)</td>
</tr>
<tr>
<td>a &#x2F;&#x3D; b</td>
<td align="center">a.divAssign(b)</td>
</tr>
<tr>
<td>a %&#x3D; b</td>
<td align="center">a.remAssign(b)</td>
</tr>
</tbody></table>
<h2 id="3、数组操作符"><a href="#3、数组操作符" class="headerlink" title="3、数组操作符"></a>3、数组操作符</h2><table>
<thead>
<tr>
<th>操作符</th>
<th align="center">函数</th>
</tr>
</thead>
<tbody><tr>
<td>a[i]</td>
<td align="center">a.get(i)</td>
</tr>
<tr>
<td>a[i, j]</td>
<td align="center">a.get(i, j)</td>
</tr>
<tr>
<td>a[i_1, …, i_n]</td>
<td align="center">a.get(i_1, …, i_n)</td>
</tr>
<tr>
<td>a[i] &#x3D; b</td>
<td align="center">a.set(i, b)</td>
</tr>
<tr>
<td>a[i, j] &#x3D; b</td>
<td align="center">a.set(i, j, b)</td>
</tr>
<tr>
<td>a[i_1, …, i_n] &#x3D; b</td>
<td align="center">a.set(i_1, …, i_n, b)</td>
</tr>
</tbody></table>
<h2 id="4、等于操作符"><a href="#4、等于操作符" class="headerlink" title="4、等于操作符"></a>4、等于操作符</h2><table>
<thead>
<tr>
<th>操作符</th>
<th align="center">函数</th>
</tr>
</thead>
<tbody><tr>
<td>a &#x3D;&#x3D; b</td>
<td align="center">a?.equals(b) ?: b &#x3D;&#x3D;&#x3D; null</td>
</tr>
<tr>
<td>a !&#x3D; b</td>
<td align="center">!(a?.equals(b) ?: b &#x3D;&#x3D;&#x3D; null)</td>
</tr>
</tbody></table>
<p>相等操作符有一点不同，为了达到正确合适的相等检查做了更复杂的转换，因为要得到一个确切的函数结构比较，不仅仅是指定的名称</p>
<p>方法必须要如下准确地被实现：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span></span><br></pre></td></tr></table></figure>

<p>操作符 &#x3D;&#x3D;&#x3D;  和 !&#x3D;&#x3D;  用来做身份检查（它们分别是 Java 中的 &#x3D;&#x3D;  和 !&#x3D;  ），并且它们不能被重载</p>
<h2 id="5、比较操作符"><a href="#5、比较操作符" class="headerlink" title="5、比较操作符"></a>5、比较操作符</h2><table>
<thead>
<tr>
<th>操作符</th>
<th align="center">函数</th>
</tr>
</thead>
<tbody><tr>
<td>a &gt; b</td>
<td align="center">a.compareTo(b) &gt; 0</td>
</tr>
<tr>
<td>a &lt; b</td>
<td align="center">a.compareTo(b) &lt; 0</td>
</tr>
<tr>
<td>a &gt;&#x3D; b</td>
<td align="center">a.compareTo(b) &gt;&#x3D; 0</td>
</tr>
<tr>
<td>a &lt;&#x3D; b</td>
<td align="center">a.compareTo(b) &lt;&#x3D; 0</td>
</tr>
</tbody></table>
<p>所有的比较都转换为对  compareTo  的调用，这个函数需要返回  Int  值</p>
<h2 id="6、函数调用"><a href="#6、函数调用" class="headerlink" title="6、函数调用"></a>6、函数调用</h2><table>
<thead>
<tr>
<th>方法</th>
<th align="center">调用</th>
</tr>
</thead>
<tbody><tr>
<td>a()</td>
<td align="center">a.invoke()</td>
</tr>
<tr>
<td>a(i)</td>
<td align="center">a.invoke(i)</td>
</tr>
<tr>
<td>a(i, j)</td>
<td align="center">a.invoke(i, j)</td>
</tr>
<tr>
<td>a(i_1, …, i_n)</td>
<td align="center">a.invoke(i_1, …, i_n)</td>
</tr>
</tbody></table>
<h2 id="7、例子"><a href="#7、例子" class="headerlink" title="7、例子"></a>7、例子</h2><p>看几个例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Point</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//+Point</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">unaryPlus</span><span class="params">()</span></span> = Point(+x, +y)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Point++ / ++Point</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">inc</span><span class="params">()</span></span> = Point(x + <span class="number">1</span>, y + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Point + Point</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(point: <span class="type">Point</span>)</span></span> = Point(x + point.x, y + point.y)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Point + Int</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(value: <span class="type">Int</span>)</span></span> = Point(x + value, y + value)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Point[index]</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> (index) &#123;</span><br><span class="line">            <span class="number">0</span> -&gt; x</span><br><span class="line">            <span class="number">1</span> -&gt; y</span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IndexOutOfBoundsException(<span class="string">&quot;无效索引&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Point(index)</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(index: <span class="type">Int</span>)</span></span> = <span class="keyword">when</span> (index) &#123;</span><br><span class="line">        <span class="number">0</span> -&gt; x</span><br><span class="line">        <span class="number">1</span> -&gt; y</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IndexOutOfBoundsException(<span class="string">&quot;无效索引&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//+Point(x=10, y=-20)  =  Point(x=10, y=-20)</span></span><br><span class="line">    println(<span class="string">&quot;+<span class="subst">$&#123;Point(<span class="number">10</span>, <span class="number">-20</span>)&#125;</span>  =  <span class="subst">$&#123;+Point(<span class="number">10</span>, <span class="number">-20</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Point(x=10, y=-20)++  =  Point(x=10, y=-20)</span></span><br><span class="line">    <span class="keyword">var</span> point = Point(<span class="number">10</span>, -<span class="number">20</span>)</span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;Point(<span class="number">10</span>, <span class="number">-20</span>)&#125;</span>++  =  <span class="subst">$&#123;point++&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//++Point(x=10, y=-20)  =  Point(x=11, y=-19)</span></span><br><span class="line">    point = Point(<span class="number">10</span>, -<span class="number">20</span>)</span><br><span class="line">    println(<span class="string">&quot;++<span class="subst">$&#123;Point(<span class="number">10</span>, <span class="number">-20</span>)&#125;</span>  =  <span class="subst">$&#123;++point&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Point(x=10, y=-20) + Point(x=10, y=-20)  =  Point(x=20, y=-40)</span></span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;Point(<span class="number">10</span>, <span class="number">-20</span>)&#125;</span> + <span class="subst">$&#123;Point(<span class="number">10</span>, <span class="number">-20</span>)&#125;</span>  =  <span class="subst">$&#123;Point(<span class="number">10</span>, <span class="number">-20</span>) + Point(<span class="number">10</span>, <span class="number">-20</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Point(x=10, y=-20) + 5  =  Point(x=15, y=-15)</span></span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;Point(<span class="number">10</span>, <span class="number">-20</span>)&#125;</span> + <span class="subst">$&#123;<span class="number">5</span>&#125;</span>  =  <span class="subst">$&#123;Point(<span class="number">10</span>, <span class="number">-20</span>) + <span class="number">5</span>&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    point = Point(<span class="number">10</span>, -<span class="number">20</span>)</span><br><span class="line">    <span class="comment">//point[0] value is: 10</span></span><br><span class="line">    println(<span class="string">&quot;point[0] value is: <span class="subst">$&#123;point[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment">//point[1] value is: -20</span></span><br><span class="line">    println(<span class="string">&quot;point[1] value is: <span class="subst">$&#123;point[<span class="number">1</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//point(0) values is: 10</span></span><br><span class="line">    println(<span class="string">&quot;point(0) values is: <span class="subst">$&#123;point(<span class="number">0</span>)&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二十二、中缀调用与解构声明"><a href="#二十二、中缀调用与解构声明" class="headerlink" title="二十二、中缀调用与解构声明"></a>二十二、中缀调用与解构声明</h1><h2 id="1、中缀调用"><a href="#1、中缀调用" class="headerlink" title="1、中缀调用"></a>1、中缀调用</h2><p>可以以以下形式创建一个 Map 变量</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> maps = mapOf(<span class="number">1</span> to <span class="string">&quot;leavesC&quot;</span>, <span class="number">2</span> to <span class="string">&quot;ye&quot;</span>, <span class="number">3</span> to <span class="string">&quot;https://juejin.cn/user/923245496518439&quot;</span>)</span><br><span class="line">    maps.forEach &#123; key, value -&gt; println(<span class="string">&quot;key is : <span class="variable">$key</span> , value is : <span class="variable">$value</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 “to” 来声明 map 的 key 与 value 之间的对应关系，这种形式的函数调用被称为中缀调用</p>
<p>kotlin 标准库中对 to 函数的声明如下所示，其作为扩展函数存在，且是一个泛型函数，返回值 Pair 最终再通过解构声明分别将 key 和 value 传给 Map</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;A, B&gt;</span> A.<span class="title">to</span><span class="params">(that: <span class="type">B</span>)</span></span>: Pair&lt;A, B&gt; = Pair(<span class="keyword">this</span>, that)</span><br></pre></td></tr></table></figure>

<p>中缀调用只能与只有一个参数的函数一起使用，无论是普通的函数还是扩展函数。中缀符号需要通过 <strong>infix</strong> 修饰符来进行标记</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> pair = <span class="number">10</span> test <span class="string">&quot;leavesC&quot;</span></span><br><span class="line">    <span class="keyword">val</span> pair2 = <span class="number">1.2</span> test <span class="number">20</span></span><br><span class="line">    println(pair2.javaClass) <span class="comment">//class kotlin.Pair</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> Any.<span class="title">test</span><span class="params">(other: <span class="type">Any</span>)</span></span> = Pair(<span class="keyword">this</span>, other)</span><br></pre></td></tr></table></figure>

<p>对于 <code>mapOf</code> 函数来说，它可以接收不定数量的 <code>Pair</code> 类型对象，因此我们也可以通过自定义的中缀调用符 <code>test</code> 来创建一个 map 变量</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> <span class="title">mapOf</span><span class="params">(<span class="keyword">vararg</span> pairs: <span class="type">Pair</span>&lt;<span class="type">K</span>, V&gt;)</span></span>: Map&lt;K, V&gt; =</span><br><span class="line">    <span class="keyword">if</span> (pairs.size &gt; <span class="number">0</span>) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) <span class="keyword">else</span> emptyMap()</span><br><span class="line"></span><br><span class="line"> <span class="keyword">val</span> map = mapOf(<span class="number">10</span> test <span class="string">&quot;leavesC&quot;</span>, <span class="number">20</span> test <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2、解构声明"><a href="#2、解构声明" class="headerlink" title="2、解构声明"></a>2、解构声明</h2><p>有时会有把一个对象拆解成多个变量的需求，在 kotlin 中这种语法称为解构声明</p>
<p>例如，以下例子将 Person 变量结构为了两个新变量：name 和 age，并且可以独立使用它们</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> (name, age) = Person(<span class="string">&quot;leavesC&quot;</span>, <span class="number">24</span>)</span><br><span class="line">    println(<span class="string">&quot;Name: <span class="variable">$name</span> , age: <span class="variable">$age</span>&quot;</span>)</span><br><span class="line">    <span class="comment">//Name: leavesC , age: 24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个解构声明会被编译成以下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name = person.component1()</span><br><span class="line"><span class="keyword">val</span> age = person.component2()</span><br></pre></td></tr></table></figure>

<p>其中的 <code>component1()</code> 和 <code>component2()</code> 函数是在 kotlin 中广泛使用的约定原则的另一个例子。任何表达式都可以出现在解构声明的右侧，只要可以对它调用所需数量的 <code>component</code> 函数即可</p>
<p>需要注意的是，<code>componentN()</code> 函数需要用 <code>operator</code> 关键字标记，以允许在解构声明中使用它们</p>
<p>对于数据类来说，其自动生成了 <code>componentN()</code> 函数，而对非数据类，为了使用解构声明，需要我们自己来手动声明函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component1</span><span class="params">()</span></span> = x</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component2</span><span class="params">()</span></span> = y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> point = Point(<span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">    <span class="keyword">val</span> (x, y) = point</span><br><span class="line">    println(<span class="string">&quot;x: <span class="variable">$x</span> , y: <span class="variable">$y</span>&quot;</span>)</span><br><span class="line">    <span class="comment">//x: 100 , y: 200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们需要从一个函数返回两个或者更多的值，这时候使用解构声明就会比较方便了</p>
<p>这里使用的是标准类 Pair 来包装要传递的数据，当然，也可以自定义数据类</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">computer</span><span class="params">()</span></span>: Pair&lt;String, <span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="comment">//各种计算</span></span><br><span class="line">    <span class="keyword">return</span> Pair(<span class="string">&quot;leavesC&quot;</span>, <span class="number">24</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> (name, age) = computer()</span><br><span class="line">    println(<span class="string">&quot;Name: <span class="variable">$name</span> , age: <span class="variable">$age</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，解构声明也可以用在 for 循环中</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(Person(<span class="string">&quot;leavesC&quot;</span>, <span class="number">24</span>), Person(<span class="string">&quot;leavesC&quot;</span>, <span class="number">25</span>))</span><br><span class="line"><span class="keyword">for</span> ((name, age) <span class="keyword">in</span> list) &#123;</span><br><span class="line">    println(<span class="string">&quot;Name: <span class="variable">$name</span> , age: <span class="variable">$age</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于遍历 map 同样适用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = mapOf(<span class="string">&quot;leavesC&quot;</span> to <span class="number">24</span>, <span class="string">&quot;ye&quot;</span> to <span class="number">25</span>)</span><br><span class="line"><span class="keyword">for</span> ((name, age) <span class="keyword">in</span> map) &#123;</span><br><span class="line">    println(<span class="string">&quot;Name: <span class="variable">$name</span> , age: <span class="variable">$age</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样也适用于 lambda 表达式</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = mapOf(<span class="string">&quot;leavesC&quot;</span> to <span class="number">24</span>, <span class="string">&quot;ye&quot;</span> to <span class="number">25</span>)</span><br><span class="line">map.mapKeys &#123; (key, value) -&gt; println(<span class="string">&quot;key : <span class="variable">$key</span> , value : <span class="variable">$value</span>&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>如果在解构声明中不需要某个变量，那么可以用下划线取代其名称，此时不会调用相应的 <code>componentN()</code> 操作符函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = mapOf(<span class="string">&quot;leavesC&quot;</span> to <span class="number">24</span>, <span class="string">&quot;ye&quot;</span> to <span class="number">25</span>)</span><br><span class="line"><span class="keyword">for</span> ((_, age) <span class="keyword">in</span> map) &#123;</span><br><span class="line">    println(<span class="string">&quot;age: <span class="variable">$age</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二十三、Object-关键字"><a href="#二十三、Object-关键字" class="headerlink" title="二十三、Object 关键字"></a>二十三、Object 关键字</h1><h2 id="1、对象声明"><a href="#1、对象声明" class="headerlink" title="1、对象声明"></a>1、对象声明</h2><p>在 kotlin 的世界中，可以通过<strong>对象声明</strong>这一功能来实现 Java 中的单例模式，将类声明与该类的单一实例声明结合到一起。与类一样，一个对象声明可以包含属性、方法、初始化语句块等的声明，且可以继承类和实现接口，唯一不被允许的是构造方法</p>
<p>与普通类的实例不同，对象声明在定义的时候就被立即创建了，不需要在代码的其它地方调用构造方法，因此为对象声明定义构造方法是没有意义的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fly</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Eat</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;eat&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> Animal : Eat(), Fly &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;fly&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Animal.fly()</span><br><span class="line">    Animal.eat()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kotlin 中的对象声明被编译成了通过静态字段来持有它的单一实例的类，这个字段名字始终都是 INSTANCE</p>
<p>例如，对于 kotlin 中的如下两个对象声明</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">object</span> SingleClass &#123;</span><br><span class="line">        <span class="keyword">val</span> names = arrayListOf&lt;String&gt;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">object</span> SingleClass2 &#123;</span><br><span class="line">        <span class="keyword">val</span> names = arrayListOf&lt;String&gt;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 代码中来访问这两个对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Test.SingleClass.INSTANCE.getNames();</span><br><span class="line">    Test.SingleClass2.INSTANCE.getNames();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、伴生对象"><a href="#2、伴生对象" class="headerlink" title="2、伴生对象"></a>2、伴生对象</h2><p>如果需要一个可以在没有类实例的情况下调用但是需要访问类内部的函数（类似于 Java 中的静态变量&#x2F;静态函数），可以将其写成那个类中的对象声明的成员</p>
<p>通过关键字 companion ，就可以获得通过容器类名称来访问这个对象的方法和属性的能力，不再需要显式地指明对象的名称</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> NAME = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">testFun</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Test.NAME</span><br><span class="line">    Test.testFun()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1、工厂模式"><a href="#1、工厂模式" class="headerlink" title="1、工厂模式"></a>1、工厂模式</h3><p>可以利用伴生对象来实现工厂模式</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newById</span><span class="params">(id: <span class="type">Int</span>)</span></span> = User(id.toString())</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newByDouble</span><span class="params">(double: <span class="type">Double</span>)</span></span> = User(double.toString())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//构造函数私有，无法创建</span></span><br><span class="line">    <span class="comment">//val user1 = User(&quot;leavesC&quot;)</span></span><br><span class="line">    <span class="keyword">val</span> user2 = User.newById(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">val</span> user3 = User.newByDouble(<span class="number">1.3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、指定名称"><a href="#2、指定名称" class="headerlink" title="2、指定名称"></a>2、指定名称</h3><p>伴生对象既可以为其指定名字，也可以直接使用其默认名 Companion，在引用伴生对象时，可以自由选择是否要在类名后加上伴生对象名</p>
<p>如果使用的是其默认名 Companion（没有自定义名称），则以下两种引用方式都是等价的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> user2 = User.Companion.newById(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">val</span> user3 = User.newByDouble(<span class="number">1.3</span>)</span><br></pre></td></tr></table></figure>

<p>如果为伴生对象声明了自定义名称，引用方式等同</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> UserLoader &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newById</span><span class="params">(id: <span class="type">Int</span>)</span></span> = User(id.toString())</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newByDouble</span><span class="params">(double: <span class="type">Double</span>)</span></span> = User(double.toString())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//构造函数私有，无法创建</span></span><br><span class="line">    <span class="comment">//val user1 = User(&quot;leavesC&quot;)</span></span><br><span class="line">    <span class="keyword">val</span> user2 = User.UserLoader.newById(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">val</span> user3 = User.newByDouble(<span class="number">1.3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、实现接口"><a href="#3、实现接口" class="headerlink" title="3、实现接口"></a>3、实现接口</h3><p>伴生对象也可以实现接口，且可以直接将包含它的类的名字当做实现了该接口的对象实例来使用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> UserLoader : Runnable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">newThread</span><span class="params">(runnable: <span class="type">Runnable</span>)</span></span> = Thread(runnable)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//User 会直接被当做 Runnable 的实例</span></span><br><span class="line">    <span class="keyword">val</span> thread = newThread(User)</span><br><span class="line">    <span class="keyword">val</span> thread2 = newThread(User.UserLoader)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、对象表达式"><a href="#3、对象表达式" class="headerlink" title="3、对象表达式"></a>3、对象表达式</h2><p>object 能用来声明匿名对象，可用于替代 Java 中的匿名内部类，且对象表达式中的代码可以访问并修改其外部的非 final 型的变量</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">newThread</span><span class="params">(runnable: <span class="type">Runnable</span>)</span></span> = Thread(runnable)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> thread = newThread(<span class="keyword">object</span> : Runnable &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二十四、委托"><a href="#二十四、委托" class="headerlink" title="二十四、委托"></a>二十四、委托</h1><h2 id="1、委托模式"><a href="#1、委托模式" class="headerlink" title="1、委托模式"></a>1、委托模式</h2><p>委托模式是一种基本的设计模式，该模式下有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。kotlin 原生支持委托模式，可以零样板代码来实现，通过关键字 by 实现委托</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DefaultPrinter</span> : <span class="type">Printer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">         println(<span class="string">&quot;DefaultPrinter print&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomPrinter</span>(<span class="keyword">val</span> printer: Printer) : Printer <span class="keyword">by</span> printer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> printer = CustomPrinter(DefaultPrinter())</span><br><span class="line">    printer.print() <span class="comment">//DefaultPrinter print</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CustomPrinter 的 by 子句表示将会在 CustomPrinter 中存储 printer 变量，并且编译器将为 CustomPrinter 隐式生成 Printer 接口的所有抽象方法，并将这些方法的调用操作转发给 printer </p>
<p>此外，CustomPrinter 也可以决定自己实现部分方法或全部自己实现，但重写的成员不会在委托对象的成员中调用 ，委托对象的成员只能访问其自身对接口成员实现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> message: String</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">reprint</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DefaultPrinter</span> : <span class="type">Printer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> message: String = <span class="string">&quot;DefaultPrinter message&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(message)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">reprint</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;DefaultPrinter reprint&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomPrinter</span>(<span class="keyword">val</span> printer: Printer) : Printer <span class="keyword">by</span> printer &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> message: String = <span class="string">&quot;CustomPrinter message&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">reprint</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;CustomPrinter reprint&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> printer = CustomPrinter(DefaultPrinter())</span><br><span class="line">    printer.print() <span class="comment">//DefaultPrinter message</span></span><br><span class="line">    printer.reprint() <span class="comment">//CustomPrinter reprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、属性委托"><a href="#2、属性委托" class="headerlink" title="2、属性委托"></a>2、属性委托</h2><p>kotlin 支持通过委托属性将对一个属性的访问操作委托给另外一个对象来完成，对应的语法格式是：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> &lt;属性名&gt;: &lt;类型&gt; <span class="keyword">by</span> &lt;表达式&gt;</span><br></pre></td></tr></table></figure>

<p><strong>属性的委托</strong>不必实现任何的接口，但需要提供一个 <strong>getValue()</strong> 方法与 <strong>setValue()<strong>（对于 var 属性），对一个属性的 get 和 set 操作会被委托给</strong>属性的委托</strong>的这两个方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Delegate</span> &#123;</span><br><span class="line">    <span class="comment">//第一个参数表示被委托的对象、第二个参数表示被委托对象自身的描述</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//第一个参数表示被委托的对象、第二个参数表示被委托对象自身的描述，第三个参数是将要赋予的值</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看以下的小例子，通过输出值就可以看出各个方法的调用时机</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> kotlin.reflect.KProperty</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Delegate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> message: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;thisRef?.javaClass?.name&#125;</span>, thank you for delegating &#x27;<span class="subst">$&#123;property.name&#125;</span>&#x27; to me!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> message ?: <span class="string">&quot;null value&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$value</span> has been assigned to &#x27;<span class="subst">$&#123;property.name&#125;</span>&#x27; in <span class="subst">$&#123;thisRef?.javaClass?.name&#125;</span>.&quot;</span>)</span><br><span class="line">        message = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> strValue: String <span class="keyword">by</span> Delegate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> example = Example()</span><br><span class="line">    println(example.strValue)</span><br><span class="line">    example.strValue = <span class="string">&quot;leaveC&quot;</span></span><br><span class="line">    println(example.strValue)</span><br><span class="line"><span class="comment">//    test.Example, thank you for delegating &#x27;strValue&#x27; to me!</span></span><br><span class="line"><span class="comment">//    null value</span></span><br><span class="line"><span class="comment">//    leaveC has been assigned to &#x27;strValue&#x27; in test.Example.</span></span><br><span class="line"><span class="comment">//    test.Example, thank you for delegating &#x27;strValue&#x27; to me!</span></span><br><span class="line"><span class="comment">//    leaveC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、延迟属性"><a href="#3、延迟属性" class="headerlink" title="3、延迟属性"></a>3、延迟属性</h2><p><strong>lazy()</strong> 是接受一个 lambda 并返回一个 <strong>Lazy &lt; T &gt;</strong> 实例的函数，返回的实例可以作为实现延迟属性的委托，第一次调用 <strong>get()</strong> 会执行已传递给 <strong>lazy()</strong> 函数的 lambda 表达式并记录结果， 后续调用 <strong>get()</strong> 只是返回记录的结果</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> lazyValue1: String <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        println(<span class="string">&quot;lazyValue1 computed!&quot;</span>)</span><br><span class="line">        <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> lazyValue2: String <span class="keyword">by</span> lazy(LazyThreadSafetyMode.SYNCHRONIZED) &#123;</span><br><span class="line">        println(<span class="string">&quot;lazyValue2 computed!&quot;</span>)</span><br><span class="line">        computeLazyValue()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">computeLazyValue</span><span class="params">()</span></span> = <span class="string">&quot;leavesC&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> example = Example()</span><br><span class="line">    println(example.lazyValue1) <span class="comment">//lazyValue1 computed!     Hello</span></span><br><span class="line">    println(example.lazyValue1) <span class="comment">//Hello</span></span><br><span class="line">    println(example.lazyValue2) <span class="comment">//lazyValue2 computed! leavesC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，对于 lazy 属性的求值是带同步锁的（synchronized），即带有 <strong>LazyThreadSafetyMode.SYNCHRONIZED</strong> 参数，此时该值只允许同一时刻只能有一个线程对其进行初始化，并且所有线程会看到相同的初始化值。如果初始化委托的同步锁不是必需的，即如果允许多个线程同时执行，那么可以将  <strong>LazyThreadSafetyMode.PUBLICATION</strong>  作为参数传递给 <strong>lazy()</strong> 函数。 而如果你确定初始化将总是发生在单个线程，那么可以使用 <strong>LazyThreadSafetyMode.NONE</strong> 模式， 此时不会有任何线程安全的保证以及相关的资源开销</p>
<h2 id="4、可观察属性"><a href="#4、可观察属性" class="headerlink" title="4、可观察属性"></a>4、可观察属性</h2><p><strong>Delegates.observable()</strong> 接受两个参数：初始值以及修改属性值时的回调函数。当为属性赋值后就会调用该回调函数，该回调函数包含三个参数：被赋值的属性、旧值与新值</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> example = Example()</span><br><span class="line">    example.age = <span class="number">24</span> <span class="comment">//kProperty.name: age , oldValue: -100 , newValue: 24</span></span><br><span class="line">    example.age = <span class="number">27</span> <span class="comment">//kProperty.name: age , oldValue: 24 , newValue: 27</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> <span class="keyword">by</span> Delegates.observable(-<span class="number">100</span>) &#123; kProperty: KProperty&lt;*&gt;, oldValue: <span class="built_in">Int</span>, newValue: <span class="built_in">Int</span> -&gt;</span><br><span class="line">        println(<span class="string">&quot;kProperty.name: <span class="subst">$&#123;kProperty.name&#125;</span> , oldValue: <span class="variable">$oldValue</span> , newValue: <span class="variable">$newValue</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要拦截一个赋值操作并判断是否进行否决，可以使用 vetoable() 函数，通过返回一个布尔值来决定是否进行拦截，该判断逻辑是在属性被赋新值生效之前进行</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> example = Example()</span><br><span class="line">    example.age = <span class="number">24</span>  <span class="comment">//kProperty.name: age , oldValue: -100 , newValue: 24</span></span><br><span class="line">    example.age = -<span class="number">10</span> <span class="comment">//kProperty.name: age , oldValue: 24 , newValue: -10</span></span><br><span class="line">    example.age = <span class="number">30</span>  <span class="comment">//kProperty.name: age , oldValue: 24 , newValue: 30 (oldValue 依然是 24，说明第二次的赋值操作被否决了)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> <span class="keyword">by</span> Delegates.vetoable(-<span class="number">100</span>) &#123; kProperty: KProperty&lt;*&gt;, oldValue: <span class="built_in">Int</span>, newValue: <span class="built_in">Int</span> -&gt;</span><br><span class="line">        println(<span class="string">&quot;kProperty.name: <span class="subst">$&#123;kProperty.name&#125;</span> , oldValue: <span class="variable">$oldValue</span> , newValue: <span class="variable">$newValue</span>&quot;</span>)</span><br><span class="line">        age &lt;= <span class="number">0</span> <span class="comment">//返回true 则表示拦截该赋值操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、把属性储存在映射中"><a href="#5、把属性储存在映射中" class="headerlink" title="5、把属性储存在映射中"></a>5、把属性储存在映射中</h2><p>可以在一个 map 映射里存储属性的值，然后把属性的存取操作委托给 map 进行管理</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> student = Student(</span><br><span class="line">        mapOf(</span><br><span class="line">            <span class="string">&quot;name&quot;</span> to <span class="string">&quot;leavesCZY&quot;</span>,</span><br><span class="line">            <span class="string">&quot;age&quot;</span> to <span class="number">24</span></span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    println(student.name)</span><br><span class="line">    println(student.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> map: Map&lt;String, Any?&gt;) &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String <span class="keyword">by</span> map</span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span> <span class="keyword">by</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，属性 name 和 age 都是不可变的（val），因此 map 的类型也是 Map 而非 MutableMap（MutableMap 在赋值后可以修改），因此如果为了支持 var 属性，可以将只读的 Map 换成 MutableMap</p>
<h2 id="6、局部委托属性"><a href="#6、局部委托属性" class="headerlink" title="6、局部委托属性"></a>6、局部委托属性</h2><p>可以将局部变量声明为委托属性</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;temp.Printer print&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getPrinter</span><span class="params">()</span></span>: Printer &#123;</span><br><span class="line">    println(<span class="string">&quot;temp.Printer getPrinter&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> Printer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//局部委托</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">example</span><span class="params">(getPrinter: () -&gt; <span class="type">Printer</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> lPrinter <span class="keyword">by</span> lazy(getPrinter)</span><br><span class="line">    <span class="keyword">val</span> valid = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">        lPrinter.print()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    example &#123; getPrinter() &#125;</span><br><span class="line">    <span class="comment">//temp.Printer getPrinter</span></span><br><span class="line">    <span class="comment">//temp.Printer print</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>委托变量只会在第一次访问时才会进行初始化，因此如果 <strong>valid</strong> 为 false 的话，<strong>getPrinter()</strong> 方法就不会被调用</p>
<h1 id="二十五、注解"><a href="#二十五、注解" class="headerlink" title="二十五、注解"></a>二十五、注解</h1><p>注解是将元数据附加到代码元素上的一种方式，附件的元数据就可以在编译后的类文件或者运行时被相关的源代码工具访问</p>
<p>注解的语法格式如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">AnnotationName</span>()</span><br></pre></td></tr></table></figure>

<p>注解的附加属性可以通过用元注解标注注解类来指定：</p>
<ul>
<li>@Target            指定该注解标注的允许范围（类、函数、属性等）</li>
<li>@Retention         指定该注解是否要存储在编译后的 class 文件中，如果要保存，则在运行时可以通过反射来获取到该注解值</li>
<li>@Repeatable        标明允许在单个元素上多次使用相同的该注解</li>
<li>@MustBeDocumented  指定该注解是公有 API 的一部分，并且应该包含在生成的 API 文档中显示的类或方法的签名中</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(AnnotationTarget.FUNCTION, AnnotationTarget.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(AnnotationRetention.RUNTIME)</span></span><br><span class="line"><span class="meta">@Repeatable</span></span><br><span class="line"><span class="meta">@MustBeDocumented</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">AnnotationName</span>()</span><br></pre></td></tr></table></figure>

<p>注解可以声明包含有参数的构造函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">OnClick</span>(<span class="keyword">val</span> viewId: <span class="built_in">Long</span>)</span><br></pre></td></tr></table></figure>

<p>允许的参数类型有：</p>
<ul>
<li>原生数据类型，对应 Java 原生的 int 、long、char 等</li>
<li>字符串</li>
<li>class 对象</li>
<li>枚举</li>
<li>其他注解</li>
<li>以上类型的数组</li>
</ul>
<p>注解参数不能包含有可空类型，因为 JVM 不支持将 null 作为注解属性的值来存储</p>
<p>看一个在运行时获取注解值的例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(AnnotationTarget.FUNCTION, AnnotationTarget.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(AnnotationRetention.RUNTIME)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">OnClick</span>(<span class="keyword">val</span> viewId: <span class="built_in">Long</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnnotationsTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnClick(200300)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClickButton</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Clicked&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> annotationsTest = AnnotationsTest()</span><br><span class="line">    <span class="keyword">for</span> (method <span class="keyword">in</span> annotationsTest.javaClass.methods) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">annotation</span> <span class="keyword">in</span> method.annotations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">annotation</span> <span class="keyword">is</span> OnClick) &#123;</span><br><span class="line">                println(<span class="string">&quot;method name: &quot;</span> + method.name)  <span class="comment">//method name: onClickButton</span></span><br><span class="line">                println(<span class="string">&quot;OnClick viewId: &quot;</span> + <span class="keyword">annotation</span>.viewId)  <span class="comment">//OnClick viewId: 200300</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  </article>
  <!-- tag -->
  <div class="mt-12 pt-6 border-t border-gray-200">
    
  </div>
  <!-- prev and next -->
  <div class="flex justify-between mt-12 pt-6 border-t border-gray-200">
    <div>
      
        <a href="/hexo-blog/public/2025/03/02/md/kotlin/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82%20Handler%20%E6%9C%BA%E5%88%B6/" class="text-sm text-gray-400 hover:text-gray-500 flex justify-center">
          <iconify-icon width="20" icon="ri:arrow-left-s-line" data-inline="false"></iconify-icon>
          一文读懂 Handler 机制
        </a>
      
    </div>
    <div>
      
        <a href="/hexo-blog/public/2025/03/02/md/kotlin/%E4%B8%80%E6%96%87%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20ConstraintLayout/" class="text-sm text-gray-400 hover:text-gray-500 flex justify-center">
          一文快速入门 ConstraintLayout
          <iconify-icon width="20" icon="ri:arrow-right-s-line" data-inline="false"></iconify-icon>
        </a>
      
    </div>
  </div>
  <!-- comment -->
  <div class="article-comments mt-12">
    
<script
  src="https://giscus.app/client.js"
  data-repo="hqqich/giscus"
  data-repo-id="R_kgDOOCZUBA"
  data-category="General"
  data-category-id="DIC_kwDOOCZUBM4Cng1l"
  data-mapping="pathname"
  data-strict="0"
  data-reactions-enabled="1"
  data-emit-metadata="0"
  data-input-position="bottom"
  data-theme="preferred_color_scheme"
  data-lang="zh-CN"
  crossorigin="anonymous"
  async
></script>
<script>
  window.onload = function () {
    console.log("giscus loaded");
    const isDark = document.documentElement.classList.contains("dark");
    const giscusFrame = document.querySelector("iframe.giscus-frame");
    giscusFrame.contentWindow.postMessage(
      {
        giscus: {
          setConfig: {
            theme: isDark ? "dark" : "light",
          },
        },
      },
      "https://giscus.app"
    );
  };
</script>


  </div>
</section>
<!-- js inspect -->

<script src="/hexo-blog/public/lib/clipboard.min.js"></script>


<script async src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
  });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>



<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
  $(document).ready(() => {
    const maraidConfig = {
      theme: "default",
      logLevel: 3,
      flowchart: { curve: "linear" },
      gantt: { axisFormat: "%m/%d/%Y" },
      sequence: { actorMargin: 50 },
    };
    mermaid.initialize(maraidConfig);
  });
</script>



<script src="/hexo-blog/public/lib/fancybox/fancybox.umd.min.js"></script>

<script>
  $(document).ready(() => {
    $('.post-content').each(function(i){
      $(this).find('img').each(function(){
        if ($(this).parent().hasClass('fancybox') || $(this).parent().is('a')) return;
        var alt = this.alt;
        if (alt) $(this).after('<span class="fancybox-alt">' + alt + '</span>');
        $(this).wrap('<a class="fancybox-img" href="' + this.src + '" data-fancybox=\"gallery\" data-caption="' + alt + '"></a>')
      });
      $(this).find('.fancybox').each(function(){
        $(this).attr('rel', 'article' + i);
      });
    });

    Fancybox.bind('[data-fancybox="gallery"]', {
        // options
    })
  })
</script>

<!-- tocbot begin -->

<script src="/hexo-blog/public/lib/tocbot/tocbot.min.js"></script>

<script>
  $(document).ready(() => {
      tocbot.init({
        // Where to render the table of contents.
        tocSelector: '.post-toc',
        // Where to grab the headings to build the table of contents.
        contentSelector: '.post-content',
        // Which headings to grab inside of the contentSelector element.
        headingSelector: 'h1, h2, h3',
        // For headings inside relative or absolute positioned containers within content.
        hasInnerContainers: true,
    });
  })
</script>
<!-- tocbot end -->


  </main>
  <footer class="flex flex-col h-40 items-center justify-center text-gray-400 text-sm">
  <!-- busuanzi -->
  
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- Busuanzi Analytics -->
<div class="flex items-center gap-2">
  <span>Visitors</span>
  <span id="busuanzi_value_site_uv"></span>
  <span>Page Views</span>
  <span id="busuanzi_value_site_pv"></span>
</div>
<!-- End Busuanzi Analytics -->


  <!-- copyright -->
  <div class="flex items-center gap-2">
    <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" style="color: inherit;">CC BY-NC-SA 4.0</a>
    <span>© 2022</span>
    <iconify-icon width="18" icon="emojione-monotone:maple-leaf" ></iconify-icon>
    <a href="https://github.com/xbmlz" target="_blank" rel="noopener noreferrer">xbmlz</a>
  </div>
  <!-- powered by -->
  <div class="flex items-center gap-2">
    <span>Powered by</span>
    <a href="https://hexo.io/" target="_blank" rel="noopener noreferrer">Hexo</a>
    <span>&</span>
    <a href="https://github.com/xbmlz/hexo-theme-maple" target="_blank" rel="noopener noreferrer">Maple</a>
  </div>

</footer>

  <div class="back-to-top box-border fixed right-6 z-1024 -bottom-20 rounded py-1 px-1 bg-slate-900 opacity-60 text-white cursor-pointer text-center dark:bg-slate-600">
    <span class="flex justify-center items-center text-sm">
      <iconify-icon width="18" icon="ion:arrow-up-c" id="go-top"></iconify-icon>
      <span id="scrollpercent"><span>0</span> %</span>
    </span>
  </div>
  
<script src="/hexo-blog/public/js/main.js"></script>


  <script>
    $(document).ready(function () {
      const mapleCount = "10";
      const speed = "0.5";
      const mapleEl = document.getElementById("maple");
      const maples = Array.from({ length: mapleCount }).map(() => {
        const maple = document.createElement("div");
        const scale = Math.random() * 0.5 + 0.5;
        const offset = Math.random() * 2 - 1;
        const x = Math.random() * mapleEl.clientWidth;
        const y = -Math.random() * mapleEl.clientHeight;
        const duration = 10 / speed;
        const delay = -duration;
        maple.className = "maple";
        maple.style.width = `${24 * scale}px`;
        maple.style.height = `${24 * scale}px`;
        maple.style.left = `${x}px`;
        maple.style.top = `${y}px`;
        maple.style.setProperty("--maple-fall-offset", offset);
        maple.style.setProperty("--maple-fall-height", `${Math.abs(y) + mapleEl.clientHeight}px`);
        maple.style.animation = `fall ${duration}s linear infinite`;
        maple.style.animationDelay = `${delay}s`;
        mapleEl.appendChild(maple)
        return maple
      })
    });
  </script>
  


  <div class="fixed top-0 bottom-0 left-0 right-0 pointer-events-none print:hidden" id="maple"></div>
</body>

</html>

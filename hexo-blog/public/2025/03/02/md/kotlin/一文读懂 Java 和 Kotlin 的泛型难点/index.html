<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-EHXM4GYP5W"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-EHXM4GYP5W');
</script>
<!-- End Google Analytics -->



<!-- Baidu Analytics -->
<script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?0a6515fb9c839d6a56d4cfd8b7d243d4";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>
<!-- End Baidu Analytics -->


<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

  <meta name="author" content="hqqich">


  <meta name="subtitle" content="忙碌把时光缩短, 苦难把岁月拉长">




<title>一文读懂 Java 和 Kotlin 的泛型难点 | Hexo-blog</title>



<link rel="icon" href="/hexo-blog/public/favicon.ico">



<link rel="stylesheet" href="/hexo-blog/public/css/main.css">


<link rel="stylesheet" href="/hexo-blog/public/lib/nprogress/nprogress.css">



<script src="/hexo-blog/public/lib/jquery.min.js"></script>


<script src="/hexo-blog/public/lib/iconify-icon.min.js"></script>


<script src="https://cdn.tailwindcss.com?plugins=typography"></script>
<script>
  tailwind.config = {
    darkMode: "class",
  };
</script>


<script src="/hexo-blog/public/lib/nprogress/nprogress.js"></script>

<script>
  $(document).ready(() => {
    NProgress.configure({
      showSpinner: false,
    });
    NProgress.start();
    $("#nprogress .bar").css({
      background: "#de7441",
    });
    $("#nprogress .peg").css({
      "box-shadow": "0 0 2px #de7441, 0 0 4px #de7441",
    });
    $("#nprogress .spinner-icon").css({
      "border-top-color": "#de7441",
      "border-left-color": "#de7441",
    });
    setTimeout(function () {
      NProgress.done();
      $(".fade").removeClass("out");
    }, 800);
  });
</script>

<script>
  (function () {
    const prefersDark =
      window.matchMedia &&
      window.matchMedia("(prefers-color-scheme: dark)").matches;
    const setting = localStorage.getItem("hexo-color-scheme") || "auto";
    if (setting === "dark" || (prefersDark && setting !== "light"))
      document.documentElement.classList.toggle("dark", true);
    let isDark = document.documentElement.classList.contains("dark");
  })();

  $(document).ready(function () {
    // init icon
    const prefersDark =
      window.matchMedia &&
      window.matchMedia("(prefers-color-scheme: dark)").matches;
    const isDark = document.documentElement.classList.contains("dark");
    $("#theme-icon").attr("icon", isDark ? "ri:moon-line" : "ri:sun-line");

    function toggleGiscusTheme() {
      const isDark = document.documentElement.classList.contains("dark");
      const giscusFrame = document.querySelector("iframe.giscus-frame");
      if (giscusFrame) {
        giscusFrame.contentWindow.postMessage(
          {
            giscus: {
              setConfig: {
                theme: isDark ? "dark" : "light",
              },
            },
          },
          "https://giscus.app"
        );
      }
    }

    // toggle dark mode
    function toggleDark() {
      let isDark = document.documentElement.classList.contains("dark");
      const setting = localStorage.getItem("hexo-color-scheme") || "auto";
      isDark = !isDark;
      document.documentElement.classList.toggle("dark", isDark);
      $("#theme-icon").attr("icon", isDark ? "ri:moon-line" : "ri:sun-line");
      if (prefersDark === isDark) {
        localStorage.setItem("hexo-color-scheme", "auto");
      } else {
        localStorage.setItem("hexo-color-scheme", isDark ? "dark" : "light");
      }
      toggleGiscusTheme();
    }

    // listen dark mode change
    window
      .matchMedia("(prefers-color-scheme: dark)")
      .addEventListener("change", (e) => {
        const setting = localStorage.getItem("hexo-color-scheme") || "auto";
        if (setting === "auto") {
          document.documentElement.classList.toggle("dark", e.matches);
          $("#theme-icon").attr(
            "icon",
            e.matches ? "ri:moon-line" : "ri:sun-line"
          );
          toggleGiscusTheme();
        }
      });

    $("#toggle-dark").click((event) => {
      const isAppearanceTransition = document.startViewTransition && !window.matchMedia('(prefers-reduced-motion: reduce)').matches
      if (!isAppearanceTransition) {
        toggleDark()
        return
      }
      const x = event.clientX
      const y = event.clientY
      const endRadius = Math.hypot(
        Math.max(x, innerWidth - x),
        Math.max(y, innerHeight - y),
      )
      const transition = document.startViewTransition(async () => {
        toggleDark()
      })

      transition.ready
        .then(() => {
          const isDark = document.documentElement.classList.contains("dark")
          const clipPath = [
            `circle(0px at ${x}px ${y}px)`,
            `circle(${endRadius}px at ${x}px ${y}px)`,
          ]
          document.documentElement.animate(
            {
              clipPath: isDark
                ? [...clipPath].reverse()
                : clipPath,
            },
            {
              duration: 400,
              easing: 'ease-out',
              pseudoElement: isDark
                ? '::view-transition-old(root)'
                : '::view-transition-new(root)',
            },
          )
        })
    });
  });
</script>




<meta name="generator" content="Hexo 7.3.0"></head>
<body class="font-sans bg-white dark:bg-zinc-900 text-gray-700 dark:text-gray-200 relative">
  <header class="fixed w-full px-5 py-1 z-10 backdrop-blur-xl backdrop-saturate-150 border-b border-black/5">
  <div class="max-auto">
    <nav class="flex items-center text-base">
      <a href="/hexo-blog/public/" class="group">
        <h2 class="font-medium tracking-tighterp text-l p-2">
          <img class="w-5 mr-2 inline-block transition-transform group-hover:rotate-[30deg]" id="logo" src="https://moe-counter-vercel-gamma.vercel.app/a?theme=rule34" alt="Hexo-blog" />
          Hexo-blog
        </h2>
      </a>
      <div id="header-title" class="opacity-0 md:ml-2 md:mt-[0.1rem] text-xs font-medium whitespace-nowrap overflow-hidden overflow-ellipsis">
        一文读懂 Java 和 Kotlin 的泛型难点
      </div>
      <div class="flex-1"></div>
      <div class="flex items-center gap-3">
        
          <a class="hidden sm:flex" href="/hexo-blog/public/archives">Posts</a>
        
          <a class="hidden sm:flex" href="/hexo-blog/public/category">Categories</a>
        
          <a class="hidden sm:flex" href="/hexo-blog/public/tag">Tags</a>
        
        
          
            <a class="w-5 h-5 hidden sm:flex" title="Github" target="_blank" rel="noopener" href="https://github.com/hqqich">
              <iconify-icon width="20" icon="ri:github-line"></iconify-icon>
            </a>
          
        
        <a class="w-5 h-5 hidden sm:flex" title="Github" href="rss2.xml">
          <iconify-icon width="20" icon="ri:rss-line"></iconify-icon>
        </a>
        <a class="w-5 h-5" title="toggle theme" id="toggle-dark">
          <iconify-icon width="20" icon="" id="theme-icon"></iconify-icon>
        </a>
      </div>
      <div class="flex items-center justify-center gap-3 ml-3 sm:hidden">
        <span class="w-5 h-5" aria-hidden="true" role="img" id="open-menu">
          <iconify-icon width="20" icon="carbon:menu" ></iconify-icon>
        </span>
        <span class="w-5 h-5 hidden" aria-hidden="true" role="img" id="close-menu">
          <iconify-icon  width="20" icon="carbon:close" ></iconify-icon>
        </span>
      </div>
    </nav>
  </div>
</header>
<div id="menu-panel" class="h-0 overflow-hidden sm:hidden fixed left-0 right-0 top-12 bottom-0 z-10">
  <div id="menu-content" class="relative z-20 bg-white/80 px-6 sm:px-8 py-2 backdrop-blur-xl -translate-y-full transition-transform duration-300">
    <ul class="nav flex flex-col sm:flex-row text-sm font-medium">
      
        <li class="nav-portfolio sm:mx-2 border-b sm:border-0 border-black/5 last:border-0 hover:text-main">
          <a href="/hexo-blog/public/archives" class="flex h-12 sm:h-auto items-center">Posts</a>
        </li>
      
        <li class="nav-portfolio sm:mx-2 border-b sm:border-0 border-black/5 last:border-0 hover:text-main">
          <a href="/hexo-blog/public/category" class="flex h-12 sm:h-auto items-center">Categories</a>
        </li>
      
        <li class="nav-portfolio sm:mx-2 border-b sm:border-0 border-black/5 last:border-0 hover:text-main">
          <a href="/hexo-blog/public/tag" class="flex h-12 sm:h-auto items-center">Tags</a>
        </li>
      
    </ul>
  </div>
  <div class="mask bg-black/20 absolute inset-0"></div>
</div>

  <main class="pt-14">
    <!-- css -->

<link rel="stylesheet" href="/hexo-blog/public/lib/fancybox/fancybox.min.css">


<link rel="stylesheet" href="/hexo-blog/public/lib/tocbot/tocbot.min.css">

<!-- toc -->

  <!-- tocbot -->
<nav class="post-toc toc text-sm w-48 relative top-32 right-0 opacity-70 hidden lg:block" style="position: fixed !important;"></nav>


<section class="px-6 max-w-prose mx-auto md:px-0">
  <!-- header -->
  <header class="overflow-hidden pt-6 pb-6 md:pt-12">
    <div class="pt-4 md:pt-6">
      <h1 id="article-title" class="text-[2rem] font-bold leading-snug mb-4 md:mb-6 md:text-[2.6rem]">
        一文读懂 Java 和 Kotlin 的泛型难点
      </h1>
      <div>
        <section class="flex items-center gap-3 text-sm">
          <span class="flex items-center gap-1">
            <iconify-icon width="18" icon="carbon-calendar" ></iconify-icon>
            <time>2025-03-02</time>
          </span>
          <span class="text-gray-400">·</span>
          <span class="flex items-center gap-1">
            <iconify-icon width="18" icon="ic:round-access-alarm" ></iconify-icon>
            <span>33 min</span>
          </span>
          <span class="text-gray-400">·</span>
          <span class="flex items-center gap-1">
            <iconify-icon width="18" icon="icon-park-outline:font-search" ></iconify-icon>
            <span>7.9k words</span>
          </span>
          
            <span class="text-gray-400">·</span>
            <span class="flex items-center gap-1">
              <iconify-icon width="16" icon="icon-park-outline:box" class="mr-2"></iconify-icon>
              <a class="article-category-link" href="/hexo-blog/public/categories/kotlin/">kotlin</a>
            </span>
          
        </section>
      </div>
    </div>
  </header>
  <!-- content -->
  <article class="post-content prose m-auto slide-enter-content dark:prose-invert">
    <blockquote>
<p>公众号：<a target="_blank" rel="noopener" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adbc507fc3704fd8955aae739a433db2~tplv-k3u1fbpfcp-zoom-1.image">字节数组</a></p>
<p>希望对你有所帮助 🤣🤣</p>
</blockquote>
<p>Java 和 Kotlin 的泛型算作是一块挺大的知识难点了，涉及到很多很难理解的概念：<strong>泛型型参、泛型实参、类型参数、不变、型变、协变、逆变、内联</strong>等等。本篇文章就将 Java 和 Kotlin 结合着一起讲，按照我的个人理解来阐述泛型的各个知识难点，希望对你有所帮助 🤣🤣</p>
<h1 id="一、泛型类型"><a href="#一、泛型类型" class="headerlink" title="一、泛型类型"></a>一、泛型类型</h1><p>泛型允许你定义带<strong>类型形参</strong>的数据类型，当这种类型的实例被创建出来后，<strong>类型形参</strong>便被替换为称为<strong>类型实参</strong>的具体类型。例如，对于 <code>List&lt;T&gt;</code>，List 称为<strong>基础类型</strong>，T 便是<strong>类型型参</strong>，T 可以是任意类型，当没有指定 T 的具体类型时，我们只能知道<code>List&lt;T&gt;</code>是一个集合列表，但不知道承载的具体数据类型。而对于 <code>List&lt;String&gt;</code>，当中的 String 便是<strong>类型实参</strong>，我们可以明白地知道该列表承载的都是字符串，在这里 String 就相当于一个参数传递给了 List，在这语义下 String 也称为<strong>类型参数</strong></p>
<p>此外，在 Kotlin 中我们可以实现<strong>实化类型参数</strong>，在运行时的<strong>内联函数</strong>中拿到作为<strong>类型实参</strong>的具体类型，即可以实现 <code>T::class.java</code>，但在 Java 中却无法实现，因为<strong>内联函数</strong>是 Kotlin 中的概念，Java 中并不存在</p>
<h1 id="二、为什么需要泛型"><a href="#二、为什么需要泛型" class="headerlink" title="二、为什么需要泛型"></a>二、为什么需要泛型</h1><p>泛型是在 Java 5 版本开始引入的，先通过几个小例子来明白泛型的重要性</p>
<p>以下代码可以成功编译，但是在运行时却抛出了 ClassCastException。了解 ArrayList 源码的同学就知道其内部是用一个<code>Object[]</code>数组来存储数据的，这使得 ArrayList 能够存储任何类型的对象，所以在没有泛型的年代开发者一不小心就有可能向 ArrayList 存入了非期望值，编译期完全正常，等到在运行时就会抛出类型转换异常了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">stringList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        addData(stringList);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) stringList.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addData</span><span class="params">(List dataList)</span> &#123;</span><br><span class="line">        dataList.add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException: </span><br><span class="line">java.lang.Integer cannot be cast to java.lang.String</span><br></pre></td></tr></table></figure>

<p>而有了泛型后，我们就可以写出更加健壮安全的代码，以下错误就完全可以在编译阶段被发现，且取值的时候也不需要进行类型强转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; stringList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    addData(stringList); <span class="comment">//报错</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> stringList.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addData</span><span class="params">(List&lt;Integer&gt; dataList)</span> &#123;</span><br><span class="line">    dataList.add(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，利用泛型我们可以写出更加具备通用性的代码。例如，假设我们需要从一个 List 中筛选出大于 0 的全部数字，那我们自然不想为 Integer、Float、Double 等多种类型各写一个筛选方法，此时就可以利用泛型来抽象筛选逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; integerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    integerList.add(-<span class="number">1</span>);</span><br><span class="line">    integerList.add(<span class="number">1</span>);</span><br><span class="line">    integerList.add(<span class="number">2</span>);</span><br><span class="line">    List&lt;Integer&gt; result1 = filter(integerList);</span><br><span class="line"></span><br><span class="line">    List&lt;Float&gt; floatList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    floatList.add(-<span class="number">1f</span>);</span><br><span class="line">    floatList.add(<span class="number">1f</span>);</span><br><span class="line">    floatList.add(<span class="number">2f</span>);</span><br><span class="line">    List&lt;Float&gt; result2 = filter(floatList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; List&lt;T&gt; <span class="title function_">filter</span><span class="params">(List&lt;T&gt; data)</span> &#123;</span><br><span class="line">    List&lt;T&gt; filterList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (T datum : data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (datum.doubleValue() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            filterList.add(datum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> filterList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，泛型有以下几点优势：</p>
<ul>
<li>类型检查，在编译阶段就能发现错误</li>
<li>更加语义化，看到 <code>List&lt;String&gt;</code>我们就知道存储的数据类型是 String</li>
<li>自动类型转换，在取值时无需进行手动类型转换</li>
<li>能够将逻辑抽象出来，使得代码更加具有通用性</li>
</ul>
<h1 id="三、类型擦除"><a href="#三、类型擦除" class="headerlink" title="三、类型擦除"></a>三、类型擦除</h1><p>泛型是在 Java 5 版本开始引入的，所以在 Java 4 中 ArrayList 还不属于泛型类，其内部通过 <strong>Object 向上转型</strong>和<strong>外部强制类型转换</strong>来实现数据存储和逻辑复用，此时开发者的项目中已经充斥了大量以下类型的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">stringList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">stringList.add(<span class="string">&quot;业志陈&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;https://juejin.cn/user/923245496518439&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) stringList.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>而在推出泛型的同时，Java 官方也必须保证二进制的向后兼容性，用 Java 4 编译出的 Class 文件也必须能够在 Java 5 上正常运行，即 Java 5 必须保证以下两种类型的代码能够在 Java 5 上共存且正常运行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">stringList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br></pre></td></tr></table></figure>

<p>为了实现这一目的，Java 就通过<strong>类型擦除</strong>这种比较别扭的方式来实现泛型。编译器在编译时会擦除类型实参，在运行时不存在任何类型相关的信息，泛型对于 JVM 来说是透明的，有泛型和没有泛型的代码通过编译器编译后所生成的二进制代码是完全相同的</p>
<p>例如，分别声明两个泛型类和非泛型类，拿到其 class 文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NodeA</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">NodeA</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.obj = obj;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NodeB</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> T obj;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">NodeB</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.obj = obj;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NodeA</span> <span class="variable">nodeA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeA</span>(<span class="string">&quot;业志陈&quot;</span>);</span><br><span class="line">        NodeB&lt;String&gt; nodeB = <span class="keyword">new</span> <span class="title class_">NodeB</span>&lt;&gt;(<span class="string">&quot;业志陈&quot;</span>);</span><br><span class="line">        System.out.println(nodeB.obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 NodeA 和 NodeB 两个对象对应的字节码其实是完全一样的，最终都是使用 Object 来承载数据，就好像传递给 NodeB 的类型参数 String 不见了一样，这便是类型擦除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">generic</span>.GenericTest &#123;</span><br><span class="line">  <span class="keyword">public</span> generic.GenericTest();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class generic/GenericTest$NodeA</span></span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String 业志陈</span></span><br><span class="line">       <span class="number">6</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method generic/GenericTest$NodeA.&quot;&lt;init&gt;&quot;:(Ljava/lang/Object;)V</span></span><br><span class="line">       <span class="number">9</span>: astore_1</span><br><span class="line">      <span class="number">10</span>: <span class="keyword">new</span>           #<span class="number">5</span>                  <span class="comment">// class generic/GenericTest$NodeB</span></span><br><span class="line">      <span class="number">13</span>: dup</span><br><span class="line">      <span class="number">14</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String 业志陈</span></span><br><span class="line">      <span class="number">16</span>: invokespecial #<span class="number">6</span>                  <span class="comment">// Method generic/GenericTest$NodeB.&quot;&lt;init&gt;&quot;:(Ljava/lang/Object;)V</span></span><br><span class="line">      <span class="number">19</span>: astore_2</span><br><span class="line">      <span class="number">20</span>: getstatic     #<span class="number">7</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">23</span>: aload_2</span><br><span class="line">      <span class="number">24</span>: invokestatic  #<span class="number">8</span>                  <span class="comment">// Method generic/GenericTest$NodeB.access$000:(Lgeneric/GenericTest$NodeB;)Ljava/lang/Object;</span></span><br><span class="line">      <span class="number">27</span>: checkcast     #<span class="number">9</span>                  <span class="comment">// class java/lang/String</span></span><br><span class="line">      <span class="number">30</span>: invokevirtual #<span class="number">10</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">33</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如果让 NodeA 直接使用 String 类型，并且为泛型类 NodeB 设定上界约束 String，两者的字节码也会完全一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NodeA</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String obj;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">NodeA</span><span class="params">(String obj)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.obj = obj;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NodeB</span>&lt;T <span class="keyword">extends</span> <span class="title class_">String</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> T obj;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">NodeB</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.obj = obj;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NodeA</span> <span class="variable">nodeA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeA</span>(<span class="string">&quot;业志陈&quot;</span>);</span><br><span class="line">        NodeB&lt;String&gt; nodeB = <span class="keyword">new</span> <span class="title class_">NodeB</span>&lt;&gt;(<span class="string">&quot;业志陈&quot;</span>);</span><br><span class="line">        System.out.println(nodeB.obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 NodeA 和 NodeB 的字节码是完全相同的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">generic</span>.GenericTest &#123;</span><br><span class="line">  <span class="keyword">public</span> generic.GenericTest();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class generic/GenericTest$NodeA</span></span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String 业志陈</span></span><br><span class="line">       <span class="number">6</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method generic/GenericTest$NodeA.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span></span><br><span class="line">       <span class="number">9</span>: astore_1</span><br><span class="line">      <span class="number">10</span>: <span class="keyword">new</span>           #<span class="number">5</span>                  <span class="comment">// class generic/GenericTest$NodeB</span></span><br><span class="line">      <span class="number">13</span>: dup</span><br><span class="line">      <span class="number">14</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String 业志陈</span></span><br><span class="line">      <span class="number">16</span>: invokespecial #<span class="number">6</span>                  <span class="comment">// Method generic/GenericTest$NodeB.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">19</span>: astore_2</span><br><span class="line">      <span class="number">20</span>: getstatic     #<span class="number">7</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">23</span>: aload_2</span><br><span class="line">      <span class="number">24</span>: invokestatic  #<span class="number">8</span>                  <span class="comment">// Method generic/GenericTest$NodeB.access$000:(Lgeneric/GenericTest$NodeB;)Ljava/lang/String;</span></span><br><span class="line">      <span class="number">27</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">30</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以说，当泛型类型被擦除后有两种转换方式</p>
<ul>
<li>如果泛型没有设置上界约束，那么将泛型转化成 Object 类型</li>
<li>如果泛型设置了上界约束，那么将泛型转化成该上界约束</li>
</ul>
<p>该结论也可以通过反射泛型类的 Class 对象来验证</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NodeA</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> T obj;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">NodeA</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.obj = obj;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NodeB</span>&lt;T <span class="keyword">extends</span> <span class="title class_">String</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> T obj;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">NodeB</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.obj = obj;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        NodeA&lt;String&gt; nodeA = <span class="keyword">new</span> <span class="title class_">NodeA</span>&lt;&gt;(<span class="string">&quot;业志陈&quot;</span>);</span><br><span class="line">        getField(nodeA.getClass());</span><br><span class="line">        NodeB&lt;String&gt; nodeB = <span class="keyword">new</span> <span class="title class_">NodeB</span>&lt;&gt;(<span class="string">&quot;https://juejin.cn/user/923245496518439&quot;</span>);</span><br><span class="line">        getField(nodeB.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getField</span><span class="params">(Class clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Field field : clazz.getDeclaredFields()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;fieldName: &quot;</span> + field.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;fieldTypeName: &quot;</span> + field.getType().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NodeA 对应的是 Object，NodeB 对应的是 String</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fieldName: obj</span><br><span class="line">fieldTypeName: java.lang.Object</span><br><span class="line">fieldName: obj</span><br><span class="line">fieldTypeName: java.lang.String</span><br></pre></td></tr></table></figure>

<p>那既然在运行时不存在任何类型相关的信息，泛型又为什么能够实现<strong>类型检查</strong>和<strong>类型自动转换</strong>等功能呢？</p>
<p>其实，类型检查是编译器在<strong>编译前</strong>帮我们完成的，编译器知道我们声明的具体的类型实参，所以类型擦除并不影响类型检查功能。而类型自动转换其实是通过内部强制类型转换来实现的，上面给出的字节码中也可以看到有一条类型强转 checkcast 的语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">27</span>: checkcast     #<span class="number">9</span>                  <span class="comment">// class java/lang/String</span></span><br></pre></td></tr></table></figure>

<p>例如，ArrayList 内部虽然用于存储数据的是 Object 数组，但 get 方法内部会自动完成类型强转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">	rangeCheck(index);</span><br><span class="line">	<span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">	<span class="comment">//强制类型转换</span></span><br><span class="line">	<span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以 Java 的泛型可以看做是一种特殊的语法糖，因此也被人称为<strong>伪泛型</strong></p>
<h1 id="四、类型擦除的后遗症"><a href="#四、类型擦除的后遗症" class="headerlink" title="四、类型擦除的后遗症"></a>四、类型擦除的后遗症</h1><p>Java 泛型对于类型的约束只在编译期存在，运行时仍然会按照 Java 5 之前的机制来运行，泛型的具体类型在运行时已经被删除了，所以 JVM 是识别不到我们在代码中指定的具体的泛型类型的</p>
<p>例如，虽然<code>List&lt;String&gt;</code>只能用于添加字符串，但我们只能<strong>泛化地</strong>识别到它属于<code>List&lt;?&gt;</code>类型，而无法具体判断出该 List 内部包含的具体类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//正常</span></span><br><span class="line"><span class="keyword">if</span> (stringList <span class="keyword">instanceof</span> ArrayList&lt;?&gt;) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//报错</span></span><br><span class="line"><span class="keyword">if</span> (stringList <span class="keyword">instanceof</span> ArrayList&lt;String&gt;) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只能对具体的对象实例进行类型校验，但无法判断出泛型形参的具体类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">filter</span><span class="params">(T data)</span> &#123;</span><br><span class="line">	<span class="comment">//正常</span></span><br><span class="line">	<span class="keyword">if</span> (data <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//报错</span></span><br><span class="line">	<span class="keyword">if</span> (T <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//报错</span></span><br><span class="line">	Class&lt;T&gt; tClass = T::getClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，类型擦除也会导致 Java 中出现多态问题。例如，以下两个方法的方法签名并不完全相同，但由于类型擦除的原因，入参参数的数据类型都会被看成 <code>List&lt;Object&gt;</code>，从而导致两者无法共存在同一个区域内</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">filter</span><span class="params">(List&lt;String&gt; stringList)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">filter</span><span class="params">(List&lt;Integer&gt; stringList)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、Kotlin-泛型"><a href="#五、Kotlin-泛型" class="headerlink" title="五、Kotlin 泛型"></a>五、Kotlin 泛型</h1><p>Kotlin 泛型在大体上和 Java 一致，毕竟两者需要保证兼容性</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plate</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> t: T) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">cut</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(t.toString())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Banana</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> plateApple = Plate&lt;Apple&gt;(Apple())</span><br><span class="line">    <span class="comment">//泛型类型自动推导</span></span><br><span class="line">    <span class="keyword">val</span> plateBanana = Plate(Banana())</span><br><span class="line">    plateApple.cut()</span><br><span class="line">    plateBanana.cut()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kotlin 也支持在扩展函数中使用泛型</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> List<span class="type">&lt;T&gt;</span>.<span class="title">find</span><span class="params">(t: <span class="type">T</span>)</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">val</span> index = indexOf(t)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) <span class="keyword">get</span>(index) <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，为了实现向后兼容，目前高版本 Java 依然允许实例化没有具体类型参数的泛型类，这可以说是一个对新版本 JDK 危险但对旧版本友好的兼容措施。但 Kotlin 要求在使用泛型时需要<strong>显式声明泛型类型</strong>或者是<strong>编译器能够类型推导出具体类型</strong>，任何不具备具体泛型类型的泛型类都无法被实例化。因为 Kotlin 一开始就是基于 Java 6 版本的，一开始就存在了泛型，自然就不存在需要兼容老代码的问题，因此以下例子和 Java 会有不同的表现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arrayList1 = ArrayList() <span class="comment">//错误，编译器报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> arrayList2 = arrayListOf&lt;<span class="built_in">Int</span>&gt;() <span class="comment">//正常</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> arrayList3 = arrayListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">//正常</span></span><br></pre></td></tr></table></figure>

<p>还有一个比较容易让人误解的点。我们经常会使用 <code>as</code> 和 <code>as?</code> 来进行类型转换，但如果转换对象是泛型类型的话，那就会由于类型擦除而出现误判。如果转换对象有正确的<strong>基础类型</strong>，那么转换就会成功，而不管类型实参是否相符。因为在运行时转换发生的时候类型实参是未知的，此时编译器只会发出 “unchecked cast” 警告，代码还是可以正常编译的</p>
<p>例如，在以下例子中代码的运行结果还符合我们的预知。第一个转换操作由于类型相符，所以打印出了相加值。第二个转换操作由于基础类型是 Set 而非 List，所以抛出了 IllegalAccessException</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    printSum(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) <span class="comment">//6</span></span><br><span class="line">    printSum(setOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) <span class="comment">//IllegalAccessException</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(c: <span class="type">Collection</span>&lt;*&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> intList = c <span class="keyword">as</span>? List&lt;<span class="built_in">Int</span>&gt; ?: <span class="keyword">throw</span> IllegalAccessException(<span class="string">&quot;List is expected&quot;</span>)</span><br><span class="line">    println(intList.sum())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在以下例子中抛出的却是 ClassCastException，这是因为在运行时不会判断且无法判断出类型实参到底是否是 Int，而只会判断基础类型 List 是否相符，所以 <code>as?</code> 操作会成功，等到要执行相加操作时才会发现拿到的是 String 而非 Number</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">printSum(listOf(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>))</span><br><span class="line"></span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException: </span><br><span class="line">java.lang.String cannot be cast to java.lang.Number</span><br></pre></td></tr></table></figure>

<h1 id="六、上界约束"><a href="#六、上界约束" class="headerlink" title="六、上界约束"></a>六、上界约束</h1><p>泛型本身已经带有类型约束的作用，我们也可以进一步细化其支持的具体类型</p>
<p>例如，假设存在一个盘子 Plate，我们要求该 Plate 只能用于装水果 Fruit，那么就可以对其泛型声明做进一步约束，Java 中使用 extend 关键字来声明约束规则，而 Kotlin 使用的是 <strong>:</strong>  。这样 Plate 就只能用于 Fruit 和其子类，而无法用于 Noodles 等不相关的类型，这种类型约束就被称为<strong>上界约束</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Fruit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> : <span class="type">Fruit</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Noodles</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Plate</span>&lt;<span class="type">T : Fruit</span>&gt;(<span class="keyword">val</span> t: T)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> applePlate = Plate(Apple()) <span class="comment">//正常</span></span><br><span class="line">    <span class="keyword">val</span> noodlesPlate = Plate(Noodles()) <span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果上界约束拥有多层类型元素，Java 是使用 &amp; 符号进行链式声明，Kotlin 则是用 where 关键字来依次进行声明</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Soft</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Plate</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> t: T) <span class="keyword">where</span> T : Fruit, T : Soft</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Fruit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> : <span class="type">Fruit</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Banana</span> : <span class="type">Fruit</span>(), Soft</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> applePlate = Plate(Apple()) <span class="comment">//报错</span></span><br><span class="line">    <span class="keyword">val</span> bananaPlate = Plate(Banana()) <span class="comment">//正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，没有指定上界约束的类型形参会默认使用 Any? 作为上界，即我们可以使用 String 或 String? 作为具体的类型实参。如果想确保最终的类型实参一定是非空类型，那么就需要主动声明上界约束为 Any</p>
<h1 id="七、类型通配符-星号投影"><a href="#七、类型通配符-星号投影" class="headerlink" title="七、类型通配符 &amp; 星号投影"></a>七、类型通配符 &amp; 星号投影</h1><p>假设现在有个需求，需要我们提供一个方法用于遍历所有类型的 List 集合并打印元素</p>
<p>第一种做法就是直接将方法参数类型声明为 List，不包含任何泛型类型声明。这种做法可行，但编译器会警告无法确定 <code>list</code>元素的具体类型，所以这不是最优解法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList1</span><span class="params">(List list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能会想到的第二种做法是：将泛型类型直接声明为 Object，希望让其适用于任何类型的 List。这种做法完全不可行，因为即使 <code>String</code> 是 <code>Object</code> 的子类，但 <code>List&lt;String&gt;</code> 和 <code>List&lt;Object&gt;</code>并不具备从属关系，这导致 <code>printList2</code> 方法实际上只能用于<code>List&lt;Object&gt;</code>这一种具体类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList2</span><span class="params">(List&lt;Object&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最优解法就是要用到 Java 的类型通配符 <strong>?</strong> 了，<code>printList3</code>方法完全可行且编译器也不会警告报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList3</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>？ 表示我们并不关心具体的泛型类型，而只是想配合其它类型进行一些条件限制。例如，<code>printList3</code>方法希望传入的是一个 List，但不限制泛型的具体类型，此时<code>List&lt;?&gt;</code>就达到了这一层限制条件</p>
<p>类型通配符也存在着一些限制。因为 <code>printList3</code> 方法并不包含具体的泛型类型，所以我们从中取出的值只能是 Object 类型，且无法向其插入值，这都是为了避免发生 ClassCastException</p>
<p>Java 的<strong>类型通配符</strong>对应 Kotlin 中的概念就是**星号投影 * **，Java 存在的限制在 Kotlin 中一样有</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printList</span><span class="params">(list: <span class="type">List</span>&lt;*&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (any <span class="keyword">in</span> list) &#123;</span><br><span class="line">        println(any)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，星号投影只能出现在<strong>类型形参</strong>的位置，不能作为<strong>类型实参</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list: MutableList&lt;*&gt; = ArrayList&lt;Number&gt;() <span class="comment">//正常</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list2: MutableList&lt;*&gt; = ArrayList&lt;*&gt;() <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<h1 id="八、协变-不变"><a href="#八、协变-不变" class="headerlink" title="八、协变 &amp; 不变"></a>八、协变 &amp; 不变</h1><p>看以下例子。Apple 和 Banana 都是 Fruit 的子类，可以发现 Apple[] 类型的对象是可以赋值给 Fruit[] 的，且 Fruit[] 可以容纳 Apple 对象和 Banana 对象，这种设计就被称为<strong>协变</strong>，即如果 A 是 B 的子类，那么 A[] 就是 B[] 的子类型。相对的，Object[] 就是所有数组对象的父类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Banana</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Fruit[] fruitArray = <span class="keyword">new</span> <span class="title class_">Apple</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//正常</span></span><br><span class="line">    fruitArray[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">    <span class="comment">//编译时正常，运行时抛出 ArrayStoreException</span></span><br><span class="line">    fruitArray[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Banana</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 Java 中的泛型是<strong>不变</strong>的，这意味着 String 虽然是 Object 的子类，但<code>List&lt;String&gt;</code>并不是<code>List&lt;Object&gt;</code>的子类型，两者并不具备继承关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Object&gt; objectList = stringList; <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<p>那为什么 Java 中的泛型是<strong>不变</strong>的呢？</p>
<p>这可以通过看一个例子来解释。假设 Java 中的泛型是<strong>协变</strong>的，那么以下代码就可以成功通过编译阶段的检查，在运行时就不可避免地将抛出 ClassCastException，而引入泛型的初衷就是为了实现类型安全，支持协变的话那泛型也就没有比数组安全多少了，因此就将泛型被设计为<strong>不变</strong>的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Object&gt; objs = strList; <span class="comment">//假设可以运行，实际上编译器会报错</span></span><br><span class="line">objs.add(<span class="number">1</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strList.get(<span class="number">0</span>); <span class="comment">//将抛出 ClassCastException，无法将整数转换为字符串</span></span><br></pre></td></tr></table></figure>

<p>再来想个问题，既然<strong>协变</strong>本身并不安全，那么数组为何又要被设计为协变呢？</p>
<p>Arrays 类包含一个 <code>equals</code>方法用于比较两个数组对象是否相等。如果数组是协变的，那么就需要为每一种数组对象都定义一个 <code>equals</code>方法，包括开发者自定义的数据类型。想要避免这种情况，就需要让 Object[] 可以接收任意数组类型，即<strong>让 Object[] 成为所有数组对象的父类型</strong>，这就使得数组必须支持协变，这样多态才能生效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Arrays</span> &#123;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object[] a, Object[] a2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a==a2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (a==<span class="literal">null</span> || a2==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="keyword">if</span> (a2.length != length)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> a[i];</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> a2[i];</span><br><span class="line">            <span class="keyword">if</span> (!(o1==<span class="literal">null</span> ? o2==<span class="literal">null</span> : o1.equals(o2)))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，Kotlin 中的数组和 Java 中的数组并不一样，Kotlin 数组并不支持协变，Kotlin 数组类似于集合框架，具有对应的实现类 Array，Array 属于泛型类，支持了泛型因此也不再协变</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stringArray = arrayOfNulls&lt;String&gt;(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> anyArray: Array&lt;Any?&gt; = stringArray <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Java 的泛型也并非完全<strong>不变</strong>的，只是实现<strong>协变</strong>需要满足一些条件，甚至也可以实现<strong>逆变</strong>，下面就来介绍下泛型如何实现<strong>协变</strong>和<strong>逆变</strong></p>
</blockquote>
<h1 id="九、泛型协变"><a href="#九、泛型协变" class="headerlink" title="九、泛型协变"></a>九、泛型协变</h1><p>假设我们定义了一个<code>copyAll</code>希望用于 List 数据迁移。那以下操作在我们看来就是完全安全的，因为 Integer 是 Number 的子类，按道理来说是能够将 Integer 保存为 Number 的，但由于泛型不变性，<code>List&lt;Integer&gt;</code>并不是<code>List&lt;Number&gt;</code>的子类型，所以实际上该操作将报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Number&gt; numberList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; integerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    integerList.add(<span class="number">1</span>);</span><br><span class="line">    integerList.add(<span class="number">2</span>);</span><br><span class="line">    integerList.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    copyAll(numberList, integerList); <span class="comment">//报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copyAll</span><span class="params">(List&lt;T&gt; to, List&lt;T&gt; from)</span> &#123;</span><br><span class="line">    to.addAll(from);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考下该操作为什么会报错？</p>
<p>编译器的作用之一就是<strong>进行安全检查并阻止可能发生不安全行为的操作</strong>，<code>copyAll</code> 方法会报错，那么肯定就是编译器觉得该方法有可能会触发不安全的操作。开发者的本意是希望将 Integer 类型的数据转移到 NumberList 中，只有这种操作且这种操作在我们看来肯定是安全的，但是编译器不知道开发者最终所要做的具体操作啊</p>
<p>假设 <code>copyAll</code>方法可以正常调用，那么<code>copyAll</code>方法自然只会把 <code>from</code> 当做 <code>List&lt;Number&gt;</code>来看待。因为 Integer 是 Number 的子类，从 <code>integerList</code> 获取到的数据对于 <code>numberList</code> 来说自然是安全的。而如果我们在<code>copyAll</code>方法中偷偷向 <code>integerList</code> 传入了一个 Number 类型的值的话，那么自然就将抛出异常，因为 from 实际上是 <code>List&lt;Integer&gt;</code>类型</p>
<p>为了阻止这种不安全的行为，编译器选择通过直接报错来进行提示。为了解决报错，我们就需要向编译器做出安全保证：<strong>从 from 取出来的值只会当做 Number 类型，且不会向 from 传入任何值</strong></p>
<p>为了达成以上保证，需要修改下 <code>copyAll</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copyAll</span><span class="params">(List&lt;T&gt; to, List&lt;? extends T&gt; from)</span> &#123;</span><br><span class="line">    to.addAll(from);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>? extends T</code> 表示 <code>from</code> 接受 T 或者 T 的子类型，而不单单是 T 自身，这意味着我们可以安全地从 <code>from</code> 中取值并声明为 T 类型，但由于我们并不知道 T 代表的具体类型，写入操作并不安全，因此编译器会阻止我们向 <code>from</code> 执行传值操作。有了该限制后，从<code>integerList</code>中取出来的值只能是当做 Number 类型，且避免了向<code>integerList</code>插入非法值的可能，此时<code>List&lt;Integer&gt;</code>就相当于<code>List&lt;? extends Number&gt;</code>的子类型了，从而使得 <code>copyAll</code> 方法可以正常使用</p>
<p>简而言之，带 <strong>extends</strong> 限定了上界的通配符类型使得<strong>泛型参数类型是协变的</strong>，即如果 A 是 B 的子类，那么 <code>Generic&lt;A&gt;</code> 就是<code>Generic&lt;? extends B&gt;</code>的子类型</p>
<h1 id="十、泛型逆变"><a href="#十、泛型逆变" class="headerlink" title="十、泛型逆变"></a>十、泛型逆变</h1><p><strong>协变</strong>所能做到的是：如果 A 是 B 的子类，那么 <code>Generic&lt;A&gt;</code> 就是<code>Generic&lt;? extends B&gt;</code>的子类型。<strong>逆变</strong>相反，其代表的是：如果 A 是 B 的子类，那么 <code>Generic&lt;B&gt;</code> 就是 <code>Generic&lt;? super A&gt;</code> 的子类型</p>
<p>协变还比较好理解，毕竟其继承关系是相同的，但逆变就比较反直觉了，整个继承关系都倒过来了</p>
<p>逆变的作用可以通过相同的例子来理解，<code>copyAll</code> 方法如下修改也可以正常使用，此时就是向编译器做出了另一种安全保证：<strong>向 numberList 传递的值只会是 Integer 类型，且从 numberList 取出的值也只会当做 Object 类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copyAll</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; to, List&lt;T&gt; from)</span> &#123;</span><br><span class="line">    to.addAll(from);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>? super T</code>表示 <code>to</code> 接收 T 或者 T 的父类型，而不单单是 T 自身，这意味着我们可以安全地向 <code>to</code> 传类型为 T 的值，但由于我们并不知道 T 代表的具体类型，所以从 <code>to</code> 取出来的值只能是 Object 类型。有了该限制后，<code>integerList</code>只能向 <code>numberList</code>传递类型为 Integer 的值，且避免了从 <code>numberList</code> 中获取到非法类型值的可能，此时<code>List&lt;Number&gt;</code>就相当于<code>List&lt;? super Integer&gt;</code>的子类型了，从而使得 <code>copyAll</code> 方法可以正常使用</p>
<p>简而言之，带 <strong>super</strong> 限定了下界的通配符类型使得<strong>泛型参数类型是逆变的</strong>，即如果 A 是 B 的子类，那么 <code>Generic&lt;B&gt;</code> 就是 <code>Generic&lt;? super A&gt;</code> 的子类型</p>
<h1 id="十一、out-in"><a href="#十一、out-in" class="headerlink" title="十一、out  &amp;  in"></a>十一、out  &amp;  in</h1><p>Java 中关于泛型的困境在 Kotlin 中一样存在，out 和 in 都是 Kotlin 的关键字，其作用都是为了来应对泛型问题。<code>in</code> 和 <code>out</code> 是一个对立面，同时它们又与泛型<strong>不变</strong>相对立，统称为<strong>型变</strong></p>
<ul>
<li>out 本身带有<strong>出去</strong>的意思，本身带有倾向于<strong>取值操作</strong>的意思，用于<strong>泛型协变</strong></li>
<li>in 本身带有<strong>进来</strong>的意思，本身带有倾向于<strong>传值操作</strong>的意思，用于<strong>泛型逆变</strong></li>
</ul>
<p>再来看下相同例子，该例子在 Java 中存在的问题在 Kotlin 中一样有</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> numberList = mutableListOf&lt;Number&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> intList = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    copyAll(numberList, intList) <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line">    numberList.forEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">copyAll</span><span class="params">(to: <span class="type">MutableList</span>&lt;<span class="type">T</span>&gt;, from: <span class="type">MutableList</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    to.addAll(from)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>报错原因和 Java 完全一样，因为此时编译器无法判断出我们到底是否会做出不安全的操作，所以我们依然要来向编译器做出安全保证</p>
<p>此时就需要在 Kotlin 中来实现<strong>泛型协变</strong>和<strong>泛型逆变</strong>了，以下两种方式都可以实现：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">copyAll</span><span class="params">(to: <span class="type">MutableList</span>&lt;<span class="type">T</span>&gt;, from: <span class="type">MutableList</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    to.addAll(from)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">copyAll</span><span class="params">(to: <span class="type">MutableList</span>&lt;<span class="type">in</span> <span class="type">T</span>&gt;, from: <span class="type">MutableList</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    to.addAll(from)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>out</code> 关键字就相当于 Java 中的<code>&lt;?  extends T&gt;</code>，其作用就是限制了 <code>from</code> 不能用于接收值而只能向其取值，这样就避免了从 <code>to</code> 取出值然后向 <code>from</code> 赋值这种不安全的行为了，即实现了泛型协变</p>
<p><code>in</code> 关键字就相当于 Java 中的<code>&lt;? super T&gt;</code>，其作用就是限制了 <code>to</code> 只能用于接收值而不能向其取值，这样就避免了从 <code>to</code> 取出值然后向 <code>from</code> 赋值这种不安全的行为了，即实现了泛型逆变</p>
<blockquote>
<p>从这也可以联想到，<code>MutableList&lt;*&gt;</code> 就相当于 <code>MutableList&lt;out Any?&gt;</code>了，两者都带有相同的限制条件：不允许写值操作，允许读值操作，且读取出来的值只能当做 <code>Any?</code>进行处理</p>
</blockquote>
<h1 id="十二、支持协变的-List"><a href="#十二、支持协变的-List" class="headerlink" title="十二、支持协变的 List"></a>十二、支持协变的 List</h1><p>在上述例子中，想要实现协变还有另外一种方式，那就是使用 List</p>
<p>将 from 的类型声明从 <code>MutableList&lt;T&gt;</code>修改为 <code>List&lt;T&gt;</code> 后，可以发现 <code>copyAll</code> 方法也可以正常调用了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">copyAll</span><span class="params">(to: <span class="type">MutableList</span>&lt;<span class="type">T</span>&gt;, from: <span class="type">List</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    to.addAll(from)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 Kotlin 有一定了解的同学应该知道，Kotlin 中的集合框架分为两种大类：<strong>可读可写</strong>和<strong>只能读不能写</strong></p>
<p>以 Java 中的 ArrayList 为例，Kotlin 将之分为了 MutableList 和 List 两种类型的接口。而 List 接口中的泛型已经使用 out 关键字进行修饰了，且不包含任何<strong>传入值并保存</strong>的方法，即 List 接口<strong>只支持读值而不支持写值</strong>，其本身就已经满足了协变所需要的条件，因此<code>copyAll</code> 方法可以正常使用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;<span class="type">out E</span>&gt; : <span class="type">Collection</span>&lt;<span class="type">E</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> size: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isEmpty</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: @<span class="type">UnsafeVariance</span> <span class="type">E</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;E&gt;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">containsAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;@<span class="type">UnsafeVariance</span> <span class="type">E</span>&gt;)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: E</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">indexOf</span><span class="params">(element: @<span class="type">UnsafeVariance</span> <span class="type">E</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">lastIndexOf</span><span class="params">(element: @<span class="type">UnsafeVariance</span> <span class="type">E</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">listIterator</span><span class="params">()</span></span>: ListIterator&lt;E&gt;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">listIterator</span><span class="params">(index: <span class="type">Int</span>)</span></span>: ListIterator&lt;E&gt;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">subList</span><span class="params">(fromIndex: <span class="type">Int</span>, toIndex: <span class="type">Int</span>)</span></span>: List&lt;E&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然 List 接口中有几个方法也接收了 E 类型的入参参数，但该方法本身不会进行写值操作，所以实际上可以正常使用，Kotlin 也使用 <code>@UnsafeVariance</code>抑制了编译器警告</p>
</blockquote>
<h1 id="十三、reified-inline"><a href="#十三、reified-inline" class="headerlink" title="十三、reified  &amp;  inline"></a>十三、reified  &amp;  inline</h1><p>上文讲了，由于类型擦除，Java 和 Kotlin 的泛型类型实参都会在编译阶段被擦除，在 Kotlin 中存在一个额外手段可以来解决这个问题，即<strong>内联函数</strong></p>
<p>用关键字 inline 标记的函数就称为内联函数，再用 reified 关键字修饰内联函数中的泛型形参，编译器在进行编译的时候便会将内联函数的字节码插入到每一个调用的地方，当中就包括泛型的类型实参。而内联函数的类型形参能够被实化，就意味着我们可以在运行时引用实际的类型实参了</p>
<p>例如，我们可以写出以下这样的一个内联函数，用于判断一个对象是否是指定类型</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="number">1.</span>isInstanceOf&lt;String&gt;())</span><br><span class="line">    println(<span class="string">&quot;string&quot;</span>.isInstanceOf&lt;<span class="built_in">Int</span>&gt;())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> Any.<span class="title">isInstanceOf</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> <span class="keyword">is</span> T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将以上的 Kotlin 代码反编译为 Java 代码，可以看出来 <code>main()</code>方法最终是没有调用 <code>isInstanceOf</code> 方法的，具体的判断逻辑都被插入到了<code>main()</code>方法内部，最终是执行了 <code>instanceof</code> 操作，且指定了具体的泛型类型参数 String 和 Integer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">GenericTest6Kt</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">$this$isInstanceOf$iv</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">$i$f$isInstanceOf</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">var2</span> <span class="operator">=</span> $<span class="built_in">this</span>$isInstanceOf$iv <span class="keyword">instanceof</span> String;</span><br><span class="line">      $i$f$isInstanceOf = <span class="literal">false</span>;</span><br><span class="line">      System.out.println(var2);</span><br><span class="line">      <span class="type">Object</span> <span class="variable">$this$isInstanceOf$iv</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">      $i$f$isInstanceOf = <span class="literal">false</span>;</span><br><span class="line">      var2 = $<span class="built_in">this</span>$isInstanceOf$iv <span class="keyword">instanceof</span> Integer;</span><br><span class="line">      $i$f$isInstanceOf = <span class="literal">false</span>;</span><br><span class="line">      System.out.println(var2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] var0)</span> &#123;</span><br><span class="line">      main();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isInstanceOf</span><span class="params">(Object $<span class="built_in">this</span>$isInstanceOf)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">$i$f$isInstanceOf</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      Intrinsics.checkNotNullParameter($<span class="built_in">this</span>$isInstanceOf, <span class="string">&quot;$this$isInstanceOf&quot;</span>);</span><br><span class="line">      Intrinsics.reifiedOperationMarker(<span class="number">3</span>, <span class="string">&quot;T&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> $<span class="built_in">this</span>$isInstanceOf <span class="keyword">instanceof</span> Object;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>inline 和 reified 比较有用的一个场景是用在 Gson 反序列的时候。由于泛型运行时<strong>类型擦除</strong>的问题，目前用 Gson 反序列化泛型类时步骤是比较繁琐的，利用 inline 和 reified 我们就可以简化很多操作</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> gson = Gson()</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">toBean</span><span class="params">(json: <span class="type">String</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> gson.fromJson(json, T::<span class="keyword">class</span>.java)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">BlogBean</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> url: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> json = <span class="string">&quot;&quot;&quot;&#123;&quot;name&quot;:&quot;业志陈&quot;,&quot;url&quot;:&quot;https://juejin.cn/user/923245496518439&quot;&#125;&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">val</span> listJson = <span class="string">&quot;&quot;&quot;[&#123;&quot;name&quot;:&quot;业志陈&quot;,&quot;url&quot;:&quot;https://juejin.cn/user/923245496518439&quot;&#125;,&#123;&quot;name&quot;:&quot;业志陈&quot;,&quot;url&quot;:&quot;https://juejin.cn/user/923245496518439&quot;&#125;]&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> blogBean = toBean&lt;BlogBean&gt;(json)</span><br><span class="line">    <span class="keyword">val</span> blogMap = toBean&lt;Map&lt;String, String&gt;&gt;(json)</span><br><span class="line">    <span class="keyword">val</span> blogBeanList = toBean&lt;List&lt;BlogBean&gt;&gt;(listJson)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//BlogBean(name=业志陈, url=https://juejin.cn/user/923245496518439)</span></span><br><span class="line">    println(blogBean)</span><br><span class="line">    <span class="comment">//&#123;name=业志陈, url=https://juejin.cn/user/923245496518439&#125;</span></span><br><span class="line">    println(blogMap)</span><br><span class="line">    <span class="comment">//[&#123;name=业志陈, url=https://juejin.cn/user/923245496518439&#125;, &#123;name=业志陈, url=https://juejin.cn/user/923245496518439&#125;]</span></span><br><span class="line">    println(blogBeanList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我也利用 Kotlin 的这个强大特性写了一个用于简化 Java &#x2F; Kotlin 平台的序列化和反序列化操作的库：<a target="_blank" rel="noopener" href="https://github.com/leavesCZY/JsonHolder">JsonHolder</a></p>
<h1 id="十四、总结"><a href="#十四、总结" class="headerlink" title="十四、总结"></a>十四、总结</h1><p>最后来做个简单的总结</p>
<table>
<thead>
<tr>
<th></th>
<th>协变</th>
<th>逆变</th>
<th>不变</th>
</tr>
</thead>
<tbody><tr>
<td>Kotlin</td>
<td><code>&lt;out T&gt;</code>，只能作为消费者，只能读取不能添加</td>
<td><code>&lt;in T&gt;</code>，只能作为生产者，只能添加，读取出的值只能当做 Any 类型</td>
<td><code>&lt;T&gt;</code>，既可以添加也可以读取</td>
</tr>
<tr>
<td>Java</td>
<td><code>&lt;?  extends T&gt;</code>，只能作为消费者，只能读取不能添加</td>
<td><code>&lt;? super T&gt;</code>，只能作为生产者，只能添加，读取出的值只能当做 Object 类型</td>
<td><code>&lt;T&gt;</code>，既可以添加也可以读取</td>
</tr>
</tbody></table>

  </article>
  <!-- tag -->
  <div class="mt-12 pt-6 border-t border-gray-200">
    
  </div>
  <!-- prev and next -->
  <div class="flex justify-between mt-12 pt-6 border-t border-gray-200">
    <div>
      
        <a href="/hexo-blog/public/2025/03/02/md/kotlin/%E4%B8%80%E6%96%87%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20ConstraintLayout/" class="text-sm text-gray-400 hover:text-gray-500 flex justify-center">
          <iconify-icon width="20" icon="ri:arrow-left-s-line" data-inline="false"></iconify-icon>
          一文快速入门 ConstraintLayout
        </a>
      
    </div>
    <div>
      
        <a href="/hexo-blog/public/2025/03/02/md/kotlin/Kotlin%20%E5%8D%8F%E7%A8%8B%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%881%EF%BC%89%E5%8D%8F%E7%A8%8B%E5%9F%BA%E7%A1%80/" class="text-sm text-gray-400 hover:text-gray-500 flex justify-center">
          Kotlin 协程官方文档（1）协程基础
          <iconify-icon width="20" icon="ri:arrow-right-s-line" data-inline="false"></iconify-icon>
        </a>
      
    </div>
  </div>
  <!-- comment -->
  <div class="article-comments mt-12">
    
<script
  src="https://giscus.app/client.js"
  data-repo="hqqich/giscus"
  data-repo-id="R_kgDOOCZUBA"
  data-category="General"
  data-category-id="DIC_kwDOOCZUBM4Cng1l"
  data-mapping="pathname"
  data-strict="0"
  data-reactions-enabled="1"
  data-emit-metadata="0"
  data-input-position="bottom"
  data-theme="preferred_color_scheme"
  data-lang="zh-CN"
  crossorigin="anonymous"
  async
></script>
<script>
  window.onload = function () {
    console.log("giscus loaded");
    const isDark = document.documentElement.classList.contains("dark");
    const giscusFrame = document.querySelector("iframe.giscus-frame");
    giscusFrame.contentWindow.postMessage(
      {
        giscus: {
          setConfig: {
            theme: isDark ? "dark" : "light",
          },
        },
      },
      "https://giscus.app"
    );
  };
</script>


  </div>
</section>
<!-- js inspect -->

<script src="/hexo-blog/public/lib/clipboard.min.js"></script>


<script async src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
  });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>



<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
  $(document).ready(() => {
    const maraidConfig = {
      theme: "default",
      logLevel: 3,
      flowchart: { curve: "linear" },
      gantt: { axisFormat: "%m/%d/%Y" },
      sequence: { actorMargin: 50 },
    };
    mermaid.initialize(maraidConfig);
  });
</script>



<script src="/hexo-blog/public/lib/fancybox/fancybox.umd.min.js"></script>

<script>
  $(document).ready(() => {
    $('.post-content').each(function(i){
      $(this).find('img').each(function(){
        if ($(this).parent().hasClass('fancybox') || $(this).parent().is('a')) return;
        var alt = this.alt;
        if (alt) $(this).after('<span class="fancybox-alt">' + alt + '</span>');
        $(this).wrap('<a class="fancybox-img" href="' + this.src + '" data-fancybox=\"gallery\" data-caption="' + alt + '"></a>')
      });
      $(this).find('.fancybox').each(function(){
        $(this).attr('rel', 'article' + i);
      });
    });

    Fancybox.bind('[data-fancybox="gallery"]', {
        // options
    })
  })
</script>

<!-- tocbot begin -->

<script src="/hexo-blog/public/lib/tocbot/tocbot.min.js"></script>

<script>
  $(document).ready(() => {
      tocbot.init({
        // Where to render the table of contents.
        tocSelector: '.post-toc',
        // Where to grab the headings to build the table of contents.
        contentSelector: '.post-content',
        // Which headings to grab inside of the contentSelector element.
        headingSelector: 'h1, h2, h3',
        // For headings inside relative or absolute positioned containers within content.
        hasInnerContainers: true,
    });
  })
</script>
<!-- tocbot end -->


  </main>
  <footer class="flex flex-col h-40 items-center justify-center text-gray-400 text-sm">
  <!-- busuanzi -->
  
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- Busuanzi Analytics -->
<div class="flex items-center gap-2">
  <span>Visitors</span>
  <span id="busuanzi_value_site_uv"></span>
  <span>Page Views</span>
  <span id="busuanzi_value_site_pv"></span>
</div>
<!-- End Busuanzi Analytics -->


  <!-- copyright -->
  <div class="flex items-center gap-2">
    <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" style="color: inherit;">CC BY-NC-SA 4.0</a>
    <span>© 2022</span>
    <iconify-icon width="18" icon="emojione-monotone:maple-leaf" ></iconify-icon>
    <a href="https://github.com/xbmlz" target="_blank" rel="noopener noreferrer">xbmlz</a>
  </div>
  <!-- powered by -->
  <div class="flex items-center gap-2">
    <span>Powered by</span>
    <a href="https://hexo.io/" target="_blank" rel="noopener noreferrer">Hexo</a>
    <span>&</span>
    <a href="https://github.com/xbmlz/hexo-theme-maple" target="_blank" rel="noopener noreferrer">Maple</a>
  </div>

</footer>

  <div class="back-to-top box-border fixed right-6 z-1024 -bottom-20 rounded py-1 px-1 bg-slate-900 opacity-60 text-white cursor-pointer text-center dark:bg-slate-600">
    <span class="flex justify-center items-center text-sm">
      <iconify-icon width="18" icon="ion:arrow-up-c" id="go-top"></iconify-icon>
      <span id="scrollpercent"><span>0</span> %</span>
    </span>
  </div>
  
<script src="/hexo-blog/public/js/main.js"></script>


  <script>
    $(document).ready(function () {
      const mapleCount = "10";
      const speed = "0.5";
      const mapleEl = document.getElementById("maple");
      const maples = Array.from({ length: mapleCount }).map(() => {
        const maple = document.createElement("div");
        const scale = Math.random() * 0.5 + 0.5;
        const offset = Math.random() * 2 - 1;
        const x = Math.random() * mapleEl.clientWidth;
        const y = -Math.random() * mapleEl.clientHeight;
        const duration = 10 / speed;
        const delay = -duration;
        maple.className = "maple";
        maple.style.width = `${24 * scale}px`;
        maple.style.height = `${24 * scale}px`;
        maple.style.left = `${x}px`;
        maple.style.top = `${y}px`;
        maple.style.setProperty("--maple-fall-offset", offset);
        maple.style.setProperty("--maple-fall-height", `${Math.abs(y) + mapleEl.clientHeight}px`);
        maple.style.animation = `fall ${duration}s linear infinite`;
        maple.style.animationDelay = `${delay}s`;
        mapleEl.appendChild(maple)
        return maple
      })
    });
  </script>
  


  <div class="fixed top-0 bottom-0 left-0 right-0 pointer-events-none print:hidden" id="maple"></div>
</body>

</html>

# 代码规范

<!-- TOC -->
* [代码规范](#代码规范)
    * [命名规范](#命名规范)
    * [路由规范](#路由规范)
    * [前后端交互规范](#前后端交互规范)
    * [日期时间规范](#日期时间规范)
    * [SQL语句规范](#sql语句规范)
    * [WEB网络安全规范](#web网络安全规范)
    * [maven及第三方工具规范](#maven及第三方工具规范)
    * [常量规范](#常量规范)
    * [代码格式](#代码格式)
    * [数据类型规范](#数据类型规范)
    * [字符串规范](#字符串规范)
    * [数组集合规范](#数组集合规范)
    * [SpringBoot规范](#springboot规范)
    * [java程序优化手段](#java程序优化手段)
    * [部署规范](#部署规范)
<!-- TOC -->

> 有时间学习下`kotlin`，best java(最好的java)。就像ts于js一样，kotlin于java。
> 
> 下图是java学习路线：
> 
> [![pP1Q0L4.png](https://s1.ax1x.com/2023/08/17/pP1Q0L4.png)](https://imgse.com/i/pP1Q0L4)


## 命名规范

1. 代码中的命名不能使用拼音与英文混合的方式，更不允许直接使用中文的方式。 说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。
   - 正例：tsinglink / hefei 等国际通用的名称，可视同英文。
   - 反例：DaZhePromotion [打折] / getPingfenByName() [评分] / `int a = 3`


2. 类名使用UpperCamelCase风格。
   - 正例：ForceCode / UserDO / HtmlDTO / XmlService / TcpUdpDeal / TaPromotion
   - 反例：forcecode / UserDo / HTMLDto / XMLService / TCPUDPDeal / TAPromotion


3. 方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格。
   - 正例： localValue / getHttpMessage() / inputUserId


4. 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。
   - 正例：MAX_STOCK_COUNT / CACHE_EXPIRED_TIME
   - 反例：MAX_COUNT / EXPIRED_TIME


5. 抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类命名以它要测试的类的名称开始，以Test结尾。
   - 正例：AbstractActivity / BaseActivity / CheckException / ActivityTest


6. 类型与中括号紧挨相连来表示数组。
   - 正例：定义整形数组int[] arrayDemo。
   - 反例：在main参数中，使用String args[]来定义。


7. javaBean类中的任何布尔类型的变量，都不要加is前缀，否则部分框架解析会引起序列化错误(jackson就会)。
   - 反例：isAdmin。
   - 参考：[文档](https://www.cnblogs.com/del88/p/13537360.html)


8. 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。
   - 正例：应用工具类包名为com.tsinglink.ai.web.util、类名为MessageUtils（此规则参考spring的框架结构）


9. 遇到长单词时不要胡乱缩写。
   - 反例：AbstractClass“缩写”成AbsClass；condition“缩写”成 condi；Function缩写”成Fu，此类随意缩写严重降低了代码的可阅读性。


10. 在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。
   - 正例：startTime / workQueue / nameList / TERMINATED_THREAD_COUNT
   - 反例：startedAt / QueueOfWork / listName / COUNT_TERMINATED_THREAD


11. 如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。
   - 正例： `public class OrderFactory;` `public class LoginProxy;` `public class ResourceObserver;`


12. 接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的Javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，确定与接口方法相关，并且是整个应用的基础常量。
   - 正例：接口方法签名 void commit(); 接口基础常量 String COMPANY = "alibaba"; 
   - 反例：接口方法定义 public abstract void f();
   - 说明：JDK8中接口允许有默认实现，那么这个default方法，是对所有实现类都有价值的默认实现。


13. 接口和实现类的命名有两套规则：
    1) 对于Service和DAO类，基于SOA的理念，暴露出来的服务一定是接口，内部的实现类用Impl的后缀与接口区别。
       - 正例：CacheServiceImpl实现CacheService接口。
    2) 如果是形容能力的接口名称，取对应的形容词为接口名（通常是–able的形容词）。
       - 正例：AbstractTranslator实现 Translatable接口。


14. 枚举类名带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开。
    - 说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。
    - 正例：枚举名字为ProcessStatusEnum的成员名称：SUCCESS / UNKNOWN_REASON。


15. 各层命名规约：
    A) Service/DAO层方法命名规约
        1） 获取单个对象的方法用get做前缀。
        2） 获取多个对象的方法用list做前缀，复数结尾，如：listObjects。
        3） 获取统计值的方法用count做前缀。
        4） 插入的方法用save/insert做前缀。
        5） 删除的方法用remove/delete做前缀。
        6） 修改的方法用update做前缀。
    B) 领域模型命名规约
        1） 数据对象：xxxDO，xxx即为数据表名。
        2） 数据传输对象：xxxDTO，xxx为业务领域相关的名称。
        3） 展示对象：xxxVO，xxx一般为网页名称。
        4） POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO。


## 路由规范

1. 路由命名规范：模块名/页面名/功能名
   - 正例：`/user/login` `/user/register` `/user/forgetPassword`
   - 反例：`/login` `/register` `/forgetPassword`


2. 使用“-”连接长单词
   - 正例：`https://developers.google.com/search/docs/beginner/seo-starter-guide`
   - 反例：`https://developers.google.com/search/docs/beginner/seoStarterGuide`


3. 避免在URL中使用特殊字符，例如逗号，分号，冒号，空格，引号等。
   - 正例：`/user/login`
   - 反例：`/us er:/login`


4. 常见协议
   1) `tcp://17.22.90.1:1111`
   2) `ftp://user:password@ftp.tsinglink.com/rj2b/README.md`
   3) `ssh://git@git.jetbrains.space/tsinglink/ahfd/power-misc.git`
   4) `grpc://localhost:8181`
   5) `ws(s)://127.0.0.1:8080/live/test110.flv`
   6) `rtmp://172.22.90.1:1935/hls1/test​`
   7) `rtsp://172.22.90.1:544/live/test110`
   8) `http(s)://user:password@www.tsinglink.com/rj2b/index.html`
   9) `jdbc:mysql://localhost:3306/ebank?useUnicode=true&characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai`
   10) `redis://[password@]172.22.90.1:6379/0?db=0`
   11) `mongodb://myuser:mypassword@localhost:27017/mydb?authSource=admin&ssl=true`


## 前后端交互规范


1. 前后端交互使用JSON格式，不能使用XML，且JSON的key必须使用双引号包裹。
   - 正例：`{"name":"张三","age":18}`
   - 反例：`{name:"张三",age:18}`  `<?xml version="1.0" encoding="UTF-8" ?><name>张三</name><age>18</age>`


2. 前后端交互的JSON中，key必须使用驼峰命名法。
   - 正例：`{"userName":"张三","userAge":18}`
   - 反例：`{"user_name":"张三","user_age":18}`


3. 前后端交互的JSON中，key必须使用英文单词。
   - 正例：`{"userName":"张三","userAge":18}`
   - 反例：`{"用户名":"张三","年龄":18}`


4. 前后端数据列表相关的接口返回，如果为空，则返回空数组`[]`或空集合`{}`。
   - 正例：`{"data":[]}`
   - 反例：`{"data":null}`
   - 说明：减少前端很多null判断。


5. 对于需要使用超大整数的场景，服务端一律使用String字符串类型返回，禁止使用Long类型。
   - 正例：`{"id":"123456789012345678901234567890"}`
   - 反例：`{"id":123456789012345678901234567890}`
   - 说明：Java服务端如果直接返回Long整型数据给前端，JS会自动转换为Number类型（注：此类型为双精度浮点数，表示原理与取值范围等同于Java中的Double）。Long类型能表示的最大值是2的63次方-1，在取值范围之内，超过2的53次方 (9007199254740992)的数值转化为JS的Number时，有些数值会有精度损失。扩展说明，在Long取值范围内，任何2的指数次整数都是绝对不会存在精度损失的，所以说精度损失是一个概率问题。若浮点数尾数位与指数位空间不限，则可以精确表示任何整数，但很不幸，双精度浮点数的尾数位只有52位。 反例：通常在订单号或交易号大于等于16位，大概率会出现前后端单据不一致的情况，比如，"orderId": 362909601374617692，前端拿到的值却是: 362909601374617660。


6. HTTP请求通过URL传递参数时，不能超过2048字节。
   - 说明：不同浏览器对于URL的最大长度限制略有不同，并且对超出最大长度的处理逻辑也有差异，2048字节是取所有浏览器的最小值。


7. HTTP请求通过URL传递参数时，参数值必须进行URL编码。
   - 说明：URL编码后的参数值，不能包含特殊字符，例如：空格、+、&、/、?、%、#、=、:、;、,、$、@、<、>、{}、|、\、^、~、[、]、`、"、中文等。


8. HTTP请求通过body传递内容时，必须控制长度，超出最大长度后，后端解析会出错。
   - 说明：nginx默认限制是1MB，tomcat默认限制为2MB，当确实有业务需要传较大内容时，可以通过调大服务器端的限制。
   - 反例：`json`，`formData`里面放`base64`的文件，图片


9. 在分页中，用户输入参数的小于1，则前端返回第一页参数给后端；后端发现用户输入的参数大于总页数，直接返回最后一页。


10. 前后端的时间格式统一为"`yyyy-MM-dd HH:mm:ss`"，统一为UTC。
   - 正例：2021-01-01 00:00:00
   - 反例：2021-1-1 0:0:0
   - 说明：前端传递的时间格式，必须是"`yyyy-MM-dd HH:mm:ss`"，后端返回的时间格式，必须是"`yyyy-MM-dd HH:mm:ss`"，且统一为UTC。


## 日期时间规范


1. 日期格式化时，传入`pattern`中表示年份统一使用小写的y。
   - 正例：表示日期和时间的格式如下所示： new SimpleDateFormat("yyyy-MM-dd HH:mm:ss")
   - 说明：日期格式化时，yyyy表示当天所在的年，而大写的YYYY代表是week in which year（JDK7之后引入的概念），意思是当天所在的周属于的年份，一周从周日开始，周六结束，只要本周跨年，返回的YYYY就是下一年。


2. 在日期格式中分清楚大写的M和小写的m，大写的H和小写的h分别指代的意义。
   - 说明：日期格式中的这两对字母表意如下：
      1) 表示月份是大写的M;
      2) 表示分钟则是小写的m;
      3) 24小时制的是大写的H;
      4) 12小时制的则是小写的h.


3. 获取当前毫秒数：`System.currentTimeMillis()`; 而不是`new Date().getTime()`。
   - 说明：`System.currentTimeMillis()`的调用比`new Date().getTime()`的调用效率高，因为后者在`new Date()`时，会创建一个Date对象，而`System.currentTimeMillis()`则不会。如果想获取更加精确的纳秒级时间值，使用`System.nanoTime`的方式。在JDK8中，针对统计时间等场景，推荐使用`Instant`类。


4. 不允许在程序任何地方中使用：
    1) `java.sql.Date`。
    2) `java.sql.Time`。
    3) `java.sql.Timestamp`。
   - 说明：第1个不记录时间，`getHours()`抛出异常；第2个不记录日期，`getYear()`抛出异常；第3个在构造方法`super((time/1000)*1000)`，在`Timestamp` 属性`fastTime`和`nanos`分别存储秒和纳秒信息。
   - 反例：`java.util.Date.after(Date)`进行时间比较时，当入参是`java.sql.Timestamp`时，会触发JDK BUG(JDK9已修复)，可能导致比较时的意外结果。


5. 不要在程序中写死一年为365天，避免在公历闰年时出现日期转换错误或程序逻辑错误。
   - 正例：// 获取今年的天数 `int daysOfThisYear = LocalDate.now().lengthOfYear();` // 获取指定某年的天数 `LocalDate.of(2011, 1, 1).lengthOfYear();`
   - 反例：// 第一种情况：在闰年366天时，出现数组越界异常 `int[] dayArray = new int[365];` // 第二种情况：一年有效期的会员制，今年1月26日注册，硬编码365返回的却是1月25日 `Calendar calendar = Calendar.getInstance(); calendar.set(2020, 1, 26); calendar.add(Calendar.DATE, 365);`


6. 使用枚举值来指代月份。如果使用数字，注意`Date`，`Calendar`等日期相关类的`月份month`取值在0-11之间。
   - 正例：Calendar.JANUARY，Calendar.FEBRUARY，Calendar.MARCH等来指代相应月份来进行传参或比较。
   - 说明：参考JDK原生注释，`Month value is 0-based. e.g., 0 for January.`


7. 时间加减，时间比较使用`LocalDateTime`,`DateTime`,`LocalDate`类。
   - 正例：`LocalDateTime.now().plusDays(1);` `LocalDateTime.now().minusDays(1);` `LocalDateTime.now().isAfter(LocalDateTime.now());`
   - 反例：`Calendar.getInstance().add(Calendar.DATE, 1);` `Calendar.getInstance().add(Calendar.DATE, -1);` `Calendar.getInstance().after(Calendar.getInstance());`



## SQL语句规范


1. SQL语句中的表名、字段名、别名等，一律使用小写字母，单词之间使用下划线分隔。
   - 正例：`select user_name from user_info where user_id = 1`
   - 反例：`select userName from userInfo where userId = 1`


2. 不要使用`count(列名)`或`count(常量)`来替代`count(*)`，`count(*)`是SQL92定义的标准统计行数的语法，跟数据库无关，跟`NULL`和`非NULL`无关。
   - 说明：`count(*)`会统计值为NULL的行，而`count(列名)`不会统计此列为NULL值的行。
   - 正例：`count(*)`
   - 反例：`count(1)`


3. `count(distinct col)` 计算该列除NULL之外的不重复行数，注意 `count(distinct col1, col2)` 如果其中一列全为`NULL`，那么即使另一列有不同的值，也返回为0。
   - 正例：`count(distinct col)`
   - 反例：`count(distinct col1, col2)`


4. 当某一列的值全是`NULL`时，`count(col)`的返回结果为0，但`sum(col)`的返回结果为`NULL`，因此使用`sum()`时需注意NPE问题。
   - 正例：`select sum(col) from table;`可以使用如下方式来避免sum的NPE问题：`SELECT IFNULL(SUM(column), 0) FROM table;`
   - 反例：`select count(col) from table;`
   - 说明：数据库中`sum()`函数的计算结果为`NULL`，即使数据库表中该列全为`NULL`值，`sum()`函数也会返回0，这与`count()`函数的处理方式不同。


5. 使用`ISNULL()`来判断是否为`NULL`值。
   - 说明：`NULL`与任何值的直接比较都为`NULL`。
      1） `NULL<>NULL`的返回结果是`NULL`，而不是`false`。
      2） `NULL=NULL`的返回结果是`NULL`，而不是`true`。
      3） `NULL<>1`的返回结果是`NULL`，而不是`true`。


6. 不要用存储过程，自定义函数等来实现业务逻辑。
   - 说明：难以调试和扩展，更没有移植性。


7. 慎用`for update`，可能会导致死锁。
   - 反例：`select * from table where id = 1 for update;  --查询 table 表中 id 为 1 的记录，并对这些记录加上排他锁。`
   - 说明：借助for update语句，我们可以在应用程序的层面手工实现数据加锁保护操作。就是那些需要业务层面数据独占时，可以考虑使用for update。 比如火车票订票，在屏幕上显示有票，而真正进行出票时，需要重新确定一下这个数据没有被其他客户端修改。所以，在这个确认过程中，可以使用for update。


8. 查询和变更时，只要涉及多个表，都需要在列名前加表的别名（或表名）进行限定。
   - 正例：`select t1.id, t2.name from table1 t1, table2 t2 where t1.id = t2.id;`
   - 反例：`select id, name from table1, table2 where table1.id = table2.id;`


9. SQL语句中表的别名前加as，并且以 缩写... 的顺序依次命名。
   - 正例：`select tf.name from table_first as tf, table_second as ts where tf.id=ts.id;`
   - 反例：`select tf.name from table_first tf, table_second ts where tf.id=ts.id;`


10. `in`操作能避免则避免，若实在避免不了，需要仔细评估`in`后边的集合元素数量，控制在1000个之内。
   - 说明：`in`操作会导致全表扫描，性能较差。


11. 采用`utf8字符集`，那么字符计数方法需要注意。
   - 说明：utf8编码汉字占用3个字节，而latin1编码汉字占用2个字节，因此，对于字段长度的限制，需要注意编码的字节长度。SELECT LENGTH("清新互联")； 返回为12 SELECT CHARACTER_LENGTH("清新互联")； 返回为4 如果需要存储表情，那么选择utf8mb4来进行存储，注意它与utf8编码的区别。


12. `TRUNCATE TABLE` 比 `DELETE` 速度快，且使用的系统和事务日志资源少，但`TRUNCATE`无事务且不触发`trigger`，有可能造成事故，故不建议在开发代码中使用此语句。 
   - 说明：`TRUNCATE TABLE` 是截断表，在功能上与不带 `WHERE` 子句的 `DELETE` 语句相同。


13. `@Transactional`事务不要滥用。
   - 说明：不要所有方法都启用事务。事务会影响数据库的QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。


14. 更新数据表记录时，必须同时更新记录对应的`update_time`字段值为当前时间。
   - 说明：`update_time`字段类型为`datetime`，更新时通过`now()`函数获取当前时间戳，而不是通过程序获取当前时间戳。


15. 更新时，修改了什么就更新什么，不要所有字段都更新。
   - 说明：执行SQL时，不要更新无改动的字段，一是易出错；二是效率低；三是增加binlog存储[一篇文章搞懂bin-log](https://blog.csdn.net/qq_33522097/article/details/127053453)。



## WEB网络安全规范


1. 任何用户输入的内容都需要进行安全过滤，包括但不限于：`SQL注入`、`XSS攻击`、`CSRF攻击`、`文件上传漏洞`、`敏感信息泄露`等。
   - 说明：对于用户输入的内容，一定要进行安全过滤，防止用户输入恶意内容，导致系统安全漏洞。


2. 于用户个人的页面或者功能必须进行权限控制校验。
   - 防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信内容。


3. 不要直接拼接sql语句，防止sql注入。
   - 说明：使用PreparedStatement或者Mybatis的动态sql。


## maven及第三方工具规范


1. 使用多模块构建项目。
   - 说明：多模块构建项目，可以将项目拆分成多个模块，每个模块都是一个独立的项目，可以单独编译、单独测试、单独运行，也可以依赖其他模块，方便管理和维护。
   [![pPQKPFf.png](https://s1.ax1x.com/2023/08/15/pPQKPFf.png)](https://imgse.com/i/pPQKPFf)


2. 发起http请求推荐使用`OkHttp`。
   - 说明：因为android用的都是它，所以这里也用它，方便维护。


3. 工具包推荐使用`guava`,`commons-lang3`,不要使用`Hutool`。


4. 所有pom文件中的依赖声明放在`<dependencies>`语句块中，所有版本管理放在`<dependencyManagement>`语句块中。 
   - 说明：`<dependencyManagement>`里只是声明版本，并不实现引入，因此子项目需要显式的声明依赖，`version`和`scope`都读取自`父pom`。而`<dependencies>`所有声明在`主pom`的`<dependencies>`里的依赖都会自动引入，并默认被所有的子项目继承。


5. 网上找的jar包，一定要去官网找，不要去第三方网站下载，防止被植入病毒。不要找`SNAPSHOT版本`（安全包除外）；正式发布的类库必须先去中央仓库进行查证，使`RELEASE版本号`有延续性，且版本号不允许覆盖升级。


6. 遵循`GVA`原则，定义`GAV`遵从以下规则：
   1） `GroupID`格式：`com.{公司}.业务线 [.子业务线]`，最多4级。
      - 说明：`{公司}` 例如：tsinglink；子业务线可选。
      - 正例：`com.tsinglink.tasad`(AI平台) 或 `com.tsinglink.scposwf.hnfd`(新能源.华能风电)
   2） `ArtifactID`格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。
      - 正例：`web-server`(web服务) / `sync-data`(同步数据) / `power-forecast`(功率预测)
   3） `Version`格式：俺也不懂 `xx.xx.xx`。


7. `json`操作使用`gson`, `jackson`。不要使用`fastjson`有`反序列化漏洞`。


8. 


## 常量规范


1. 不要使用魔法值（即未经定义的常量）直接出现在代码中，应该定义为常量后使用。
   - 说明：魔法值是指在代码中直接出现的数字或字符串，应该定义为常量后使用。
   - 反例：`if (status == 1) { // 1表示启用状态 }`


2. 在`long`或者`Long`赋值时，数值后使用`大写字母L`，不能是`小写字母l`，小写容易跟数字混淆，造成误解。
   - 说明：`Long a = 2l;` 写的是数字的21，还是Long型的2?


3. 不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。
   - 正例：缓存相关常量放在类`CacheConsts`下；系统配置相关常量放在类`SystemConfigConsts`下。
   - 说明：大而全的常量类，杂乱无章，使用查找功能才能定位到修改的常量，不利于理解，也不利于维护。`public static final String GLOBAL CONSTANT = "shared in global" ;`


4. 如果变量值仅在一个固定范围内变化用`enum类型`来定义。
   - 说明：如果存在名称之外的延伸属性应使用`enum类型`。比如表示一年中的第几个季节。


5. 不要使用静态导入
   - 说明：虽然使用静态导入可以简化代码，但是会导致阅读代码的人不知道类中方法和变量的来源，容易造成混乱。



## 代码格式


1. 使用`.editorconfig`统一项目代码风格的配置文件详解
   - 说明：[博客](https://blog.csdn.net/qq_28613375/article/details/131506707)
    ```text
    # EditorConfig is awesome: https://EditorConfig.org
    
    # 顶部的EditorConfig文件
    root = true
    
    # unix风格的换行符，每个文件都以换行符结尾
    [*]
    indent_style = space
    indent_size = 4
    charset = utf-8
    end_of_line = lf
    trim_trailing_whitespace = true
    insert_final_newline = true
    max_line_length = 120
    tab_width = 4
    ij_continuation_indent_size = 8
    ij_formatter_off_tag = @formatter:off
    ij_formatter_on_tag = @formatter:on
    ij_formatter_tags_enabled = false
    ij_smart_tabs = false
    ij_visual_guides = none
    ij_wrap_on_typing = false[*.java]
    indent_style = tab
    
    # 用大括号展开符号匹配多个文件
    # 设置默认字符集
    # 设置所有以.js,.py结尾的文件的编码格式
    [*.{js,py}]
    charset = utf-8
    
    # 使用空格缩进，设置4个空格缩进
    [*.py]
    indent_style = space
    indent_size = 4
    
    # 使用制表符(tab)缩进
    [Makefile]
    indent_style = tab
    
    # 设置lib目录下的所有JS的缩进风格(使用空格缩进，缩进占用两个空格的位置)
    [lib/**.js]
    indent_style = space
    indent_size = 2
    # 匹配确切文件 package.json或.travis.yml
    [{package.json,.travis.yml}]
    indent_style = space
    indent_size = 2
    ```


2. 如果是大括号内为空，则简洁地写成`{}`即可，大括号中间无需换行和空格；如果是非空代码块则：
    1) 左大括号前不换行。
    2) 左大括号后换行。
    3) 右大括号前换行。
    4) 右大括号后还有else等代码则不换行；表示终止的右大括号后必须换行。


3. 左小括号和右边相邻字符之间不出现空格；右小括号和左边相邻字符之间也不出现空格；而左大括号前需要加空格。详见第5条下方正例提示。 
   - 反例：if (`空格`a == b`空格`)


4. if/for/while/switch/do等保留字与括号之间都必须加空格。


5. 任何二目、三目(?:)运算符的左右两边都需要加一个空格。
   - 说明：运算符包括赋值运算符=、逻辑运算符&&、加减乘除符号、三目运行符等。


6. 采用4个空格缩进，禁止使用Tab字符。
   - 说明：如果使用Tab缩进，必须设置1个Tab为4个空格。IDEA设置Tab为4个空格时，请勿勾选`Use tab character`；


7. 注释的双斜线与注释内容之间有且仅有一个空格。
   - 正例： 
      ```java
      // 这是示例注释，请注意在双斜线之后有一个空格
      String commentString = new String();
      ```

8. 声明变量时使用`final`修饰


9. 在进行类型强制转换时，右括号与强制转换值之间不需要任何空格隔开。
   - 正例： 
      ```java
      double first = 3.2d;
      int second = (int)first + 2;
      ```


10. 方法参数在定义和传入时，多个参数逗号后面必须加空格。
   - 正例：下例中实参的args1，后边必须要有一个空格。`method(args1, args2, args3);`


11. IDE的`text file encoding`设置为`UTF-8`; IDE中`文件的换行符`使用`Unix格式`，不要使用`Windows格式`。


12. 显示声明`UID`
   - 说明：在类上使用`@Data`注解时，会自动生成`serialVersionUID`，但是这个值是随机生成的，不利于后期的维护，所以建议手动声明`serialVersionUID`的值。


13. 不要在`final`变量复杂赋值
   - 说明：final变量一旦赋值，就不能再修改，所以在赋值时，一定要保证赋值的过程是简单的，不要在赋值过程中调用方法，或者是进行复杂的逻辑运算。


14. `switch`时不要忘记了 break;
   - 说明：在`switch`语句中，每个`case`后面都要加上`break`，否则会出现意想不到的结果。


15. 不要在`if`语句中使用赋值语句
   - 说明：在`if`语句中使用赋值语句，容易造成误解，所以不要在`if`语句中使用赋值语句。


16. 易变的业务使用脚本语言编写
   - 说明：`java`支持其他的脚本语言，`PHP`, `Ruby`, `Groovy`, `JS`等，
      1) 推荐使用`Groovy`，因为`Groovy`是基于`JVM`的，所以可以直接调用`java`的类库，而且语法和`java`类似，学习成本低。
      2) 易变的业务，比如一些规则，一些配置，一些计算公式等，建议使用脚本语言编写，这样可以方便修改，不需要重新编译代码。
      3) 脚本语言的执行效率比较低，所以不要在脚本中写一些复杂的业务逻辑，这样会影响系统的性能。


17. 不要使用动态编译，
   - 说明：动态编译会影响系统的性能，而且容易出现安全问题，所以不要使用动态编译。可以使用16条中的脚本语言来代替动态编译。


18. 避免使用`instanceof`来判断对象类型
   - 说明：使用`instanceof`来判断对象类型，会导致代码的耦合性增强，不利于后期的维护，所以不要使用`instanceof`来判断对象类型。


19. 不要使用`==`来判断字符串是否相等
   - 说明：因为`==`操作符比较的是两个对象的引用地址，而不是它们的内容。对于字符串对象，应该使用 `.equals()` 或 `.equalsIgnoreCase()` 方法来进行内容比较。这适用于 Java 中的所有对象，不仅限于字符串。


20. 使用`optional`处理null类型的判断
   - 说明：`optional`是Java8中引入的一个新的类，用来处理null类型的判断，可以有效的避免空指针异常，所以在使用的时候，尽量使用`optional`来处理null类型的判断。
   - 正例： 
      ```java
      Optional<String> optional = Optional.ofNullable(null);
      optional.ifPresent(System.out::println);
      ```
   - 反例： 
      ```java
      String str = null;
      if (str != null) {
          System.out.println(str);
      }
      ```


## 数据类型规范


1. 在使用`BigDecimal`时，必须使用`String`来构造，禁止使用`double`或者`float`来构造。
   - 说明：`double`和`float`只能用来做科学计算或者是工程计算，在商业计算中，我们要使用`BigDecimal`来进行精确计算。


2. 精度要求较高的计算时，使用`BigDecimal`或整数。
   - 说明：
      1) 在商业计算中，我们要使用`BigDecimal`来进行精确计算。
      2) 或者将小数放大多少倍变成整数来处理。
      3) 四舍五入，可以使用`BigDecimal`的`setScale`方法来进行处理。


3. 不要使用包装类型比较大小
   - 说明：包装类型比较大小，会自动拆箱，可能会出现空指针异常，所以不要使用包装类型比较大小。



## 字符串规范


1. 推荐使用`string`直接量赋值
   - 正例：`String str = "abc";`
   - 反例：`String str = new String("abc");`


2. 注意方法中传递参数的要求
   - 说明：如果方法中传递的参数是字符串，那么一定要注意参数的要求，比如参数是否允许为null，参数的长度限制，是否是需要传入一个正则表达式等。


3. 正确使用 `String`, `StringBuffer`, `StringBuilder`
   - 说明：
      1) 在字符串不经常变化的场景中可以使用`String类`，例如常量的声明、少量的变量运算等。
      2) 在频繁进行字符串的运算(如拼接、替换、删除等)，并且运行在多线程的环境中，则可以考虑使用`StringBuffer`,例如XML解析、HTTP参数解析和封装等。
      3) 在频繁进行字符串的运算(如拼接、替换、删除等)，并且运行在单线程的环境中，则可以考虑使用`StringBuilder`,如SQL语句的拼装、JSON封装等。


4. 注意字符串的位置
   - 说明：
      ```java
      String str1 = 1 + 2 + "abc"; // 3abc
      String str2 = abc + 1 + 2; // abc12
      ```


5. 自由选择字符串拼接方法
   - 说明：在进行字符串拼接时，可以自由选择使用`+`操作符或者是`StringBuilder`的`append`方法，但是在进行大量的字符串拼接时，推荐使用`StringBuilder`的`append`方法，因为`+`操作符会产生大量的临时对象，会影响系统的性能。
      1) `+` 等价于：`new StringBuilder().append("a").toString();` 每一次循环都创建一个对象


7. 推荐在复杂的字符串操作中使用正则表达式
   - 说明：追加，合并，替换，倒叙，分割等，使用正则。


8. 建议使用UTF编码
   - 正例：
      ```java
      String str = "清新互联";
      byte[] bytes = str.getBytes("UTF-8");
      String result = new String(bytes, "UTF-8");
      ```


9. 使用Guava的Joiner,Splitter和CharMatcher来进行字符串的拼接,分割和字符匹配
   - 正例： 
      ```java
      String[] strArray = {"a", "b", "c"};
      String result = Joiner.on(",").skipNulls().join(strArray);
      ```
   - 反例： 
      ```java
      String[] strArray = {"a", "b", "c"};
      String result = "";
      for (String str : strArray) {
          if (str != null) {
              result += str + ",";
          }
      }
      ```


10. 读取文件时，不要写死分割符`\`,用`File.separator`代替
   - 说明：在windows系统中，文件的分割符是`\`，而在linux系统中，文件的分割符是`/`，所以在读取文件时，不要写死分割符`\`，而是使用`File.separator`代替。


## 数组集合规范


1. 关于`hashCode`和`equals`的处理，遵循如下规则：
   1) 只要覆写equals，就必须覆写hashCode。
   2) 因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须覆写这两种方法。
   3) 如果自定义对象作为Map的键，那么必须覆写hashCode和equals。
   - 说明：String因为覆写了hashCode和equals方法，所以可以愉快地将String对象作为key来使用。


2. 判断所有集合内部的元素是否为空，使用`isEmpty()`方法，而不是`size()==0`的方式。
   - 说明：`size()==0`的方式，会遍历集合一遍，性能较差。在某些集合中，前者的时间复杂度为O(1)，而且可读性更好。
   - 正例： 
      ```java
      Map<String, Object> map = new HashMap<>(16);
      if (map.isEmpty()) {
          System.out.println("map为空");
      }
      ```


3. 在使用`java.util.stream.Collectors`类的`toMap()`方法转为Map集合时，一定要使用含有参数类型为`BinaryOperator`，参数名为`mergeFunction`的方法，否则当出现相同key值时会抛出`IllegalStateException异常`。
   - 说明：参数mergeFunction的作用是当出现key重复时，自定义对value的处理策略。 
   - 正例：
      ```java
      List<Pair<String, Double>> pairArrayList = new ArrayList<>(3);
      pairArrayList.add(new Pair<>("version", 12.10));
      pairArrayList.add(new Pair<>("version", 12.19));
      pairArrayList.add(new Pair<>("version", 6.28));
      Map<String, Double> map = pairArrayList.stream().collect(
      // 生成的map集合中只有一个键值对：{version=6.28}
      Collectors.toMap(Pair::getKey, Pair::getValue, (v1, v2) -> v2));
      ```
   - 反例：
      ```java
      String[] departments = new String[] {"iERP", "iERP", "EIBU"};
      // 抛出IllegalStateException异常
      Map<Integer, String> map = Arrays.stream(departments)
      .collect(Collectors.toMap(String::hashCode, str -> str));
      ```


4. 在使用`java.util.stream.Collectors`类的`toMap()`方法转为`Map集合`时，一定要注意当`value`为`null`时会抛`NPE异常`。
   - 说明：在java.util.HashMap的merge方法里会进行如下的判断：
      ```java
      if (value == null || remappingFunction == null)
      throw new NullPointerException(); 
      ```
   - 反例：
      ```java
      List<Pair<String, Double>> pairArrayList = new ArrayList<>(2);
      pairArrayList.add(new Pair<>("version1", 8.3));
      pairArrayList.add(new Pair<>("version2", null));
      Map<String, Double> map = pairArrayList.stream().collect(
      // 抛出NullPointerException异常
      Collectors.toMap(Pair::getKey, Pair::getValue, (v1, v2) -> v2));
      ```


5. `ArrayList`的`subList`结果不可强转成`ArrayList`，否则会抛出 `ClassCastException`异常：`java.util.RandomAccessSubList cannot be cast to java.util.ArrayList`。
   - 说明：`subList()`返回的是`ArrayList`的内部类`SubList`，并不是 `ArrayList`本身，而是`ArrayList` 的一个视图，对于`SubList`的所有操作最终会反映到原列表上。


6. 使用Map的方法`keySet()`/`values()`/`entrySet()`返回集合对象时，不可以对其进行添加元素操作，否则会抛出`UnsupportedOperationException`异常。


7. `Collections`类返回的对象，如：`emptyList()`/`singletonList()`等都是`immutable list  `，不可对其进行添加或者删除元素的操作。
   - 反例：如果查询无结果，返回Collections.emptyList()空集合对象，调用方一旦进行了添加元素的操作，就会触发UnsupportedOperationException异常。


8. 在`subList`场景中，高度注意对父集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生`ConcurrentModificationException`异常。

9. 使用集合转数组的方法，必须使用集合的`toArray(T[] array)`，传入的是类型完全一致、长度为0的空数组。
   - 反例：直接使用`toArray`无参方法存在问题，此方法返回值只能是`Object[]`类，若强转其它类型数组将出现`ClassCastException`错误。
   - 正例：
      ```java
      List<String> list = new ArrayList<>(2);
      list.add("tsing");
      list.add("ling");
      String[] array = list.toArray(new String[0]); 
      ```
   - 说明：使用`toArray`带参方法，数组空间大小的`length`：
      1） 等于0，动态创建与size相同的数组，性能最好。
      2） 大于0但小于size，重新创建大小等于size的数组，增加GC负担。
      3） 等于size，在高并发情况下，数组创建完成之后，size正在变大的情况下，负面影响与2相同。
      4） 大于size，空间浪费，且在size处插入null值，存在NPE隐患。


10. 在使用`Collection`接口任何实现类的`addAll()`方法时，都要对输入的集合参数进行`NPE`判断。
   - 说明：在`ArrayList#addAll`方法的第一行代码即`Object[] a = c.toArray();` 其中c为输入集合参数，如果为null，则直接抛出异常。


11. 使用工具类`Arrays.asList()`把数组转换成集合时，不能使用其修改集合相关的方法(也就是不可变集合)，它的`add/remove/clear`方法会抛出`UnsupportedOperationException`异常。 
   - 说明：asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。 
   ```java
   String[] str = new String[] { "str1", "str2" };
   List list = Arrays.asList(str);
   ```
   1) 第一种情况：`list.add("str3");` 运行时异常。
   2) 第二种情况：`str[0] = "strNew";` 也会随之修改，反之亦然。


12. 泛型通配符`<? extends T>`来接收返回的数据，此写法的泛型集合不能使用add方法，而`<? super T>`不能使用get方法，两者在接口调用赋值的场景中容易出错。 
   - 说明：扩展说一下PECS(Producer Extends Consumer Super)原则：
   1) 第一、频繁往外读取内容的，适合用<? extends T>。
   2) 第二、经常往里插入的，适合用<? super T>


13. 在无泛型限制定义的集合赋值给泛型限制的集合时，在使用集合元素时，需要进行`instanceof`判断，避免抛出`ClassCastException`异常。 
   - 说明：毕竟泛型是在JDK5后才出现，考虑到向前兼容，编译器是允许非泛型集合与泛型集合互相赋值。
   - 反例： 
      ```java
      List<String> generics = new ArrayList<>();
      List notGenerics = new ArrayList(10);
      notGenerics.add(new Object());
      notGenerics.add(new Integer(1));
      generics = notGenerics;
      for (String string : generics) { // 此处抛出ClassCastException异常
          System.out.println(string);
      }
      ```


14. 不要在`foreach`循环里进行元素的`remove`/`add`操作。`remove`元素请使用`Iterator`方式，如果并发操作，需要对`Iterator`对象加锁。
   - 正例：
      ```java
      ist<String> list = new ArrayList<>();
      list.add("1");
      list.add("2");
      Iterator<String> iterator = list.iterator();
      while (iterator.hasNext()) {
         String item = iterator.next();
         if (删除元素的条件) {
            iterator.remove();
         }
      }
      ```
   - 反例：
      ```java
      for (String item : list) {
         if ("1".equals(item)) {
            list.remove(item);
         }
      }
      ```


15. 在JDK7版本及以上，`Comparator`实现类要满足如下三个条件，不然`Arrays.sort`，`Collections.sort`会抛`IllegalArgumentException`异常。 
   - 说明：三个条件如下 
      1） x，y的比较结果和y，x的比较结果相反。 
      2） x>y，y>z，则x>z。 
      3） x=y，则x，z比较结果和y，z比较结果相同。
   - 反例：下例中没有处理相等的情况，交换两个对象判断结果并不互反，不符合第一个条件，在实际使用中 可能会出现异常。
      ```java
      new Comparator<Student>() {
         @Override
         public int compare(Student o1, Student o2) {
            return o1.getId() > o2.getId() ? 1 : -1;
         }
      };
      ```


16. 集合泛型定义时，在JDK7及以上，使用`diamond`语法或全省略。
   - 说明：菱形泛型，即`diamond`，直接使用`<>`来指代前边已经指定的类型。
   - 正例：
      ```java
      // diamond方式，即<>
      HashMap<String, String> userCache = new HashMap<>(16);
      // 全省略方式
      ArrayList<User> users = new ArrayList(10);
      ```


17. 集合初始化时，指定集合初始值大小。
   - 说明：`HashMap`使用`HashMap(int initialCapacity)` 初始化，如果暂时无法确定集合大小，那么指定默认值（`16`）即可。
   - 正例：`initialCapacity = (需要存储的元素个数 / 负载因子) + 1`。注意负载因子（即loader factor）默认为0.75，如果暂时无法确定初始值大小，请设置为16（即默认值）。
   - 反例： `HashMap`需要放置1024个元素，由于没有设置容量初始大小，随着元素增加而被迫不断扩容，`resize()`方法总共会调用8次，反复重建哈希表和数据迁移。当放置的集合元素个数达千万级时会影响程序性能。


18. 使用`entrySet`遍历`Map类`集合KV，而不是`keySet`方式进行遍历。
   - 说明：`keySet`其实是遍历了2次，一次是转为`Iterator`对象，另一次是从`hashMap`中取出`key`所对应的`value`。而`entrySet`只是遍历了一次就把`key`和`value`都放到了`entry`中，效率更高。如果是JDK8，使用`Map.forEach`方法。
   - 正例：`values()`返回的是V值集合，是一个`list集合`对象；`keySet()`返回的是K值集合，是一个`Set集合`对象；`entrySet()`返回的是K-V值组合集合。


19. 高度注意`Map类`集合`K/V`能不能存储`null`值的情况，如下表格：

    | 集合类  | Key  | Value  | Super  | 说明  |
    |---|---|---|---|---|
    | HashTable  | 不允许为null  | 不允许为null  | Dictionary  | 线程安全  |
    | ConcurrentHashMap  | 不允许为null  | 不允许为null  | AbstractMap  | 锁分段技术(JDK1.8:CAS)  |
    | TreeMap  | 不允许为null  | 允许为null  | AbstractMap  | 线程不安全  |
    | HashMap  | 允许为null  | 允许为null  | 允许为null  | 线程不安全  |


20. 合理利用好集合的有序性(`sort`)和稳定性(`order`)，避免集合的无序性(`unsort`)和不稳定性(`unorder`)带来的负面影响。 
   - 说明：有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次序是一定的。如：`ArrayList`是`order/unsort`；`HashMap`是`unorder/unsort`；`TreeSet`是`order/sort`。


21. 利用`Set`元素唯一的特性，可以快速对一个集合进行去重操作，避免使用`List`的`contains()`进行遍历去重或者判断包含操作。
   - 说明：注意对于POJO对象，要正确覆写`hashCode()`和`equals()`方法。


22. 能用数组的地方就不要集合
   - 说明：性能要求较高的场景中，使用数组来代替集合，可以有效的提高系统的性能。
   - 举个例子：
      ```
      // 使用集合
      int sum(List<Integer> list) {
         int sum = 0;
         for (int i : list) {
            sum += i;  // 这里 有拆箱操作
         }
         return sum;
      }

      int sum(int[] array) {
         int sum = 0;
         for (int i : array) {
            sum += i;
         }
         return sum;
      }
      ```
   - 说明：如果需要变长的场景，使用Arrays数组里的copyOf方法来增长。
      ```java
      public static <T> T[] expandCapacity(T[] datas, int newLen) {
         newLen = newLen < 0 ? 0 : newLen;   // 不能是负值
         return Arrays.copyOf(datas, newLen);   // 生成一个新数组，并拷贝原值
      }
      ```




## SpringBoot规范

> 请熟读峰哥的光伏SPringboot框架，(接口文档生成,参数校验,ORM,等)

1. 依赖注入时，使用`构造函数注入`，不要使用`字段注入`和`setter方法注入`。
   - 说明：使用构造函数注入，可以保证依赖的完整性，而且可以保证依赖的不可变性，而且可以避免循环依赖的问题。
   - 正例：
      ```java
      private final TaskService taskService;
      private final SnowflakeIdWorker snowflakeIdWorker;
      @Autowired
      public TaskController(TaskService taskService, SnowflakeIdWorker snowflakeIdWorker) {
          this.taskService = taskService;
          this.snowflakeIdWorker = snowflakeIdWorker;
      }
      ```
   - 反例：`@Autowired private TaskService taskService;`


## java程序优化手段

1. 使用缓存，推荐使用`caffeine`。
   - 说明：缓存是提高系统性能的有效手段，可以有效的减少数据库的访问，提高系统的性能。但是缓存也会带来一些问题，比如缓存的数据和数据库的数据不一致，所以在使用缓存的时候，一定要注意缓存的数据和数据库的数据的一致性。


2. 使用对象池，推荐使用`commons-pool2`。
   - 说明：是一个开源的Java库，提供了对象池（Object Pooling）的实现，用于管理和复用对象，以提高应用程序的性能和资源利用率。以下是 commons-pool2 库的一些优势：
      1) 支持对象池的多种配置，如对象池的大小、对象池的最大空闲时间、对象池的最小空闲时间等。
      2) 对象复用与性能提升。
      3) 减少GC压力。
      4) 连接池和线程池的实现。


3. 调整`JVM`参数
   1) `-Xms`：设置`JVM`初始内存大小。(重要)
   2) `-Xmx`：设置`JVM`最大内存大小。(重要)
   3) `-Xmn`：设置`JVM`新生代大小。
   4) `-XX:NewRatio`：设置`JVM`新生代和老年代的比例。
   5) `-XX:SurvivorRatio`：设置`JVM`新生代中Eden区和Survivor区的比例。
   6) `-XX:MaxTenuringThreshold`：设置`JVM`对象进入老年代的年龄。
   7) `-XX:PermSize`：设置`JVM`永久代大小。
   8) `-XX:MaxPermSize`：设置`JVM`最大永久代大小。
   9) `-XX:MaxDirectMemorySize`：设置`JVM`最大直接内存大小。
   10) `-XX:+UseConcMarkSweepGC`：设置`JVM`使用CMS垃圾回收器。
   11) `-XX:+UseParNewGC`：设置`JVM`使用ParNew垃圾回收器。
   12) `-XX:+UseParallelGC`：设置`JVM`使用Parallel垃圾回收器。
   13) `-XX:+UseParallelOldGC`：设置`JVM`使用Parallel Old垃圾回收器。
   14) `-XX:+UseSerialGC`：设置`JVM`使用Serial垃圾回收器。
   15) `-XX:+UseG1GC`：设置`JVM`使用G1垃圾回收器。
   16) `-XX:+UseTLAB`：设置`JVM`使用TLAB。
   17) `-XX:+DisableExplicitGC`：设置`JVM`禁止显示垃圾回收。
   18) `-XX:+PrintGCDetails`：设置`JVM`打印GC日志。


4. 善用临时目录
    - 说明：在进行文件操作时，可以使用临时目录，可以有效的提高系统的性能。
    - 正例：`File.createTempFile("prefix", "suffix");`


5. 常见java参数
   1) `-Djava.library.path`：设置`java`的`native`库的路径。(java调用C/C++动态库时会用到)
   2) `-Djava.ext.dirs`：设置`java`的扩展库的路径。
   3) `-Djava.class.path`：设置`java`的类路径。
   4) `-Djava.compiler`：设置`java`的编译器。
   5) `-Djava.io.tmpdir`：设置`java`的临时目录。
   6) `-Djava.protocol.handler.pkgs`：设置`java`的协议处理器包。
   7) `-Djava.awt.headless`：设置`java`是否支持`GUI`。
   8) `-Dfile.encoding`：设置`java`的文件编码。
   9) `-Dsun.jnu.encoding`：设置`java`的文件编码。
   - 正例：
```text
"C:\Program Files\Java\jdk1.8.0_333\bin\java.exe" 
-XX:TieredStopAtLevel=1 
-noverify 
-Dspring.output.ansi.enabled=always 
-Dcom.sun.management.jmxremote 
-Dspring.jmx.enabled=true 
-Dspring.liveBeansView.mbeanDomain 
-Dspring.application.admin.enabled=true 
"-Dmanagement.endpoints.jmx.exposure.include=*" 
-javaagent:F:\JetBrains\Toolbox\apps\IDEA-U\ch-0\232.8660.185\lib\idea_rt.jar=49190:F:\JetBrains\Toolbox\apps\IDEA-U\ch-0\232.8660.185\bin 
-Dfile.encoding=UTF-8 
-classpath "C:\Program Files\Java\jdk1.8.0_333\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_333\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_333\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_333\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_333\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_333\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_333\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_333\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_333\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_333\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_333\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_333\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_333\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_333\jre\lib\ext\zipfs.jar;C:\Program Files\Java\jdk1.8.0_333\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_333\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_333\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_333\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_333\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_333\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_333\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_333\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_333\jre\lib\rt.jar;F:\project\kotlin\power-misc\javasrc\admin\target\classes;F:\sorf\apache-maven-3.8.6\repository\org\springframework\boot\spring-boot-starter-data-jpa\2.7.14\spring-boot-starter-data-jpa-2.7.14.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\boot\spring-boot-starter-aop\2.7.14\spring-boot-starter-aop-2.7.14.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\spring-aop\5.3.29\spring-aop-5.3.29.jar;F:\sorf\apache-maven-3.8.6\repository\org\aspectj\aspectjweaver\1.9.7\aspectjweaver-1.9.7.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\boot\spring-boot-starter-jdbc\2.7.14\spring-boot-starter-jdbc-2.7.14.jar;F:\sorf\apache-maven-3.8.6\repository\com\zaxxer\HikariCP\4.0.3\HikariCP-4.0.3.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\spring-jdbc\5.3.29\spring-jdbc-5.3.29.jar;F:\sorf\apache-maven-3.8.6\repository\jakarta\transaction\jakarta.transaction-api\1.3.3\jakarta.transaction-api-1.3.3.jar;F:\sorf\apache-maven-3.8.6\repository\jakarta\persistence\jakarta.persistence-api\2.2.3\jakarta.persistence-api-2.2.3.jar;F:\sorf\apache-maven-3.8.6\repository\org\hibernate\hibernate-core\5.6.15.Final\hibernate-core-5.6.15.Final.jar;F:\sorf\apache-maven-3.8.6\repository\org\jboss\logging\jboss-logging\3.4.3.Final\jboss-logging-3.4.3.Final.jar;F:\sorf\apache-maven-3.8.6\repository\net\bytebuddy\byte-buddy\1.12.23\byte-buddy-1.12.23.jar;F:\sorf\apache-maven-3.8.6\repository\antlr\antlr\2.7.7\antlr-2.7.7.jar;F:\sorf\apache-maven-3.8.6\repository\org\jboss\jandex\2.4.2.Final\jandex-2.4.2.Final.jar;F:\sorf\apache-maven-3.8.6\repository\com\fasterxml\classmate\1.5.1\classmate-1.5.1.jar;F:\sorf\apache-maven-3.8.6\repository\org\hibernate\common\hibernate-commons-annotations\5.1.2.Final\hibernate-commons-annotations-5.1.2.Final.jar;F:\sorf\apache-maven-3.8.6\repository\org\glassfish\jaxb\jaxb-runtime\2.3.8\jaxb-runtime-2.3.8.jar;F:\sorf\apache-maven-3.8.6\repository\org\glassfish\jaxb\txw2\2.3.8\txw2-2.3.8.jar;F:\sorf\apache-maven-3.8.6\repository\com\sun\istack\istack-commons-runtime\3.0.12\istack-commons-runtime-3.0.12.jar;F:\sorf\apache-maven-3.8.6\repository\com\sun\activation\jakarta.activation\1.2.2\jakarta.activation-1.2.2.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\data\spring-data-jpa\2.7.14\spring-data-jpa-2.7.14.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\data\spring-data-commons\2.7.14\spring-data-commons-2.7.14.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\spring-orm\5.3.29\spring-orm-5.3.29.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\spring-context\5.3.29\spring-context-5.3.29.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\spring-tx\5.3.29\spring-tx-5.3.29.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\spring-beans\5.3.29\spring-beans-5.3.29.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\spring-aspects\5.3.29\spring-aspects-5.3.29.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\boot\spring-boot-starter-web\2.7.14\spring-boot-starter-web-2.7.14.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\boot\spring-boot-starter\2.7.14\spring-boot-starter-2.7.14.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\boot\spring-boot-starter-logging\2.7.14\spring-boot-starter-logging-2.7.14.jar;F:\sorf\apache-maven-3.8.6\repository\ch\qos\logback\logback-classic\1.2.12\logback-classic-1.2.12.jar;F:\sorf\apache-maven-3.8.6\repository\ch\qos\logback\logback-core\1.2.12\logback-core-1.2.12.jar;F:\sorf\apache-maven-3.8.6\repository\org\apache\logging\log4j\log4j-to-slf4j\2.17.2\log4j-to-slf4j-2.17.2.jar;F:\sorf\apache-maven-3.8.6\repository\org\apache\logging\log4j\log4j-api\2.17.2\log4j-api-2.17.2.jar;F:\sorf\apache-maven-3.8.6\repository\org\slf4j\jul-to-slf4j\1.7.36\jul-to-slf4j-1.7.36.jar;F:\sorf\apache-maven-3.8.6\repository\jakarta\annotation\jakarta.annotation-api\1.3.5\jakarta.annotation-api-1.3.5.jar;F:\sorf\apache-maven-3.8.6\repository\org\yaml\snakeyaml\1.30\snakeyaml-1.30.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\boot\spring-boot-starter-json\2.7.14\spring-boot-starter-json-2.7.14.jar;F:\sorf\apache-maven-3.8.6\repository\com\fasterxml\jackson\datatype\jackson-datatype-jdk8\2.13.5\jackson-datatype-jdk8-2.13.5.jar;F:\sorf\apache-maven-3.8.6\repository\com\fasterxml\jackson\module\jackson-module-parameter-names\2.13.5\jackson-module-parameter-names-2.13.5.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\boot\spring-boot-starter-tomcat\2.7.14\spring-boot-starter-tomcat-2.7.14.jar;F:\sorf\apache-maven-3.8.6\repository\org\apache\tomcat\embed\tomcat-embed-core\9.0.78\tomcat-embed-core-9.0.78.jar;F:\sorf\apache-maven-3.8.6\repository\org\apache\tomcat\embed\tomcat-embed-el\9.0.78\tomcat-embed-el-9.0.78.jar;F:\sorf\apache-maven-3.8.6\repository\org\apache\tomcat\embed\tomcat-embed-websocket\9.0.78\tomcat-embed-websocket-9.0.78.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\spring-web\5.3.29\spring-web-5.3.29.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\spring-webmvc\5.3.29\spring-webmvc-5.3.29.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\spring-expression\5.3.29\spring-expression-5.3.29.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\boot\spring-boot-devtools\2.7.14\spring-boot-devtools-2.7.14.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\boot\spring-boot\2.7.14\spring-boot-2.7.14.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\boot\spring-boot-autoconfigure\2.7.14\spring-boot-autoconfigure-2.7.14.jar;F:\sorf\apache-maven-3.8.6\repository\com\fasterxml\jackson\module\jackson-module-kotlin\2.13.5\jackson-module-kotlin-2.13.5.jar;F:\sorf\apache-maven-3.8.6\repository\com\fasterxml\jackson\core\jackson-databind\2.13.5\jackson-databind-2.13.5.jar;F:\sorf\apache-maven-3.8.6\repository\com\fasterxml\jackson\core\jackson-core\2.13.5\jackson-core-2.13.5.jar;F:\sorf\apache-maven-3.8.6\repository\com\fasterxml\jackson\core\jackson-annotations\2.13.5\jackson-annotations-2.13.5.jar;F:\sorf\apache-maven-3.8.6\repository\org\jetbrains\kotlin\kotlin-reflect\1.6.21\kotlin-reflect-1.6.21.jar;F:\sorf\apache-maven-3.8.6\repository\org\jetbrains\kotlin\kotlin-stdlib\1.6.21\kotlin-stdlib-1.6.21.jar;F:\sorf\apache-maven-3.8.6\repository\org\jetbrains\kotlin\kotlin-stdlib-common\1.6.21\kotlin-stdlib-common-1.6.21.jar;F:\sorf\apache-maven-3.8.6\repository\org\jetbrains\annotations\13.0\annotations-13.0.jar;F:\sorf\apache-maven-3.8.6\repository\org\jetbrains\kotlin\kotlin-stdlib-jdk8\1.6.21\kotlin-stdlib-jdk8-1.6.21.jar;F:\sorf\apache-maven-3.8.6\repository\org\jetbrains\kotlin\kotlin-stdlib-jdk7\1.6.21\kotlin-stdlib-jdk7-1.6.21.jar;F:\sorf\apache-maven-3.8.6\repository\org\jetbrains\kotlinx\kotlinx-coroutines-core\1.6.4\kotlinx-coroutines-core-1.6.4.jar;F:\sorf\apache-maven-3.8.6\repository\org\jetbrains\kotlinx\kotlinx-coroutines-core-jvm\1.6.4\kotlinx-coroutines-core-jvm-1.6.4.jar;F:\sorf\apache-maven-3.8.6\repository\com\mysql\mysql-connector-j\8.0.33\mysql-connector-j-8.0.33.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\boot\spring-boot-configuration-processor\2.7.14\spring-boot-configuration-processor-2.7.14.jar;F:\sorf\apache-maven-3.8.6\repository\org\projectlombok\lombok\1.18.28\lombok-1.18.28.jar;F:\sorf\apache-maven-3.8.6\repository\jakarta\xml\bind\jakarta.xml.bind-api\2.3.3\jakarta.xml.bind-api-2.3.3.jar;F:\sorf\apache-maven-3.8.6\repository\jakarta\activation\jakarta.activation-api\1.2.2\jakarta.activation-api-1.2.2.jar;F:\sorf\apache-maven-3.8.6\repository\com\vaadin\external\google\android-json\0.0.20131108.vaadin1\android-json-0.0.20131108.vaadin1.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\spring-core\5.3.29\spring-core-5.3.29.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\spring-jcl\5.3.29\spring-jcl-5.3.29.jar;F:\project\kotlin\power-misc\javasrc\dllJar\target\classes;F:\sorf\apache-maven-3.8.6\repository\org\slf4j\slf4j-api\1.7.36\slf4j-api-1.7.36.jar;F:\project\kotlin\power-misc\javasrc\dataSaveSqlite\target\classes;F:\sorf\apache-maven-3.8.6\repository\org\springframework\boot\spring-boot-properties-migrator\2.7.14\spring-boot-properties-migrator-2.7.14.jar;F:\sorf\apache-maven-3.8.6\repository\org\springframework\boot\spring-boot-configuration-metadata\2.7.14\spring-boot-configuration-metadata-2.7.14.jar;F:\sorf\apache-maven-3.8.6\repository\org\xerial\sqlite-jdbc\3.36.0.3\sqlite-jdbc-3.36.0.3.jar;F:\sorf\apache-maven-3.8.6\repository\com\github\gwenn\sqlite-dialect\0.1.2\sqlite-dialect-0.1.2.jar;F:\sorf\apache-maven-3.8.6\repository\com\fasterxml\jackson\datatype\jackson-datatype-jsr310\2.13.5\jackson-datatype-jsr310-2.13.5.jar;F:\sorf\apache-maven-3.8.6\repository\com\google\guava\guava\32.1.1-jre\guava-32.1.1-jre.jar;F:\sorf\apache-maven-3.8.6\repository\com\google\guava\failureaccess\1.0.1\failureaccess-1.0.1.jar;F:\sorf\apache-maven-3.8.6\repository\com\google\guava\listenablefuture\9999.0-empty-to-avoid-conflict-with-guava\listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar;F:\sorf\apache-maven-3.8.6\repository\com\google\code\findbugs\jsr305\3.0.2\jsr305-3.0.2.jar;F:\sorf\apache-maven-3.8.6\repository\org\checkerframework\checker-qual\3.33.0\checker-qual-3.33.0.jar;F:\sorf\apache-maven-3.8.6\repository\com\google\errorprone\error_prone_annotations\2.18.0\error_prone_annotations-2.18.0.jar;F:\sorf\apache-maven-3.8.6\repository\com\google\j2objc\j2objc-annotations\2.8\j2objc-annotations-2.8.jar;F:\sorf\apache-maven-3.8.6\repository\com\google\code\gson\gson\2.9.1\gson-2.9.1.jar" 
com.tsinglink.javasrc.JavasrcApplicationKt
```


## 部署规范


1. 服务器上的文件夹命名规范，不要用中文路径
   - windows: `D:\tsinglink\项目(英文)\模块(英文)\`
   - linux: `/opt/tsinglink/项目(英文)/模块(英文)/`


2. 服务器上jar包命名规范
   - `项目-模块-Version.jar`
   - 例如：`ahfd-web-20230816.jar`


3. 建议使用`pm2`部署，和node项目兼容
   - 好处：
      1) 可以使用`pm2`的监控功能，可以监控项目的运行状态，如果项目挂了，可以自动重启项目。
      2) 借用`pm2`实现项目开机自启项目。
      3) 可以使用`pm2`的日志功能，可以查看项目的日志。不用控制台日志了。


4. web服务建议使用`nginx`做反向代理
   - 好处：
      1) 可以实现负载均衡，可以将请求分发到不同的服务器上。
      2) 可以实现动静分离，将静态资源和动态资源分开，提高系统的性能。
      3) 可以实现反向代理，可以隐藏服务器的真实IP地址，提高系统的安全性。


5. jar包部署时，将配置(如：`application.yml`、`logback.xml`)放在同级目录下的`config`文件夹中
   - 说明：将配置文件放在`config`文件夹中，可以方便的管理配置文件，而且可以避免配置文件和jar包混在一起，方便管理。

     [![pP1KZmd.png](https://s1.ax1x.com/2023/08/17/pP1KZmd.png)](https://imgse.com/i/pP1KZmd)


6. springboot项目jar包部署时，通过命令行参数改变配置文件某个属性的值
   - 说明：通过命令行参数改变配置文件某个属性的值，可以方便的修改配置文件的某个属性的值，而不用修改配置文件，方便管理。
   - 正例：`java -jar xxx.jar --server.port=8080 --spring.profiles.active=dev --tsinglink.version='1.0.0'`
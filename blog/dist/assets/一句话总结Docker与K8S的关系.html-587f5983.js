import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as t,c,a as e,d as n,e as a,f as d}from"./app-6847d3e4.js";const s={},p=d('<blockquote><p>一句话总结：Docker只是容器的一种，它面向的是单体，K8S可以管理多种容器，它面向的是集群，Docker可以作为一种容器方案被K8S管理。下文继续具体介绍。</p></blockquote><h3 id="_1、容器的核心概念" tabindex="-1"><a class="header-anchor" href="#_1、容器的核心概念" aria-hidden="true">#</a> 1、容器的核心概念</h3><p>介绍这几个核心概念：OCI、CR、Runc、Containerd、CRI。</p><h4 id="_1-1、容器运行规范" tabindex="-1"><a class="header-anchor" href="#_1-1、容器运行规范" aria-hidden="true">#</a> 1.1、容器运行规范</h4><p>容器运行规范OCI（Open Container Initiative）即开放的容器运行时规范，定义了镜像和容器运行时的规范。</p><p>容器镜像规范：该规范的目标是创建可互操作的工具，用于构建、传输和准备运行的容器镜像。</p><p>容器运行时规范：该规范用于定义容器的配置、执行环境和生命周期。</p><h4 id="_1-2、容器运行时" tabindex="-1"><a class="header-anchor" href="#_1-2、容器运行时" aria-hidden="true">#</a> 1.2、容器运行时</h4><p>容器运行时（Container Runtime）负责以下工作：拉取镜像、提取镜像到文件系统、为容器准备挂载点、从容器镜像中设置元数据以确保容器按预期运行、提醒内核为该容器分配某种隔离、提醒内核为该容器分配资源限制、调用系统指令启动容器等。</p><p>容器运行时的有如下方案：Containerd、CRI-O 、Kata、Virtlet等等。</p><h4 id="_1-3、runc" tabindex="-1"><a class="header-anchor" href="#_1-3、runc" aria-hidden="true">#</a> 1.3、RunC</h4><p>RunC （Run Container）是从 Docker 的 libcontainer 中迁移而来的，实现了容器启停、资源隔离等功能。Docker将RunC捐赠给 OCI 作为OCI 容器运行时标准的参考实现。</p><p>RunC是一个基于OCI标准实现的一个轻量级容器运行工具，用来创建和运行容器。纯从系统角度，Runc才是底层的容器运行时 。</p><h4 id="_1-4、containerd" tabindex="-1"><a class="header-anchor" href="#_1-4、containerd" aria-hidden="true">#</a> 1.4、Containerd</h4><p>Containerd是用来维持通过RunC创建的容器的运行状态。即RunC用来创建和运行容器，containerd作为常驻进程用来管理容器。<code>containerd（container daemon）</code>是一个daemon进程用来管理和运行容器，可以用来拉取/推送镜像和管理容器的存储和网络。其中可以调用runc来创建和运行容器。</p><p>很早之前的 Docker Engine 中就有了 Containerd，只不过现在是将 Containerd 从 Docker Engine 里分离出来，作为一个独立的开源项目，目标是提供一个更加开放、稳定的容器运行基础设施。分离出来的Containerd 将具有更多的功能，涵盖整个容器运行时管理的所有需求，提供更强大的支持。</p><p>Containerd 是一个工业级标准的容器运行时，它强调<strong>简单性</strong>、<strong>健壮性</strong>和<strong>可移植性</strong>，Containerd 可以负责干下面这些事情：</p><ul><li>管理容器的生命周期（从创建容器到销毁容器）</li><li>拉取/推送容器镜像</li><li>存储管理（管理镜像及容器数据的存储）</li><li>调用 runc 运行容器（与 runc 等容器运行时交互）</li><li>管理容器网络接口及网络</li></ul><p><strong>K8S自v1.24 起，已经删除了Dockershim</strong> ，使用Containerd作为容器运行时。选择 Containerd原因是，它的调用链更短，组件更少，更稳定，占用节点资源更少。</p><h4 id="_1-5、docker、containerd、runc的关系" tabindex="-1"><a class="header-anchor" href="#_1-5、docker、containerd、runc的关系" aria-hidden="true">#</a> 1.5、Docker、Containerd、RunC的关系</h4><p>三者关系，见下图：</p><figure><img src="https://img.mangod.top/blog/202308191006949.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://img.mangod.top/blog/202308190953039.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_1-6、cri" tabindex="-1"><a class="header-anchor" href="#_1-6、cri" aria-hidden="true">#</a> 1.6、CRI</h4><p>容器运行时是 Kubernetes（K8S） 最重要的组件之一，负责管理镜像和容器的生命周期。Kubelet 通过 <code>Container Runtime Interface (CRI)</code> 与容器运行时交互，以管理镜像和容器。</p><p><strong>CRI即容器运行时接口，主要用来定义K8S与容器运行时的API调用</strong>，kubelet通过CRI来调用容器运行时，只要实现了CRI接口的容器运行时就可以对接到K8S的kubelet组件。</p><figure><img src="https://img.mangod.top/blog/202308191024448.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_2、docker和k8s的关系" tabindex="-1"><a class="header-anchor" href="#_2、docker和k8s的关系" aria-hidden="true">#</a> 2、Docker和K8S的关系</h3><p>Docker和K8S本质上都是创建容器的工具，Docker作用与单机，K8S作用与集群。</p><p>在单机的容器解决方案，首选Docker。随着时代的发展，对系统的性能有了更高的要求，高可用、高并发都是基本要求。随着要求变高的的同时，单机显然性能就跟不上了，服务器集群管理就是发展趋势，所以 Kubernetes 为代表的云原生技术强势发展。</p><h4 id="_2-1、容器创建调用链路" tabindex="-1"><a class="header-anchor" href="#_2-1、容器创建调用链路" aria-hidden="true">#</a> 2.1、容器创建调用链路</h4><p>Docker、Kubernetes、OCI、CRI-O、containerd、runc，他们是如何一起协作的呢，见下图。</p><figure><img src="https://img.mangod.top/blog/202308191135670.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上图所示为容器的调用链路。如图我们看到的，只要是实现了CRI的容器运行时就能够被K8S采用。Containerd是通过CRI Plugin 来适配CRI的，而CRI-O则是为CRI量生打造。</p><p>我们还可以看到包括了Docker和K8S两条主线，其中Docker主要是在面向单体应用，K8S是用于集群。</p><h4 id="_2-2、关系" tabindex="-1"><a class="header-anchor" href="#_2-2、关系" aria-hidden="true">#</a> 2.2、关系</h4><p>从上面的容器调用链路可以看到，对于Containerd 和 CRI-O我们非常清楚他们是干嘛的，但是对于Docker和K8S间的联系我们还需要再来理一下。</p><figure><img src="https://img.mangod.top/blog/202308191031983.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如图为K8S与Docker之间的联系（包含K8S1.23版本在内以及之前的版本），从K8S-1.24版本开始将移除docker-shim模块。下面继续看看他们之间的小故事。</p><h3 id="_3、dockershim的小故事" tabindex="-1"><a class="header-anchor" href="#_3、dockershim的小故事" aria-hidden="true">#</a> 3、Dockershim的小故事</h3><h4 id="_3-1、dockershim的由来" tabindex="-1"><a class="header-anchor" href="#_3-1、dockershim的由来" aria-hidden="true">#</a> 3.1、dockershim的由来</h4><p>自 K8S - v1.24 起，Dockershim 已被删除，这对K8S项目来说是一个积极的举措。</p><p>在 K8S 的早期，只支持一个容器运行时，那个容器运行时就是 Docker Engine。 那时并没有其他的选择。</p><p>随着时间推移，我们开始添加更多的容器运行时，比如 rkt 和 hypernetes，很明显 K8S 用户希望选择最适合他们的运行时。因此，K8S 需要一种方法来允许K8S集群灵活地使用任何容器运行时。</p><p>于是有了容器运行时接口 (CRI) 的发布，CRI 的引入对K8S项目和K8S用户来说都很棒，但它引入了一个问题：Docker Engine 作为容器运行时的使用早于 CRI，所以Docker Engine 不兼容 CRI。</p><p>为了解决这个问题，在 kubelet 组件中引入了一个小型软件 shim (dockershim)，专门用于填补 Docker Engine 和 CRI 之间的空白， 允许集群继续使用 Docker Engine 作为容器运行时。</p><h4 id="_3-2、dockershim的宿命" tabindex="-1"><a class="header-anchor" href="#_3-2、dockershim的宿命" aria-hidden="true">#</a> 3.2、dockershim的宿命</h4><p>然而，这个小软件 shim 从来没有打算成为一个永久的解决方案。 多年来，它的存在给 kubelet 本身带来了许多不必要的复杂性。由于这个 shim，Docker 的一些集成实现不一致，导致维护人员的负担增加。</p><p>总之，这样的方式不但带来了更高的复杂度，而且由于部件的增加也增加了不稳定的因素，同时还增加了维护负担，所以弃用dockershim是迟早的事。</p><p><strong>总结</strong>：<strong>dockershim</strong> 一直都是 K8S 社区为了能让 Docker 成为其支持的容器运行时，所维护的一个兼容程序。 现在**所谓的废弃，**也仅仅是 K8S 要放弃对现在代码仓库中的 dockershim 的维护支持。以便K8S可以像刚开始时计划的那样，仅负责维护其 CRI ，任何兼容 CRI 的容器运行时，都可以作为 K8S 的 runtime。</p><p><strong>3.3、流转图：</strong></p><figure><img src="https://img.mangod.top/blog/202308191031628.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>总结</strong>：本文讲了<strong>容器的核心概念、Docker和K8S的关系、Dockershim的小故事</strong>，希望对你有帮助！</p><p><strong>本篇完结！感谢你的阅读，欢迎点赞 关注 收藏 私信！！！</strong></p>',54),h=e("strong",null,"原文链接：",-1),g={href:"https://mp.weixin.qq.com/s/jmoxfDJxYKK7sLQLylaS8w",target:"_blank",rel:"noopener noreferrer"},l=e("figure",null,[e("img",{src:"https://img.mangod.top/blog/202305191058876.jpg",alt:"",tabindex:"0",loading:"lazy"}),e("figcaption")],-1),u={href:"https://www.cnblogs.com/mangod/p/18007490",target:"_blank",rel:"noopener noreferrer"};function m(k,_){const r=o("ExternalLinkIcon");return t(),c("div",null,[p,e("p",null,[h,e("a",g,[n("https://mp.weixin.qq.com/s/jmoxfDJxYKK7sLQLylaS8w"),a(r)])]),l,e("p",null,[n("本文转自 "),e("a",u,[n("https://www.cnblogs.com/mangod/p/18007490"),a(r)]),n("，如有侵权，请联系删除。")])])}const b=i(s,[["render",m],["__file","一句话总结Docker与K8S的关系.html.vue"]]);export{b as default};

import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as c,c as l,a as n,d as s,e,f as t}from"./app-6847d3e4.js";const i={},u={href:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adbc507fc3704fd8955aae739a433db2~tplv-k3u1fbpfcp-zoom-1.image",target:"_blank",rel:"noopener noreferrer"},r=n("p",null,"希望对你有所帮助 🤣🤣",-1),k=n("p",null,[s("最近一直在了解关于 "),n("strong",null,"Kotlin协程"),s(" 的知识，那最好的学习资料自然是官方提供的学习文档了，看了看后我就萌生了翻译官方文档的想法。前后花了要接近一个月时间，一共九篇文章，在这里也分享出来，希望对读者有所帮助。个人知识所限，有些翻译得不是太顺畅，也希望读者能提出意见")],-1),d={href:"https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md",target:"_blank",rel:"noopener noreferrer"},m=t(`<p>Deferred 值提供了在协程之间传递单个值的方便方法，而通道（Channels）提供了一种传输值流的方法</p><h1 id="一、通道基础" tabindex="-1"><a class="header-anchor" href="#一、通道基础" aria-hidden="true">#</a> 一、通道基础</h1><p>通道在概念上非常类似于 <code>BlockingQueue</code>，它们之间的一个关键区别是：通道有一个挂起的 send 函数和一个挂起的 receive 函数，而不是一个阻塞的 put 操作和一个阻塞的 take 操作</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span><span class="token operator">*</span>
<span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span>channels<span class="token punctuation">.</span><span class="token operator">*</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking <span class="token punctuation">{</span>
    <span class="token comment">//sampleStart</span>
    <span class="token keyword">val</span> channel <span class="token operator">=</span> Channel<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    launch <span class="token punctuation">{</span>
        <span class="token comment">// this might be heavy CPU-consuming computation or async logic, we&#39;ll just send five squares</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>x <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">..</span><span class="token number">5</span><span class="token punctuation">)</span> channel<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// here we print five received integers:</span>
    <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Done!&quot;</span></span><span class="token punctuation">)</span>
    <span class="token comment">//sampleEnd</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果是:</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token number">1</span>
<span class="token number">4</span>
<span class="token number">9</span>
<span class="token number">16</span>
<span class="token number">25</span>
Done<span class="token operator">!</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="二、关闭和迭代通道" tabindex="-1"><a class="header-anchor" href="#二、关闭和迭代通道" aria-hidden="true">#</a> 二、关闭和迭代通道</h1><p>与队列不同，通道可以关闭，以此来表明元素已发送完成。在接收方，使用常规的 for 循环从通道接收元素是比较方便的</p><p>从概念上讲，close 类似于向通道发送一个特殊的 cloase 标记。一旦接收到这个 close 标记，迭代就会停止，因此可以保证接收到 close 之前发送的所有元素：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span><span class="token operator">*</span>
<span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span>channels<span class="token punctuation">.</span><span class="token operator">*</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking <span class="token punctuation">{</span>
    <span class="token comment">//sampleStart</span>
    <span class="token keyword">val</span> channel <span class="token operator">=</span> Channel<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    launch <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>x <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">..</span><span class="token number">5</span><span class="token punctuation">)</span> channel<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x<span class="token punctuation">)</span>
        channel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// we&#39;re done sending</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// here we print received values using \`for\` loop (until the channel is closed)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>y <span class="token keyword">in</span> channel<span class="token punctuation">)</span> <span class="token function">println</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Done!&quot;</span></span><span class="token punctuation">)</span>
    <span class="token comment">//sampleEnd</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="三、构建通道生产者" tabindex="-1"><a class="header-anchor" href="#三、构建通道生产者" aria-hidden="true">#</a> 三、构建通道生产者</h1><p>协程生成元素序列(sequence )的模式非常常见。这是可以经常在并发编程中发现的生产者-消费者模式的一部分。你可以将这样一个生产者抽象为一个以 channel 为参数的函数，但这与必须从函数返回结果的常识相反</p><p>有一个方便的名为 product 的协程构造器，它使得在 producer 端执行该操作变得很容易；还有一个扩展函数 consumerEach，它替换了consumer 端的 for 循环：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span><span class="token operator">*</span>
<span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span>channels<span class="token punctuation">.</span><span class="token operator">*</span>

<span class="token keyword">fun</span> CoroutineScope<span class="token punctuation">.</span><span class="token function">produceSquares</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> ReceiveChannel<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span> <span class="token operator">=</span> produce <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>x <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">..</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token function">send</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking <span class="token punctuation">{</span>
    <span class="token comment">//sampleStart</span>
    <span class="token keyword">val</span> squares <span class="token operator">=</span> <span class="token function">produceSquares</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    squares<span class="token punctuation">.</span><span class="token function">consumeEach</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Done!&quot;</span></span><span class="token punctuation">)</span>
    <span class="token comment">//sampleEnd</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="四、管道" tabindex="-1"><a class="header-anchor" href="#四、管道" aria-hidden="true">#</a> 四、管道</h1><p>管道是一种模式，是一个协程正在生成的可能是无穷多个元素的值流</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">fun</span> CoroutineScope<span class="token punctuation">.</span><span class="token function">produceNumbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> produce<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token function">send</span><span class="token punctuation">(</span>x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// infinite stream of integers starting from 1</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>存在一个或多个协程对值流进行取值，进行一些处理并产生一些其它结果。在下面的示例中，每个返回值也是入参值（数字）的平方值</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">fun</span> CoroutineScope<span class="token punctuation">.</span><span class="token function">square</span><span class="token punctuation">(</span>numbers<span class="token operator">:</span> ReceiveChannel<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> ReceiveChannel<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span> <span class="token operator">=</span> produce <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>x <span class="token keyword">in</span> numbers<span class="token punctuation">)</span> <span class="token function">send</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动并连接整个管道：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span><span class="token operator">*</span>
<span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span>channels<span class="token punctuation">.</span><span class="token operator">*</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking <span class="token punctuation">{</span>
    <span class="token comment">//sampleStart</span>
    <span class="token keyword">val</span> numbers <span class="token operator">=</span> <span class="token function">produceNumbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// produces integers from 1 and on</span>
    <span class="token keyword">val</span> squares <span class="token operator">=</span> <span class="token function">square</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span> <span class="token comment">// squares integers</span>
    <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span>squares<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// print first five</span>
    <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Done!&quot;</span></span><span class="token punctuation">)</span> <span class="token comment">// we are done</span>
    coroutineContext<span class="token punctuation">.</span><span class="token function">cancelChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// cancel children coroutines</span>
    <span class="token comment">//sampleEnd</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> CoroutineScope<span class="token punctuation">.</span><span class="token function">produceNumbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> produce<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token function">send</span><span class="token punctuation">(</span>x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// infinite stream of integers starting from 1</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> CoroutineScope<span class="token punctuation">.</span><span class="token function">square</span><span class="token punctuation">(</span>numbers<span class="token operator">:</span> ReceiveChannel<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> ReceiveChannel<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span> <span class="token operator">=</span> produce <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>x <span class="token keyword">in</span> numbers<span class="token punctuation">)</span> <span class="token function">send</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>创建协程的所有函数都被定义为 CoroutineScope 的扩展，因此我们可以依赖结构化并发来确保应用程序中没有延迟的全局协程</p></blockquote><h1 id="五、使用管道的素数" tabindex="-1"><a class="header-anchor" href="#五、使用管道的素数" aria-hidden="true">#</a> 五、使用管道的素数</h1><p>让我们以一个使用协程管道生成素数的例子，将管道发挥到极致。我们从一个无限的数字序列开始</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">fun</span> CoroutineScope<span class="token punctuation">.</span><span class="token function">numbersFrom</span><span class="token punctuation">(</span>start<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">=</span> produce<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x <span class="token operator">=</span> start
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token function">send</span><span class="token punctuation">(</span>x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// infinite stream of integers from start</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以下管道过滤传入的数字流，删除所有可被给定素数整除的数字：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">fun</span> CoroutineScope<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>numbers<span class="token operator">:</span> ReceiveChannel<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token punctuation">,</span> prime<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">=</span> produce<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>x <span class="token keyword">in</span> numbers<span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> prime <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">send</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，我们通过从2开始一个数字流，从当前通道获取一个质数，并为找到的每个质数启动新的管道：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token function">numbersFrom</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">..</span><span class="token punctuation">.</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>下面的示例代码打印了前十个质数，在主线程的上下文中运行整个管道。因为所有的协程都是在主 runBlocking 协程的范围内启动的，所以我们不必保留所有已启动的协程的显式引用。我们使用扩展函数 cancelChildren 来取消打印前十个质数后的所有子协程</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span><span class="token operator">*</span>
<span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span>channels<span class="token punctuation">.</span><span class="token operator">*</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking <span class="token punctuation">{</span>
    <span class="token comment">//sampleStart</span>
    <span class="token keyword">var</span> cur <span class="token operator">=</span> <span class="token function">numbersFrom</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">val</span> prime <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token function">println</span><span class="token punctuation">(</span>prime<span class="token punctuation">)</span>
        cur <span class="token operator">=</span> <span class="token function">filter</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> prime<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    coroutineContext<span class="token punctuation">.</span><span class="token function">cancelChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// cancel all children to let main finish</span>
    <span class="token comment">//sampleEnd    </span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> CoroutineScope<span class="token punctuation">.</span><span class="token function">numbersFrom</span><span class="token punctuation">(</span>start<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">=</span> produce<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x <span class="token operator">=</span> start
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token function">send</span><span class="token punctuation">(</span>x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// infinite stream of integers from start</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> CoroutineScope<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>numbers<span class="token operator">:</span> ReceiveChannel<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token punctuation">,</span> prime<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">=</span> produce<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>x <span class="token keyword">in</span> numbers<span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> prime <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">send</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token number">2</span>
<span class="token number">3</span>
<span class="token number">5</span>
<span class="token number">7</span>
<span class="token number">11</span>
<span class="token number">13</span>
<span class="token number">17</span>
<span class="token number">19</span>
<span class="token number">23</span>
<span class="token number">29</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，你可以使用标准库中的 iterator 协程构造器来构建相同的管道。将 product 替换为 iterator，send 替换为 yield，receive 替换为 next，ReceiveChannel 替换为 iterator，并去掉协程作用域。你也不需要再使用 runBlocking 。但是，使用如上所示的通道的管道的好处是，如果在 Dispatchers.Default 上下文中运行它，它实际上可以利用多个 CPU 来执行代码</p><p>但无论如何，如上所述的替代方案也是一个非常不切实际的来寻找素数的方法。实际上，管道确实涉及一些其他挂起调用（如对远程服务的异步调用），并且这些管道不能使用 sequence/iterator 来构建，因为它们不允许任意挂起，而 product 是完全异步的</p><h1 id="六、扇出" tabindex="-1"><a class="header-anchor" href="#六、扇出" aria-hidden="true">#</a> 六、扇出</h1><p>多个协程可以从同一个通道接收数据，在它们之间分配任务。让我们从一个周期性地生成整数（每秒10个数）的 producer 协程开始：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">fun</span> CoroutineScope<span class="token punctuation">.</span><span class="token function">produceNumbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> produce<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// start from 1</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">send</span><span class="token punctuation">(</span>x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// produce next</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment">// wait 0.1s</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们可以有多个处理器(processor)协程。在本例中，他们只需打印他们的 id 和接收的数字：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">fun</span> CoroutineScope<span class="token punctuation">.</span><span class="token function">launchProcessor</span><span class="token punctuation">(</span>id<span class="token operator">:</span> Int<span class="token punctuation">,</span> channel<span class="token operator">:</span> ReceiveChannel<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">=</span> launch <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>msg <span class="token keyword">in</span> channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Processor #</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">id</span></span><span class="token string"> received </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">msg</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>    
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在让我们启动5个处理器，让它们工作几乎一秒钟。看看会发生什么：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span><span class="token operator">*</span>
<span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span>channels<span class="token punctuation">.</span><span class="token operator">*</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">//sampleStart</span>
    <span class="token keyword">val</span> producer <span class="token operator">=</span> <span class="token function">produceNumbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">launchProcessor</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> producer<span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">950</span><span class="token punctuation">)</span>
    producer<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// cancel producer coroutine and thus kill them all</span>
    <span class="token comment">//sampleEnd</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> CoroutineScope<span class="token punctuation">.</span><span class="token function">produceNumbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> produce<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// start from 1</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">send</span><span class="token punctuation">(</span>x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// produce next</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment">// wait 0.1s</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> CoroutineScope<span class="token punctuation">.</span><span class="token function">launchProcessor</span><span class="token punctuation">(</span>id<span class="token operator">:</span> Int<span class="token punctuation">,</span> channel<span class="token operator">:</span> ReceiveChannel<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">=</span> launch <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>msg <span class="token keyword">in</span> channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Processor #</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">id</span></span><span class="token string"> received </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">msg</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>    
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>尽管接收每个特定整数的处理器 id 可能不同，但运行结果将类似于以下输出：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>Processor #<span class="token number">2</span> received <span class="token number">1</span>
Processor #<span class="token number">4</span> received <span class="token number">2</span>
Processor #<span class="token number">0</span> received <span class="token number">3</span>
Processor #<span class="token number">1</span> received <span class="token number">4</span>
Processor #<span class="token number">3</span> received <span class="token number">5</span>
Processor #<span class="token number">2</span> received <span class="token number">6</span>
Processor #<span class="token number">4</span> received <span class="token number">7</span>
Processor #<span class="token number">0</span> received <span class="token number">8</span>
Processor #<span class="token number">1</span> received <span class="token number">9</span>
Processor #<span class="token number">3</span> received <span class="token number">10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，取消 producer 协程会关闭其通道，从而最终终止 processor 协程正在执行的通道上的迭代</p><p>另外，请注意我们如何使用 for 循环在通道上显式迭代以在 launchProcessor 代码中执行 fan-out。与 consumeEach 不同，这个 for 循环模式在多个协程中使用是完全安全的。如果其中一个 processor 协程失败，则其他处理器仍将处理通道，而通过 consumeEach 写入的处理器总是在正常或异常完成时消费（取消）底层通道</p><h1 id="七、扇入" tabindex="-1"><a class="header-anchor" href="#七、扇入" aria-hidden="true">#</a> 七、扇入</h1><p>多个协程可以发送到同一个通道。例如，有一个字符串通道和一个挂起函数，函数以指定的延迟将指定的字符串重复发送到此通道：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">sendString</span><span class="token punctuation">(</span>channel<span class="token operator">:</span> SendChannel<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span><span class="token punctuation">,</span> s<span class="token operator">:</span> String<span class="token punctuation">,</span> time<span class="token operator">:</span> Long<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">delay</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span>
        channel<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，让我们看看如果启动两个协程来发送字符串会发生什么情况（在本例中，我们将它们作为主协程的子协程，在主线程的上下文中启动）：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span><span class="token operator">*</span>
<span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span>channels<span class="token punctuation">.</span><span class="token operator">*</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking <span class="token punctuation">{</span>
    <span class="token comment">//sampleStart</span>
    <span class="token keyword">val</span> channel <span class="token operator">=</span> Channel<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    launch <span class="token punctuation">{</span> <span class="token function">sendString</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;foo&quot;</span></span><span class="token punctuation">,</span> <span class="token number">200L</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    launch <span class="token punctuation">{</span> <span class="token function">sendString</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;BAR!&quot;</span></span><span class="token punctuation">,</span> <span class="token number">500L</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// receive first six</span>
        <span class="token function">println</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    coroutineContext<span class="token punctuation">.</span><span class="token function">cancelChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// cancel all children to let main finish</span>
    <span class="token comment">//sampleEnd</span>
<span class="token punctuation">}</span>

<span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">sendString</span><span class="token punctuation">(</span>channel<span class="token operator">:</span> SendChannel<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span><span class="token punctuation">,</span> s<span class="token operator">:</span> String<span class="token punctuation">,</span> time<span class="token operator">:</span> Long<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">delay</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span>
        channel<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>foo
foo
BAR<span class="token operator">!</span>
foo
foo
BAR<span class="token operator">!</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="八、带缓冲的通道" tabindex="-1"><a class="header-anchor" href="#八、带缓冲的通道" aria-hidden="true">#</a> 八、带缓冲的通道</h1><p>到目前为止显示的通道都没有缓冲区。无缓冲通道在发送方和接收方同时调用发送和接收操作时传输元素。如果先调用 send，则在调用 receive 之前会将其挂起；如果先调用 receive ，则在调用 send 之前会将其挂起</p><p>Channel() 工厂函数和 produce 构建器都采用可选的参数 <code>capacity</code> 来指定缓冲区大小。 缓冲用于允许发送者在挂起之前发送多个元素，类似于具有指定容量的 BlockingQueue，它在缓冲区已满时才阻塞</p><p>查看以下代码的效果：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span><span class="token operator">*</span>
<span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span>channels<span class="token punctuation">.</span><span class="token operator">*</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">//sampleStart</span>
    <span class="token keyword">val</span> channel <span class="token operator">=</span> Channel<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment">// create buffered channel</span>
    <span class="token keyword">val</span> sender <span class="token operator">=</span> launch <span class="token punctuation">{</span> <span class="token comment">// launch sender coroutine</span>
        <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Sending </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span> <span class="token comment">// print before sending each element</span>
            channel<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token comment">// will suspend when buffer is full</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// don&#39;t receive anything... just wait....</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
    sender<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// cancel sender coroutine</span>
    <span class="token comment">//sampleEnd    </span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用了容量为4的缓冲通道，所以将打印五次：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>Sending <span class="token number">0</span>
Sending <span class="token number">1</span>
Sending <span class="token number">2</span>
Sending <span class="token number">3</span>
Sending <span class="token number">4</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前四个元素被添加到缓冲区内，sender 在尝试发送第五个元素时挂起</p><h1 id="九、通道是公平的" tabindex="-1"><a class="header-anchor" href="#九、通道是公平的" aria-hidden="true">#</a> 九、通道是公平的</h1><p>对通道的发送和接收操作，对于从多个协程调用它们的顺序是公平的。它们按先入先出的顺序提供，例如，先调用 receive 的协程先获取到元素。在下面的示例中，两个协程 “ping” 和 “pong” 从共享的 “table” 通道接收 “ball” 对象</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span><span class="token operator">*</span>
<span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span>channels<span class="token punctuation">.</span><span class="token operator">*</span>

<span class="token comment">//sampleStart</span>
<span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">Ball</span><span class="token punctuation">(</span><span class="token keyword">var</span> hits<span class="token operator">:</span> Int<span class="token punctuation">)</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking <span class="token punctuation">{</span>
    <span class="token keyword">val</span> table <span class="token operator">=</span> Channel<span class="token operator">&lt;</span>Ball<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// a shared table</span>
    launch <span class="token punctuation">{</span> <span class="token function">player</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;ping&quot;</span></span><span class="token punctuation">,</span> table<span class="token punctuation">)</span> <span class="token punctuation">}</span>
    launch <span class="token punctuation">{</span> <span class="token function">player</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;pong&quot;</span></span><span class="token punctuation">,</span> table<span class="token punctuation">)</span> <span class="token punctuation">}</span>
    table<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token function">Ball</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// serve the ball</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token comment">// delay 1 second</span>
    coroutineContext<span class="token punctuation">.</span><span class="token function">cancelChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// game over, cancel them</span>
<span class="token punctuation">}</span>

<span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">player</span><span class="token punctuation">(</span>name<span class="token operator">:</span> String<span class="token punctuation">,</span> table<span class="token operator">:</span> Channel<span class="token operator">&lt;</span>Ball<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>ball <span class="token keyword">in</span> table<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// receive the ball in a loop</span>
        ball<span class="token punctuation">.</span>hits<span class="token operator">++</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">name</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">ball</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span> <span class="token comment">// wait a bit</span>
        table<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>ball<span class="token punctuation">)</span> <span class="token comment">// send the ball back</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//sampleEnd</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>“ping” 协程首先开始运行，所以它是第一个接收到 ball 的。即使 “ping” 协程在将 ball 重新送回给 table 后又立即开始进行 receive，但 ball 还是会被 “pong” 接收到，因为它已经先在等待接收了：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>ping <span class="token function">Ball</span><span class="token punctuation">(</span>hits<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
pong <span class="token function">Ball</span><span class="token punctuation">(</span>hits<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
ping <span class="token function">Ball</span><span class="token punctuation">(</span>hits<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>
pong <span class="token function">Ball</span><span class="token punctuation">(</span>hits<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,66),v={href:"https://github.com/Kotlin/kotlinx.coroutines/issues/111",target:"_blank",rel:"noopener noreferrer"},b=t(`<h1 id="十、计时器通道" tabindex="-1"><a class="header-anchor" href="#十、计时器通道" aria-hidden="true">#</a> 十、计时器通道</h1><p>计时器通道是一种特殊的会合(rendezvous)通道，自该通道的最后一次消耗以来，每次给定的延迟时间结束后都将返回 Unit 值。尽管它看起来是无用处的，但它是一个有用的构建块，可以创建复杂的基于时间的 produce 管道和进行窗口化操作以及其它时间相关的处理。计时器通道可用于 select 执行 “on tick” 操作</p><p>要创建这样的通道，请使用工厂方法 ticker。如果不需要通道发送更多元素了，请对其使用 ReceiveChannel.cancel 取消发送</p><p>现在让我们看看它在实践中是如何工作的：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span><span class="token operator">*</span>
<span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span>channels<span class="token punctuation">.</span><span class="token operator">*</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking<span class="token operator">&lt;</span>Unit<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> tickerChannel <span class="token operator">=</span> <span class="token function">ticker</span><span class="token punctuation">(</span>delayMillis <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> initialDelayMillis <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// create ticker channel</span>
    <span class="token keyword">var</span> nextElement <span class="token operator">=</span> <span class="token function">withTimeoutOrNull</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> tickerChannel<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Initial element is available immediately: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">nextElement</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span> <span class="token comment">// initial delay hasn&#39;t passed yet</span>

    nextElement <span class="token operator">=</span> <span class="token function">withTimeoutOrNull</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> tickerChannel<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token comment">// all subsequent elements has 100ms delay</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Next element is not ready in 50 ms: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">nextElement</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>

    nextElement <span class="token operator">=</span> <span class="token function">withTimeoutOrNull</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> tickerChannel<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Next element is ready in 100 ms: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">nextElement</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>

    <span class="token comment">// Emulate large consumption delays</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Consumer pauses for 150ms&quot;</span></span><span class="token punctuation">)</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">150</span><span class="token punctuation">)</span>
    <span class="token comment">// Next element is available immediately</span>
    nextElement <span class="token operator">=</span> <span class="token function">withTimeoutOrNull</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> tickerChannel<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Next element is available immediately after large consumer delay: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">nextElement</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
    <span class="token comment">// Note that the pause between \`receive\` calls is taken into account and next element arrives faster</span>
    nextElement <span class="token operator">=</span> <span class="token function">withTimeoutOrNull</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> tickerChannel<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> 
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Next element is ready in 50ms after consumer pause in 150ms: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">nextElement</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>

    tickerChannel<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// indicate that no more elements are needed</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>Initial element <span class="token keyword">is</span> available immediately<span class="token operator">:</span> kotlin<span class="token punctuation">.</span>Unit
Next element <span class="token keyword">is</span> not ready <span class="token keyword">in</span> <span class="token number">50</span> ms<span class="token operator">:</span> <span class="token keyword">null</span>
Next element <span class="token keyword">is</span> ready <span class="token keyword">in</span> <span class="token number">100</span> ms<span class="token operator">:</span> kotlin<span class="token punctuation">.</span>Unit
Consumer pauses <span class="token keyword">for</span> 150ms
Next element <span class="token keyword">is</span> available immediately after large consumer delay<span class="token operator">:</span> kotlin<span class="token punctuation">.</span>Unit
Next element <span class="token keyword">is</span> ready <span class="token keyword">in</span> 50ms after consumer pause <span class="token keyword">in</span> 150ms<span class="token operator">:</span> kotlin<span class="token punctuation">.</span>Unit
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，ticker 能感知到消费端可能处于暂停状态，并且在默认的情况下，如果发生暂停，将会延迟下一个元素的生成，尝试保持生成元素的固定速率</p><p>可选的，ticker 函数的 mode 参数可以指定为 TickerMode.FIXED_DELAY，以保证元素之间的固定延迟</p>`,9);function g(f,h){const a=o("ExternalLinkIcon");return c(),l("div",null,[n("blockquote",null,[n("p",null,[s("公众号："),n("a",u,[s("字节数组"),e(a)])]),r]),n("blockquote",null,[k,n("p",null,[s("协程官方文档："),n("a",d,[s("coroutines-guide"),e(a)])])]),m,n("p",null,[s("请注意，有时由于所使用的执行者的性质，通道可能会产生看起来不公平的执行效果。有关详细信息，请参阅此 "),n("a",v,[s("issue"),e(a)])]),b])}const x=p(i,[["render",g],["__file","Kotlin 协程官方文档（6）通道.html.vue"]]);export{x as default};
